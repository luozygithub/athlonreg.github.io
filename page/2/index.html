<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="author" content="luozy">
    
    <meta name="description" content="���������������������̰���������ܼ�������̰����">
    
    
    
    
    
    
    <title>luozy&#39;s Blog</title>
    <!-- inject:style -->
    <link href="/css/style.css" rel="stylesheet" type="text/css">
    <!-- endinject -->
    <style>
        .cube-loading {
            top: 0;
            position: fixed;
            width: 100%;
            height: 100%;
            background: url('/images/lg/loading.gif') no-repeat center center;
            background-color: rgba(0,0,0,.7);
        }

        .cube-loading.out {
            display: none;
        }

        .cube-loading:before {
            display: block;
            content: 'Loading';
            position: relative;
            width: 100%;
            top: 50%;
            right: -50%;
            color: #fff;
        }

        @media(max-width: 768px) {
            .cube-loading:before {
                font-size: 1.2em;
                transform: translate(-24px,20px);
                -webkit-transform: translate(-24px,20px);
                -o-transform: translate(-24px,20px);
                -ms-transform: translate(-24px,20px);
            }
        }

        @media(min-width: 768px) {
            .cube-loading:before {

            }
        }
    </style>
    
</head></html>
<body>
<div class="cube-body">
    <nav id="cube-top-memu" class="cube-menu">
    <ul class="cube-menu-collapse">
        
        <li>
            <i class="cube-icon cube-icon-home" aria-hidden="true"></i>
            <a href="/">首页</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-archive" aria-hidden="true"></i>
            <a href="/archives">归档</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-categories" aria-hidden="true"></i>
            <a href="/categories">分类</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-tags" aria-hidden="true"></i>
            <a href="/tags">标签</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-about" aria-hidden="true"></i>
            <a href="/about-me">关于我</a>
        </li>
        
    </ul>
</nav>
<nav class="cube-side-menu" id="cube-side-menu">
    <ul class="cube-menu-list">
        
        <li>
            <a class="lrc-control">Open Lyrics</a>
        </li>
        
        <li>
            <a class="scroll-to-top">Top</a>
        </li>
    </ul>
</nav>
    <header class="cube-header" id="cube-header">
    <img src=" http://cube-1252774894.cosgz.myqcloud.com/background.png " alt="头部背景图片">
    
    <div class="cube-type">
        <span class="cube-typed-title">Sakuraの娜娜奇</span>
        <span class="cube-typed-cursor">|</span>
    </div>
    
</header>

    <style>
        nav.cube-menu:before {
            content: '';
            visibility: hidden;
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 44px;
        
            filter: blur(4px);
            -webkit-filter: blur(4px);
        
            z-index: -1;
            background-image: url('http://cube-1252774894.cosgz.myqcloud.com/background.png');
            background-repeat: no-repeat;
            background-position: center -356px;
            background-size: cover;
            background-color: transparent;
        }

        header.cube-background.cube-header-background {
            visibility: hidden;
            background-image: url('http://cube-1252774894.cosgz.myqcloud.com/background.png');
            background-position: center -400px;
        }
    </style>
    <header class="cube-background cube-header-background">
        
        <div class="cube-type">
            <span class="cube-typed-title">Sakuraの娜娜奇</span>
            <span class="cube-typed-cursor">|</span>
        </div>
        
    </header>
    <div class="load-header-background"></div>
    <script>
        (function (window) {

            window.headerModule = {}
            window.headerModule.image = {
                width: '2000',
                height: '1414'
            }

        })(window)
    </script>
    
    <div class="cube-content">
        <div class="cube-left">
            
<div class="cube-excerpt" id="cube-excerpt-BOM">
    <header class="cube-excerpt-header">
        <h1><a href="/2018/10/26/BOM/">BOM</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2018-10-26
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h1 id="BOM-Browser-object-model-浏览器对象模型"><a href="#BOM-Browser-object-model-浏览器对象模型" class="headerlink" title="BOM(Browser object model)浏览器对象模型"></a>BOM(Browser object model)浏览器对象模型</h1><blockquote>
<p> 一个浏览器窗口就是一个bom（浏览器对象）</p>
</blockquote>
<p><img src="C:\Users\罗中运\AppData\Roaming\Typora\typora-user-images\1540517515858.png" alt="1540517515858"></p>
<h5 id="window下的方法，通常情况下window开头的方法函数都可以省略window使用"><a href="#window下的方法，通常情况下window开头的方法函数都可以省略window使用" class="headerlink" title="window下的方法，通常情况下window开头的方法函数都可以省略window使用"></a>window下的方法，通常情况下window开头的方法函数都可以省略window使用</h5><h4 id="confirm（）方法"><a href="#confirm（）方法" class="headerlink" title="confirm（）方法"></a>confirm（）方法</h4><blockquote>
<p>confirm() 方法用于显示一个带有指定消息和 OK 及取消按钮的对话框。</p>
</blockquote>
<p>返回值：点击确定，返回true</p>
<p>​        点击取消，返回false </p>
<h4 id="prompt"><a href="#prompt" class="headerlink" title="prompt()"></a>prompt()</h4><blockquote>
<p>prompt()方法用于显示可提示用户进行输入的对话框。</p>
<p>这个方法返回用户输入的字符串。</p>
</blockquote>
<p>参数： 第一个参数 提示面板上显示的内容</p>
<p>​          第二个参数 输入框上显示的内容（可以不填）</p>
<p>返回值：输入框的内容    </p>
<h4 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h4><blockquote>
<p>open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口。</p>
</blockquote>
<p>第一个参数： 加载的url</p>
<p>第二个参数：指定target属性窗口的名称，（）</p>
<p>第三个参数：一串特殊意义的字符串，配置我们打开窗口的大小坐标</p>
<h5 id="url完整组成"><a href="#url完整组成" class="headerlink" title="url完整组成"></a>url完整组成</h5><h5 id="协议：-主机名：端口号-路径-？查询字符串-锚点"><a href="#协议：-主机名：端口号-路径-？查询字符串-锚点" class="headerlink" title="协议：//主机名：端口号/路径/？查询字符串#锚点"></a>协议：//主机名：端口号/路径/？查询字符串#锚点</h5><h5 id="protocol-hostname-port-pathname-search-hash"><a href="#protocol-hostname-port-pathname-search-hash" class="headerlink" title="protocol://hostname:port/pathname/?search#hash"></a>protocol://hostname:port/pathname/?search#hash</h5><h4 id="opener打开当前窗口的父窗口的对象（只有火狐浏览器兼容）"><a href="#opener打开当前窗口的父窗口的对象（只有火狐浏览器兼容）" class="headerlink" title="opener打开当前窗口的父窗口的对象（只有火狐浏览器兼容）"></a>opener打开当前窗口的父窗口的对象（只有火狐浏览器兼容）</h4><p>opener.document.write(“father”);//父窗口输出</p>
<h4 id="setTimeout-延时器"><a href="#setTimeout-延时器" class="headerlink" title="setTimeout()延时器"></a>setTimeout()延时器</h4><p>格式：</p>
<p>var timer = setTimerout(函数，毫秒数);</p>
<p>功能： 延迟对应毫秒数，去执行函数，有且仅执行一次；</p>
<p>取消延时器</p>
<p>clearTImeout(timer);</p>
<h4 id="history-历史对象"><a href="#history-历史对象" class="headerlink" title="history 历史对象"></a>history 历史对象</h4><p>window.history</p>
<p>属性</p>
<p>history.length    历史纪录长度</p>
<p>方法：</p>
<p>​    history.back();//后退</p>
<p>​    history.forward();//前进</p>
<p>​    history.go();//到指定历史界面</p>
<p>​        参数：正整数，负整数，0 前进/后退n条记录；0重新加载</p>
<h4 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h4><blockquote>
<p>地址栏部分</p>
<p>url：统一资源定位符</p>
<p>组成一个完整的url，必须按格式进行填写。</p>
</blockquote>
<h5 id="第一部分：location-protocol-协议"><a href="#第一部分：location-protocol-协议" class="headerlink" title="第一部分：location.protocol 协议"></a>第一部分：location.protocol 协议</h5><p>http://</p>
<p>https://</p>
<p>传输方式</p>
<h5 id="第二部分：主机名-location-hostname"><a href="#第二部分：主机名-location-hostname" class="headerlink" title="第二部分：主机名 location.hostname"></a>第二部分：主机名 location.hostname</h5><p>www.baidu.com 域名IP的昵称</p>
<p>61.135.169.125 IP 全网唯一</p>
<h5 id="location-port-端口号"><a href="#location-port-端口号" class="headerlink" title="location.port 端口号"></a>location.port 端口号</h5><p>系统会给当前使用网络的app，分配一个号码，这个号码就是端口号</p>
<p>当前电脑内唯一识别正在使用网络的软件；</p>
<p>ip：port 在全球范围内定位当前使用网络的软件</p>
<h5 id="pathname路径"><a href="#pathname路径" class="headerlink" title="pathname路径"></a>pathname路径</h5><p>location.pathname</p>
<h5 id="search向服务器提交数据部分（查询字符串）"><a href="#search向服务器提交数据部分（查询字符串）" class="headerlink" title="search向服务器提交数据部分（查询字符串）"></a>search向服务器提交数据部分（查询字符串）</h5><p>location.search </p>
<p>查询字符串</p>
<p>？name1 =value&amp; name2 = value</p>
<h5 id="hash锚点"><a href="#hash锚点" class="headerlink" title="hash锚点"></a>hash锚点</h5><p>location.hash</p>
<h3 id="location方法"><a href="#location方法" class="headerlink" title="location方法"></a>location方法</h3><p>location.assign（） 跳转到某一个url</p>
<p>location.replace（） 在当前窗口替换url</p>
<p>assign和replace区别assign有历史记录，replace没有</p>
<p>location.reload（） 刷新网页 参数location.reload（true）：不经过缓存直接刷新页面</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2018/10/26/BOM/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-面向对象和面向过程">
    <header class="cube-excerpt-header">
        <h1><a href="/2018/10/25/面向对象和面向过程/">面向对象和面向过程</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2018-10-25
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/对象/" class="cube-excerpt-tag-link">#对象</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h1 id="面向对象与面向过程的本质的区别"><a href="#面向对象与面向过程的本质的区别" class="headerlink" title="面向对象与面向过程的本质的区别"></a>面向对象与面向过程的本质的区别</h1><h3 id="一、面向对象与面向过程的区别"><a href="#一、面向对象与面向过程的区别" class="headerlink" title="一、面向对象与面向过程的区别"></a>一、面向对象与面向过程的区别</h3><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p>
<p>可以拿生活中的实例来理解面向过程与面向对象，例如五子棋，面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。</p>
<p>如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。</p>
<p>可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。</p>
<p>上述的内容是从网上查到的，觉得这个例子非常的生动形象，我就写了下来，现在就应该理解了他俩的区别了吧，其实就是两句话，面向对象就是高度实物抽象化、面向过程就是自顶向下的编程！</p>
<h3 id="二、面向对象的特点"><a href="#二、面向对象的特点" class="headerlink" title="二、面向对象的特点"></a>二、面向对象的特点</h3><p>​    在了解其特点之前，咱们先谈谈对象，对象就是现实世界存在的任何事务都可以称之为对象，有着自己独特的个性</p>
<p>​    属性用来描述具体某个对象的特征。比如小志身高180M，体重70KG，这里身高、体重都是属性。<br>面向对象的思想就是把一切都看成对象，而对象一般都由属性+方法组成！</p>
<p>​    属性属于对象静态的一面，用来形容对象的一些特性，方法属于对象动态的一面，咱们举一个例子，小明会跑，会说话，跑、说话这些行为就是对象的方法！所以为动态的一面， 我们把属性和方法称为这个对象的成员！</p>
<p>​    <strong>类</strong>：具有同种属性的对象称为类，是个抽象的概念。比如“人”就是一类，期中有一些人名，比如小明、小红、小玲等等这些都是对象，类就相当于一个模具，他定义了它所包含的全体对象的公共特征和功能，对象就是类的一个实例化，小明就是人的一个实例化！我们在做程序的时候，经常要将一个变量实例化，就是这个原理！我们一般在做程序的时候一般都不用类名的，比如我们在叫小明的时候，不会喊“人，你干嘛呢！”而是说的是“小明，你在干嘛呢！”</p>
<p>​    面向对象有三大特性，分别是封装性、继承性和多态性，这里小编不给予太多的解释，因为在后边的博客会专门总结的！</p>
<h3 id="三、面向过程与面向对象的优缺点"><a href="#三、面向过程与面向对象的优缺点" class="headerlink" title="三、面向过程与面向对象的优缺点"></a>三、面向过程与面向对象的优缺点</h3><p>​    很多资料上全都是一群很难理解的理论知识，整的小编头都大了，后来发现了一个比较好的文章，写的真是太棒了，通俗易懂，想要不明白都难!</p>
<p>​    用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭。所谓盖浇饭，北京叫盖饭，东北叫烩饭，广东叫碟头饭，就是在一碗白米饭上面浇上一份盖菜，你喜欢什么菜，你就浇上什么菜。我觉得这个比喻还是比较贴切的。</p>
<p>​    蛋炒饭制作的细节，我不太清楚，因为我没当过厨师，也不会做饭，但最后的一道工序肯定是把米饭和鸡蛋混在一起炒匀。盖浇饭呢，则是把米饭和盖菜分别做好，你如果要一份红烧肉盖饭呢，就给你浇一份红烧肉；如果要一份青椒土豆盖浇饭，就给浇一份青椒土豆丝。</p>
<p>​    蛋炒饭的好处就是入味均匀，吃起来香。如果恰巧你不爱吃鸡蛋，只爱吃青菜的话，那么唯一的办法就是全部倒掉，重新做一份青菜炒饭了。盖浇饭就没这么多麻烦，你只需要把上面的盖菜拨掉，更换一份盖菜就可以了。盖浇饭的缺点是入味不均，可能没有蛋炒饭那么香。</p>
<p>​    到底是蛋炒饭好还是盖浇饭好呢？其实这类问题都很难回答，非要比个上下高低的话，就必须设定一个场景，否则只能说是各有所长。如果大家都不是美食家，没那么多讲究，那么从饭馆角度来讲的话，做盖浇饭显然比蛋炒饭更有优势，他可以组合出来任意多的组合，而且不会浪费。</p>
<p>​    盖浇饭的好处就是”菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是”可维护性“比较好，”饭” 和”菜”的耦合度比较低。蛋炒饭将”蛋”“饭”搅和在一起，想换”蛋”“饭”中任何一种都很困难，耦合度很高，以至于”可维护性”比较差。软件工程追求的目标之一就是可维护性，可维护性主要表现在3个方面：可理解性、可测试性和可修改性。面向对象的好处之一就是显著的改善了软件系统的可维护性。 
　　 </p>
<h4 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h4><blockquote>
<p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。<br>缺点：没有面向对象易维护、易复用、易扩展</p>
</blockquote>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><blockquote>
<p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 </p>
<p>缺点：性能比面向过程低</p>
</blockquote>
<hr>
<p>作者：十四期_李光<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/jerry11112/article/details/79027834" target="_blank" rel="noopener">https://blog.csdn.net/jerry11112/article/details/79027834</a> </p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2018/10/25/面向对象和面向过程/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-Math对象和日期对象">
    <header class="cube-excerpt-header">
        <h1><a href="/2018/10/25/Math对象和日期对象/">Math对象和日期对象</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2018-10-25
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/js/" class="cube-excerpt-tag-link">#js</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <h2 id="1、Math对象"><a href="#1、Math对象" class="headerlink" title="1、Math对象"></a>1、Math对象</h2><h4 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h4><p>[0,1)返回随机数</p>
<h4 id="Math-max-num1-num2-Math-min-num1-num2"><a href="#Math-max-num1-num2-Math-min-num1-num2" class="headerlink" title="Math.max(num1,num2),Math.min(num1,num2);"></a>Math.max(num1,num2),Math.min(num1,num2);</h4><p>取较大，较小值</p>
<h4 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round()"></a>Math.round()</h4><p>四舍五入，变成整数</p>
<h4 id="Math-floor-Math-ceil"><a href="#Math-floor-Math-ceil" class="headerlink" title="Math.floor(), Math.ceil()"></a>Math.floor(), Math.ceil()</h4><p>向下，上取整</p>
<h4 id="Math-sqrt"><a href="#Math-sqrt" class="headerlink" title="Math.sqrt()"></a>Math.sqrt()</h4><p>开平方</p>
<h4 id="Math-abs"><a href="#Math-abs" class="headerlink" title="Math.abs()"></a>Math.abs()</h4><p>取绝对值</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p><img src="C:\Users\罗中运\Pictures\Saved Pictures\对象.png" alt="对象"></p>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>1、抽象：抽指把核心的东西抽出来，把与我们要解决的问题有关的东西拿出来摆在面前 </p>
<p>2、封装：让使用对象的人不考虑内部实现，只考虑功能使用  把内部的代码保护起来，只留出一些个api接口供用户使用</p>
<p>3、继承：就是为了代码的复用，从父类上继承出一些方法和属性，子类也有自己的一些属性 </p>
<p>4、多态：实际上是不同对象作用与同一操作产生不同的效果。多态的思想实际上是把“想做什么”和“谁去做“分开</p>
<h5 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h5><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p>
<p>可以拿生活中的实例来理解面向过程与面向对象，例如五子棋，面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。</p>
<h6 id="如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。"><a href="#如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。" class="headerlink" title="如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。"></a>如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。</h6><h6 id="可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。"><a href="#可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。" class="headerlink" title="可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。"></a>可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。</h6><p>###### </p>
<h4 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a>对象的组成</h4><p>1、方法   函数：过程、动态的</p>
<p>2、属性   变量：状态、静态的，</p>
<h4 id="this当前的方法属于谁就是谁"><a href="#this当前的方法属于谁就是谁" class="headerlink" title="this当前的方法属于谁就是谁"></a>this<strong>当前的方法属于谁就是谁</strong></h4><p>例如点击事件里的this，其实就是触发事件的那个dom对象的onclick方法里的this，当然是人家自己咯</p>
<p> 再比如说一个函数里的this，这个函数都属于window的一个方法，当然里面的this也是window咯</p>
<p>  还有哦，不要在系统对象上面添加属性和方法，这样不太好</p>
<p> 那么在谁身上加呢？在object这个对象身上，别的date呀array呀，这些对象都是有一些个好玩的功能的，</p>
<p>  object也就自己最强大的一个功能就是，没有功能~~~~ 这样咱们就可以随意给他加属性和方法而不用去想会不会覆盖了</p>
<p>1、通过历史</p>
<p>​    面向过程语言：汇编、c语言</p>
<p>​    面向对象语言：c++，java</p>
<p>2、编程思想</p>
<p>​    面向过程：只关心数字逻辑</p>
<p>​    面向过程：具体某一个是提来的，唯一的实体。</p>
<p>3、语法：<br>​    在JS中需要通过两个语法实现面向对象程序。<br>​    类   在JS没有类这个概念。<br>​    对象 </p>
<p>​    类：将具有同一类特征的事物总结，抽象的概念。<br>​    对象：唯一的某一个个体。</p>
<p>​    类           对象<br>​    人          你、我、他<br>​    复仇者联盟  钢铁侠    </p>
<p>4、代码<br>​    数据类型：<br>​            基本数据类型：<br>​            特殊数据类型：null undefined NaN<br>​            复合数据类型：数组、字符串、对象</p>
<p>5、数据结构：<br>​    基本数据类型(只能存储单个的值)  -&gt;  数组(可以处理批量的数据)  -&gt;  对象(既能存储数据，又能存储函数)</p>
<h4 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h4><p>1、最基础的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、通过new声明对象</span></span><br><span class="line"><span class="comment">// var obj = new Object();</span></span><br><span class="line"><span class="comment">//2、省略new声明对象</span></span><br><span class="line"><span class="comment">// var obj = Object();</span></span><br><span class="line"><span class="comment">//3、直接通过对象常量赋值</span></span><br><span class="line"><span class="comment">/*var obj = &#123;&#125;;</span></span><br><span class="line"><span class="comment">添加对象的属性  和普通的变量是一样的</span></span><br><span class="line"><span class="comment">obj.name = '小明';</span></span><br><span class="line"><span class="comment">obj.age = 18;</span></span><br><span class="line"><span class="comment">//添加对象的方法/函数</span></span><br><span class="line"><span class="comment">obj.run = function()&#123;</span></span><br><span class="line"><span class="comment">	alert("会跑")</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">alert(obj.name);</span></span><br><span class="line"><span class="comment">obj.run();*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*var obj = &#123;</span></span><br><span class="line"><span class="comment">	name: "小明",</span></span><br><span class="line"><span class="comment">	age: 18,</span></span><br><span class="line"><span class="comment">	run: function()&#123;</span></span><br><span class="line"><span class="comment">	alert("会跑");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">alert(obj.name);</span></span><br><span class="line"><span class="comment">obj.run();*/</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加对象的属性  和普通的变量是一样的</span></span><br><span class="line">obj.name = <span class="string">'小明'</span>;</span><br><span class="line">obj[<span class="string">'age'</span>] = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加对象的方法/函数</span></span><br><span class="line">obj.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"会跑"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(obj[<span class="string">'name'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除对象的属性和方法的关键字 delete</span></span><br><span class="line"><span class="comment">// delete删除对象属性，delete删除不了变量及原型链中的变量</span></span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line">alert(obj.name);</span><br><span class="line"></span><br><span class="line">obj.run();</span><br></pre></td></tr></table></figure>
<p>但是这样太麻烦，我要写100个人，那得写100次。有别的方法吗？有</p>
<p>2、工厂方式 通过构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//原料</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">//加工</span></span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age=age;</span><br><span class="line">    obj.showAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         alert(<span class="keyword">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出厂</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1=createPerson(<span class="string">"shizhikai"</span>,<span class="string">'3岁'</span>)</span><br><span class="line"><span class="keyword">var</span> obj2=createPerson(<span class="string">"ni"</span>,<span class="string">'18岁'</span>);</span><br><span class="line"></span><br><span class="line">alert(obj1.showName)<span class="comment">//function()&#123;alert(this.name)&#125;</span></span><br><span class="line">alert(obj2.showName)<span class="comment">//function()&#123;alert(this.name)&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="日起对象Date"><a href="#日起对象Date" class="headerlink" title="日起对象Date"></a>日起对象Date</h2><p>Date对象代表日期</p>
<p> Date</p>
<p>类型使用自 UTC（Coordinated Universal Time，国际协调时间）1970 年 1 月 1 日午夜（零时）开始经过的毫秒数来保存日期。Date 类型保存的日期能够精确到 1970 年 1 月 1 日之前或之后的 285616 年。</p>
<p>创建一个日期对象，使用 new 运算符和 Date 构造方法(构造函数)即可。</p>
<p>​    <strong>var d = new Date();</strong></p>
<p>在调用 Date 构造方法而不传递参数的情况下，新建的对象自动获取当前的时间和日期。</p>
<p>创建日期对象并指定时间</p>
<p>​    <strong>var d = new Date(“2015/08/22”);</strong></p>
<p>​    <strong>var d = new Date(2016,04,13,14,34);</strong></p>
<p>【注】time可以是“2015/08/22”， “2015-08-22”  ，或1970年当前日期的毫秒数56521211021</p>
<h4 id="5、日期对象Date（格式化方法，了解即可）"><a href="#5、日期对象Date（格式化方法，了解即可）" class="headerlink" title="5、日期对象Date（格式化方法，了解即可）"></a>5、日期对象Date（格式化方法，了解即可）</h4><table>
<thead>
<tr>
<th>alert(box.toDateString());</th>
<th>//以特定的格式显示星期几、月、日和年</th>
</tr>
</thead>
<tbody>
<tr>
<td>alert(box.toTimeString());</td>
<td>//以特定的格式显示时、分、秒和时区</td>
</tr>
<tr>
<td>alert(box.toLocaleDateString());</td>
<td>//以特定地区格式显示星期几、月、日和年</td>
</tr>
<tr>
<td>alert(box.toLocaleTimeString());</td>
<td>//以特定地区格式显示时、分、秒和时区</td>
</tr>
<tr>
<td>alert(box.toUTCString());</td>
<td>//以特定的格式显示完整的 UTC 日期。</td>
</tr>
</tbody>
</table>
<h4 id="6、日期对象Date方法"><a href="#6、日期对象Date方法" class="headerlink" title="6、日期对象Date方法"></a>6、日期对象Date方法</h4><p>x(“2015-08-24”);</p>
<p>//转换格式默认支持2015-08-24或2015/08/24</p>
<p>//返回距离1970年1月1日0时的毫秒数</p>
<p>d.getTime()/d.setTime()</p>
<p>getTime获取某个日期自1970年以来的毫秒数</p>
<p>setTime修改日期的毫秒数，对应的日期时间也会修改</p>
<p>var myDate = new Date();</p>
<p>myDate.getTime();</p>
<h4 id="7、日期对象方法"><a href="#7、日期对象方法" class="headerlink" title="7、日期对象方法"></a>7、日期对象方法</h4><h5 id="重点记忆（set-get既能获取又能够赋值-get只能获取）"><a href="#重点记忆（set-get既能获取又能够赋值-get只能获取）" class="headerlink" title="重点记忆（set/get既能获取又能够赋值    get只能获取）"></a>重点记忆（set/get既能获取又能够赋值    get只能获取）</h5><blockquote>
<p>调用格式： 日期对象.方法()</p>
</blockquote>
<p>set/getDate() 从Date对象中返回一个月中的某一天(1~31)</p>
<p>getDay() 从Date对象返回一周中的某一天(0~6 )    获取日期星期几（0~6）0是周日</p>
<p>set/getMonth() 从Date对象中返回月份(0~11)对应（1~12）</p>
<p>set/getFullYear() 从Date对象以四位数返回年份</p>
<p>set/getHours() 返回Date对象的小时(0~23)</p>
<p>set/getMinutes() 返回Date对象的分钟(0~59)</p>
<p>set/getSeconds() 返回Date对象的秒数(0~59)</p>
<p>set/getMilliseconds()   返回Date对象的毫秒</p>
<p>set/getTime() 返回1970年1月1日至今的毫秒数</p>
<p>getTimezoneOffset()     返回本地时间与格林威治标准时间(GMT)的分钟差</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><h4 id="setInterval-函数，毫秒数"><a href="#setInterval-函数，毫秒数" class="headerlink" title="setInterval(函数，毫秒数)"></a>setInterval(函数，毫秒数)</h4><p>此处函数不加小括号，此处含义是把函数传过去让他执行</p>
<p>格式： var timer = setInterval(show, 1000);</p>
<p>返回值：当前定时器的编码</p>
<h4 id="clearInterval（timer）；-关闭定时器"><a href="#clearInterval（timer）；-关闭定时器" class="headerlink" title="clearInterval（timer）；//关闭定时器"></a>clearInterval（timer）；//关闭定时器</h4><p>函数写法：</p>
<p>1、</p>
<p>function show(){</p>
<p>}</p>
<p>2、</p>
<p>var show = function(){</p>
<p>}</p>
<p>show();</p>
<p>所以上面写法可以替换为</p>
<p>格式： setInterval( function(){</p>
<p>}, 1000);</p>
<p>此处函数叫做匿名函数；</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2018/10/25/Math对象和日期对象/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-字符串String">
    <header class="cube-excerpt-header">
        <h1><a href="/2018/10/23/字符串String/">字符串String</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2018-10-23
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/js/" class="cube-excerpt-tag-link">#js</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>[TOC]</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>所有使用单引号或者双引号括起来的内容，都叫字符串。</p>
<p>​    【注】单引号和双引号没有区别，单引号如果嵌套，要交替使用。</p>
<p>声明字符串</p>
<p>1、new</p>
<p>var str = new String(1000);</p>
<p>alert(typeof str);//object</p>
<p>2、省略new 声明字符串</p>
<p>var str2 = String(1000);</p>
<p>alert(typeof str);//String</p>
<p>var str = “1000”;</p>
<p>alert(typeof str);//string</p>
<blockquote>
<p>上述三种不同声明方法使用起来没有区别</p>
</blockquote>
<h4 id="字符串数据类型"><a href="#字符串数据类型" class="headerlink" title="字符串数据类型"></a>字符串数据类型</h4><p>​    即是基本数据类型，又是复合数据类型。</p>
<p>变量存的是字符串的地址</p>
<p>字符串只读一旦被声明就没法修改，只能抹去重新赋值</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>str.length</p>
<p>返回当前字符串中字符个数，汉字相当于一个字符；</p>
<p>访问字符串某一个字符</p>
<p>可以通过 str[下标]</p>
<p>【注】只读不可修改</p>
<p>+拼接字符串</p>
<h2 id="方法（注意方法调用要加小括号-）"><a href="#方法（注意方法调用要加小括号-）" class="headerlink" title="方法（注意方法调用要加小括号()）"></a>方法（注意方法调用要加小括号()）</h2><h5 id="big-用大号字体显示字符串"><a href="#big-用大号字体显示字符串" class="headerlink" title="big()                 用大号字体显示字符串"></a>big()                 用大号字体显示字符串</h5><h5 id="blink-显示闪动字符串-IE下无效"><a href="#blink-显示闪动字符串-IE下无效" class="headerlink" title="blink()              显示闪动字符串(IE下无效)"></a>blink()              显示闪动字符串(IE下无效)</h5><h5 id="bold-使用粗体显示字符串"><a href="#bold-使用粗体显示字符串" class="headerlink" title="bold()               使用粗体显示字符串"></a>bold()               使用粗体显示字符串</h5><h5 id="fixed-以打字机文本显示字符串"><a href="#fixed-以打字机文本显示字符串" class="headerlink" title="fixed()              以打字机文本显示字符串"></a>fixed()              以打字机文本显示字符串</h5><h5 id="strike-使用删除线来显示字符串"><a href="#strike-使用删除线来显示字符串" class="headerlink" title="strike()             使用删除线来显示字符串"></a>strike()             使用删除线来显示字符串</h5><h5 id="fontcolor-使用指定颜色来显示字符串"><a href="#fontcolor-使用指定颜色来显示字符串" class="headerlink" title="fontcolor()       使用指定颜色来显示字符串"></a>fontcolor()       使用指定颜色来显示字符串</h5><h5 id="fontsize-使用指定尺寸来显示字符串"><a href="#fontsize-使用指定尺寸来显示字符串" class="headerlink" title="fontsize()         使用指定尺寸来显示字符串"></a>fontsize()         使用指定尺寸来显示字符串</h5><h5 id="link-将字符串显示为链接"><a href="#link-将字符串显示为链接" class="headerlink" title="link()                将字符串显示为链接"></a>link()                将字符串显示为链接</h5><h5 id="sub-把字符串显示为下标"><a href="#sub-把字符串显示为下标" class="headerlink" title="sub()                把字符串显示为下标"></a>sub()                把字符串显示为下标</h5><h5 id="sup-把字符串显示为上标"><a href="#sup-把字符串显示为上标" class="headerlink" title="sup()                把字符串显示为上标"></a>sup()                把字符串显示为上标</h5><p>document.write()中使用,用特殊的样式输出该字符串。</p>
<h3 id="字符串的方法-字符串的获取方法"><a href="#字符串的方法-字符串的获取方法" class="headerlink" title="字符串的方法-字符串的获取方法"></a>字符串的方法-字符串的获取方法</h3><p>charAt(3)         <strong>//获取下标为3的字符</strong></p>
<p>charCodeAt(3)     <strong>//获取下标为3的字符的编码</strong></p>
<p>【注】上述两个方法使用字符串对象调用</p>
<p>fromCharCode(94)  <strong>//编码转换成字符</strong></p>
<p> 该方法是 String 的静态方法，所以用String调用，        </p>
<p>如：var str = String.fromCharCode(97,98,99);</p>
<h3 id="字符串的查找方法"><a href="#字符串的查找方法" class="headerlink" title="字符串的查找方法"></a>字符串的查找方法</h3><p>​    <1>indexOf(“abc”, start);   查找字符串第一次出现的位置，可以传两个参数</1></p>
<p>​    <2>lastIndexOf(“abc”);      查找字符串最后一次出现的位置  如果没有找到  返回-1</2></p>
<p>​    <3>search()  正则匹配(返回出现的位置)</3></p>
<h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h4><p>格式： supStr.indexOf(subStr, start);</p>
<p>参数： subStr 子串 start 开始查找的位置</p>
<p>功能： 在supStr中找出subStr第一次出现的位置，从start得到位置开始找</p>
<p>返回值： -1没找到</p>
<p>​        &gt;=0 找到了并返回位置</p>
<h4 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h4><p>与indexOf类似不过是从后往前找</p>
<h4 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h4><p>格式： supStr.search(subStr/正则表达式);//只有一个参数</p>
<p>功能： 在supStr中找出subStr第一次出现的位置</p>
<p>ps：正则表达式是个功能更加强大的字符串</p>
<p>返回值： -1没找到</p>
<p>​        &gt;=0 找到了并返回位置</p>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><h4 id="replace-替换"><a href="#replace-替换" class="headerlink" title="replace()替换"></a>replace()替换</h4><p>格式： supStr.replace(oldStr/ 正则表达式，newStr);</p>
<p>功能:    用newstr替换oldStr；</p>
<p>返回值： 新生成的字符串//不会改变原来的字符串；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"how are you”;</span></span><br><span class="line"><span class="string">	 alert(str);//"</span>how are you”;</span><br><span class="line">     alert(str.replace(“are”, “old are”)); <span class="comment">//"how old are you”;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的替换只能执行一次，不能够进行全局匹配，如果需要全局匹配，则应使用正则表达式： str.replace(/are/gi,"old are") g表示进行全局匹配，i表示匹配的时候忽略大小写</span></span><br></pre></td></tr></table></figure>
<h4 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h4><p>和数组slice工能类似</p>
<p>格式： 字符串.substring（start，end）；</p>
<p>功能： 提取指定范围内的字符串，生成一个新的字符串[start, end)</p>
<h4 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h4><p>格式： 字符串.splite(分隔符， 数字) ；</p>
<p>参数： 第二个：控制返回的数组中元素的个数，一般情况下不传；</p>
<p>功能： 用分隔符将字符串分割成小的字符串，放在数组中；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;Hello world , hi&quot;</span><br><span class="line">var strArr = str.split(&quot; &quot;);//Hello,world,,,hi</span><br><span class="line"></span><br><span class="line">//特殊用法使用空字符串分割</span><br><span class="line">结果：将字符串每个字符分割放在数组里；</span><br></pre></td></tr></table></figure>
<h4 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase()"></a>toLowerCase()</h4><p>转小写</p>
<h4 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase()"></a>toUpperCase()</h4><p>转大写</p>
<table>
<thead>
<tr>
<th>不改变原来字符串，而是生成新的字符串会改变原字符串</th>
<th>会改变原字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td>replace</td>
<td>无</td>
</tr>
<tr>
<td>concat</td>
<td></td>
</tr>
<tr>
<td>split</td>
<td></td>
</tr>
<tr>
<td>substr</td>
<td></td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>修改原数组</th>
<th>不修改原数组</th>
</tr>
</thead>
<tbody>
<tr>
<td>pop push</td>
<td>concat</td>
</tr>
<tr>
<td>push  shift</td>
<td></td>
</tr>
<tr>
<td>reverse</td>
<td></td>
</tr>
<tr>
<td>splice</td>
<td></td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">st-&gt;op-&gt;condasd</span><br></pre></td></tr></table></figure>
<p>substr与substring区别</p>
<p>substr返回的字符串包括结束处字符，而substring不包括</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2018/10/23/字符串String/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-let和var的区别">
    <header class="cube-excerpt-header">
        <h1><a href="/2018/10/23/let和var的区别/">let和var的区别</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2018-10-23
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/js/" class="cube-excerpt-tag-link">#js</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>[TOC]</p>
<h1 id="let与var"><a href="#let与var" class="headerlink" title="let与var"></a>let与var</h1><p>let是ES6新增的变量类型，是用来替代var的设计，与var不同的是：</p>
<p>1、let使用块级作用域<br>2、let不支持在同作用域中声明标识符相同的变量<br>3、let用TDZ禁止了声明前访问<br>我们一条一条说明：</p>
<p>1、JavaScript的作用域（scope）只有全局和局部，对于var声明的变量，只有函数才能为它创建新的作用域，而let支持块级作用域，花括号就能为它创建新的作用域；<br>2、相同作用域，var可以反复声明相同标识符的变量，而let是不允许的;<br>3、let声明的变量禁止在声明前访问，这也是为什么很多人认为let是不支持变量提升的原因，但真的是这样吗？我们来讨论这个问题：</p>
<p>我们先说明一下什么是变量提升（hoisting）</p>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p><a href="https://blog.csdn.net/demo_18/article/details/78493489" target="_blank" rel="noopener">https://blog.csdn.net/demo_18/article/details/78493489</a></p>
<p>先上一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"hey I am now hoisting"</span>;</span><br></pre></td></tr></table></figure>
<p>看起来，我们在a被声明前调用a，没有报错，反而是返回一个undefined值，原因是：a其实已经在调用前被声明了，只是没有被初始化。JavaScript会把作用域里的所有变量和函数提到函数的顶部声明，相当于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">"hey I am now hoisting"</span>;</span><br></pre></td></tr></table></figure>
<p>JavaScript会使用undefined缺省值创建变量a，注意，事实上浏览器并没有把声明语句放到作用域的顶部，在编译阶段，控制流进入域，该域所有的变量和函数的声明先进入内存，文中代码的相对位置不会变动的。</p>
<p>由此可以知道，变量提升指的是变量声明的提升，不会提升变量的初始化和赋值。</p>
<p>对于let来说，情况有点不同:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//Uncaught ReferenceError: a is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">"hey I am now hoisting"</span>;</span><br><span class="line"></span><br><span class="line">这里抛出了一个错误，浏览器认为a并没有声明，这是否意味着<span class="keyword">let</span>并没有使a变量提升呢？我们再看一个例子</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">"hey I am outside"</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//Uncaught ReferenceError: a is not defined</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">"hey I am inside"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意看，这里同样抛出了一个错误，认为a没有声明，但是，如果a没有变量提升，执行到console.log时应该是输出全局作用域中的a，而不是出现错误。</p>
<p>我们可以推知，这里确实出现了变量提升，而我们不能够访问的原因事实上是因为let的死区（temporal dead zone）设计：当前作用域顶部到该变量声明位置中间的部分，都是该let变量的死区，在死区中，禁止访问该变量。由此，我们给出结论，let声明的变量存在变量提升， 但是由于死区我们无法在声明前访问这个变量。</p>
<h5 id="最后要指出的是，函数也是存在提升（hoisting）的，并且，函数的提升不同于变量的提升，函数相当于把自己的声明、赋值整个的放到了当前作用域的顶部。"><a href="#最后要指出的是，函数也是存在提升（hoisting）的，并且，函数的提升不同于变量的提升，函数相当于把自己的声明、赋值整个的放到了当前作用域的顶部。" class="headerlink" title="最后要指出的是，函数也是存在提升（hoisting）的，并且，函数的提升不同于变量的提升，函数相当于把自己的声明、赋值整个的放到了当前作用域的顶部。"></a>最后要指出的是，函数也是存在提升（hoisting）的，并且，函数的提升不同于变量的提升，函数相当于把自己的声明、赋值整个的放到了当前作用域的顶部。</h5>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2018/10/23/let和var的区别/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-ECMA5新增标签">
    <header class="cube-excerpt-header">
        <h1><a href="/2018/10/23/ECMA5新增标签/">ECMA5新增标签</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2018-10-23
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/H5-js/" class="cube-excerpt-tag-link">#H5 js</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>[TOC]</p>
<h3 id="学习目标："><a href="#学习目标：" class="headerlink" title="学习目标："></a>学习目标：</h3><ol>
<li>ECMA5新增知识点</li>
<li>严格模式</li>
<li>新增数组方法</li>
<li>新增字符串方法</li>
<li>认识字符串，字符串概念</li>
<li>字符串的属性和函数</li>
<li>字符串练习</li>
<li>实现登录注册严格模式</li>
</ol>
<p>  除了正常运行模式，ECMAscript 5 添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。</p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>1、在严格模式下，声明变量必须使用var；</p>
<p>2、在严格模式下， 函数参数不能重名；</p>
<p>3、</p>
<p>this无法指向全局对象；</p>
<script>
   “use strict”;


    console.log(“已经进入严格模式”);

    function a(){

        this.b = 10; //报错，因为this是undefined

    }

    a();
</script>





<p>4、在严格模式下，arguments存储的是函数传参时候的参数，在修改参数值后，arguments里面的值不会改变；    4.1arguments对象不允许被动态改变：</p>
<p>5、在严格模式下，新增保留字：implements, interface, let, package, private, protected, public, static, yield。</p>
<h2 id="ECMA新增的数组方法"><a href="#ECMA新增的数组方法" class="headerlink" title="ECMA新增的数组方法"></a>ECMA新增的数组方法</h2><h3 id="indexOf-data-start"><a href="#indexOf-data-start" class="headerlink" title="indexOf(data,start);"></a>indexOf(data,start);</h3><p>格式：数组.indexOf(data, start);</p>
<p>参数： data     要查找的元素；</p>
<p>​         start      从哪个位置开始查找</p>
<p>功能：查找某一个元素在数组中第一次出现的位置。</p>
<p>返回值：-1没找到； &gt;=找到了</p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>功能：数组遍历</p>
<p>var arr = [‘num1’,’num2’];</p>
<p>arr.forEach(function(item, index, array){</p>
<p>​    }</p>
<p>)</p>
<p>item    当前遍历到的元素num1;num2；</p>
<p>index    当前遍历到的元素的下标0；1</p>
<p>array    遍历的数组本身num1,num2</p>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>会遍历当前数组，然后调用参数中的方法，返回当前方法的返回值;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arr</span>)</span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item + <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//map不会改变原有数组，而是将函数执行一次之后的返回值组成一个数组，返回回来。</span></span><br></pre></td></tr></table></figure>
<h3 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter() 过滤"></a>filter() 过滤</h3><p>var res = [88,69,92,77,90,96,98,99].filter(function(item, index, array){ </p>
<p>​    return item&gt;80; //找出所有大于80的元素 </p>
<p>}); </p>
<p>结果：[88,92,90,96,98,99];//影响原数组</p>
<h3 id="reduce-归并"><a href="#reduce-归并" class="headerlink" title="reduce()归并"></a>reduce()归并</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre, next, index, array</span>)</span>&#123; </span><br><span class="line">    <span class="comment">//参数中的x和y，代表了之前的处理结果和下一个元素 return x+y; //return的结果会赋值给下一个函数的x参数 </span></span><br><span class="line">&#125;); 结果 ： <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="some-某些"><a href="#some-某些" class="headerlink" title="some()某些"></a>some()某些</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>([<span class="string">"yt"</span>,<span class="string">"hr"</span>,<span class="string">"wc"</span>,<span class="string">"jk"</span>].some(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123; </span><br><span class="line"><span class="comment">//判断数组中是否存在yt？ 如果找到了匹配的元素就不在运行了</span></span><br><span class="line">    <span class="keyword">return</span> item==<span class="string">"yt”; </span></span><br><span class="line"><span class="string">&#125;))&#123; </span></span><br><span class="line"><span class="string">    alert("</span>好的！<span class="string">"); </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><p>跟some一样，但要求每一项都符合，才返回true 有一项不合格就返回false</p>
<h3 id="String的trim方法"><a href="#String的trim方法" class="headerlink" title="String的trim方法"></a>String的trim方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" abc "</span>.trim(); </span><br><span class="line">首尾去空格 </span><br><span class="line"><span class="string">"abc"</span></span><br></pre></td></tr></table></figure>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2018/10/23/ECMA5新增标签/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-js排序">
    <header class="cube-excerpt-header">
        <h1><a href="/2018/10/22/js排序/">js排序</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2018-10-22
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/H5-js/" class="cube-excerpt-tag-link">#H5 js</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>[TOC]</p>
<h2 id="系统自带"><a href="#系统自带" class="headerlink" title="系统自带"></a>系统自带</h2><p>系统有自带的sort排序方法，但是他是对字符串进行判断排序</p>
<p>所以要对数字排序要给他写一个判断方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">sequence</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a &lt; b)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">5</span> ,<span class="number">56</span>, <span class="number">65</span>, <span class="number">84</span>, <span class="number">98</span>];</span><br><span class="line">alert(arr.sort(sequence));</span><br></pre></td></tr></table></figure>
<h2 id="用户编写"><a href="#用户编写" class="headerlink" title="用户编写"></a>用户编写</h2><h3 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h3><p>​                数组：9, 8, 7, 6, 5, 4<br>​                第一轮：五次<br>​                    9, 8, 7, 6, 5, 4<br>​                    8, 9, 7, 6, 5, 4<br>​                    8, 7, 9, 6, 5, 4<br>​                    8, 7, 6, 9, 5, 4<br>​                    8, 7, 6, 5, 9, 4<br>​                    8, 7, 6, 5, 4, 9</p>
<p>​                第二轮：四次<br>​                    8, 7, 6, 5, 4<br>​                    7, 8, 6, 5, 4<br>​                    7, 6, 8, 5, 4<br>​                    7, 6, 5, 8, 4<br>​                    7, 6, 5, 4, 8</p>
<p>​                第三轮：三次<br>​                    7, 6, 5, 4<br>​                    6, 7, 5, 4<br>​                    6, 5, 7, 4<br>​                    6, 5, 4, 7</p>
<p>​                第四轮：两次<br>​                    6, 5, 4<br>​                    5, 6, 4<br>​                    5, 4, 6</p>
<p>​                第五轮：一次<br>​                    5, 4<br>​                    4, 5</p>
<p>规律：</p>
<p>1、数组长度6</p>
<p>2、比较五轮 = 数组长度 - 1</p>
<p>3、数组长度 = 轮数 + 每一轮的次数</p>
<p>​    每一轮的次数 = 数组长度 - 轮数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bubbleSort(arr)&#123;</span><br><span class="line">    <span class="comment">//比较的轮数（arr.length-1）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//j每一轮比较的次数（数组长度 - 轮数）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">                arr[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h3><p>打擂台法</p>
<p>选择排序<br>​                第一轮：<br>​                    9, 8, 7, 6, 5, 4<br>​                    8, 9, 7, 6, 5, 4<br>​                    7, 9, 8, 6, 5, 4<br>​                    6, 9, 8, 7, 5, 4<br>​                    5, 9, 8, 7, 6, 4<br>​                    4, 9, 8, 7, 6, 5</p>
<p>​                第二轮：<br>​                       9, 8, 7, 6, 5<br>​                       8, 9, 7, 6, 5<br>​                       7, 9, 8, 6, 5<br>​                       6, 9, 8, 7, 5<br>​                       5, 9, 8, 7, 6</p>
<p>​                第三轮：<br>​                          9, 8, 7, 6<br>​                          8, 9, 7, 6<br>​                          7, 9, 8, 6<br>​                          6, 9, 8, 7</p>
<p>​                第四轮：</p>
<p>​                          9, 8, 7<br>​                          8, 9, 7<br>​                          7, 9, 8<br>​                第五轮：<br>​                         9, 8<br>​                         8, 9</p>
<p>规律：</p>
<p>​    通过比较首先选出最小的数放在第一个位置上，然后在其余的数中选出次小数放在第二个位置上,依此类推,直到所有的数成为有序序列。</p>
<p>​    轮数： 数组长度 -  1</p>
<p>​    每一轮比较次数：数组长度 - 当前轮数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j])&#123;</span><br><span class="line">                <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2018/10/22/js排序/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-JavaScript组成">
    <header class="cube-excerpt-header">
        <h1><a href="/2018/10/20/JavaScript组成/">JavaScript组成</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2018-10-20
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/H5-js/" class="cube-excerpt-tag-link">#H5 js</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>[TOC]</p>
<h2 id="JavaScript组成部分——ECMAScript、DOM、BOM"><a href="#JavaScript组成部分——ECMAScript、DOM、BOM" class="headerlink" title="JavaScript组成部分——ECMAScript、DOM、BOM"></a>JavaScript组成部分——ECMAScript、DOM、BOM</h2><blockquote>
<p>虽然 JavaScript 和 ECMAScript 通常被人们用来表达相同的含义，但 JavaScript 的含义却比ECMA-262标准中规定的要多得多。 一个完整的JavaScript应该由下列三个不同的部分组成</p>
</blockquote>
<h3 id="核心（ECMAScript）"><a href="#核心（ECMAScript）" class="headerlink" title="核心（ECMAScript）"></a>核心（ECMAScript）</h3><blockquote>
<p>​    ECMAScript是一种由ECMA国际（前身为欧洲计算机制造商协会，英文名为European Computer Manufacters Association）通过ECMA-262标准化的脚本程序设计语言。ECMAScript定义的只是这门语言的基础，而在此基础上可以构建更完善的脚本语言。我们常见的Web浏览器只是ECMAScript实现可能的宿主环境之一。组成部分有：语法、类型、语句、关键字、保留字、操作符、对象等。</p>
<p>​    目前ECMAScript有6个版本，分别是<strong>ECMAScript1</strong>、<strong>ECMAScript2</strong>、<strong>ECMAScript3</strong>、<strong>ECMAScript4</strong>（由于制定时分歧过大，并未正式布）、<strong>ECMAScript5、ECMAScript2015</strong>。截止发布日期，JavaScript的官方名称是ECMAScript 2015，下一版本将于今年（2016年）发布，命名为ECMAScript 2016。从2015年开始，新版本将按照ECMAScript+年份的形式发布。</p>
</blockquote>
<p>文档对象模型（DOM）——对应Document对象；</p>
<blockquote>
<p>​    一个与系统平台和编程语言无关的接口，程序和脚本可以通过这个接口动态访问和修改文档的内容、结构和样式。</p>
<p>​    DOM把一份文档理解为一颗家谱树（节点数），分别为parent（父节点）、child（子节点）、sibling（兄弟节点），如下图：</p>
<p>​    <img src="https://images2015.cnblogs.com/blog/920443/201605/920443-20160525093958709-1057258632.png" alt="img"></p>
<p>文档由节点组成的集合，节点有以下几种类型</p>
<p>​    元素节点（标签）、文本节点（包含在元素节点中）、属性节点（对元素做出更具体的描述）——几乎所有元素都有一个title属性</p>
</blockquote>
<p>DOM把整个网页映射成为一个多层节点</p>
<h3 id="浏览器对象模型（BOM）——对应window对象"><a href="#浏览器对象模型（BOM）——对应window对象" class="headerlink" title="浏览器对象模型（BOM）——对应window对象"></a>浏览器对象模型（BOM）——对应window对象</h3><p>他提供了很多对象，用于访问浏览器的功能；这些功能与人和网页内容无关；</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2018/10/20/JavaScript组成/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-js数组">
    <header class="cube-excerpt-header">
        <h1><a href="/2018/10/19/js数组/">js数组</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2018-10-19
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/H5-js/" class="cube-excerpt-tag-link">#H5 js</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>[TOC]</p>
<p>//underfined、null、boolean、string、number为基本数值类型。逗号一并定义初始化多个变量。基本包装类型String、Boolean、Number通过valueOf()可以获取基本数值类型，可以实现自动装箱和拆箱操作。</p>
<blockquote>
<p>数组：存储批量数据的一个数据结构</p>
<p>数据类型：</p>
<p>​    基本数据类型：</p>
<p>​        数字</p>
<p>​        字符串</p>
<p>​        布尔值</p>
<p>​    特殊数据类型：</p>
<p>​        undefined null NaN</p>
<p>​    复合/引用数据类型：</p>
<p>​        数组</p>
</blockquote>
<h2 id="数组的声明和使用"><a href="#数组的声明和使用" class="headerlink" title="数组的声明和使用"></a>数组的声明和使用</h2><h3 id="声明数组三种方法"><a href="#声明数组三种方法" class="headerlink" title="声明数组三种方法"></a>声明数组三种方法</h3><p>1、var arr = new Array(10, true, “hello”);</p>
<p>2、var arr = Array(10 , true, “hello”);</p>
<p>3、var arr = [10, true, “hello”];</p>
<p>new Array()</p>
<p>Array()</p>
<p>​    如果传入参数的时候，仅仅传入了一个参数并且是个数字；</p>
<p>​    这是它的作用是声明了一个传入数字大小的数组，而不是把这个数字存了进去；</p>
<h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><p>数组元素：数组中的每一个数据</p>
<p>访问元素，通过下标（索引）访问。数组[下标]，下标从零开始</p>
<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p>1、for循环遍历</p>
<p>for(var i = 0; i&lt; arr.length; i++){</p>
<p>​    arr[i];</p>
<p>}</p>
<p>2、快速遍历（快速枚举）</p>
<blockquote>
<p>执行效率更高（但不稳定）</p>
<p>尽量在for in 的时候，不要增删数组中的元素。</p>
</blockquote>
<p>for(var i in arr){</p>
<p>​    arr[i];</p>
<p>}</p>
<h2 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h2><h3 id="1、栈方法-模拟栈结构"><a href="#1、栈方法-模拟栈结构" class="headerlink" title="1、栈方法(模拟栈结构)"></a>1、栈方法(模拟栈结构)</h3><p>特点：先进后出，从一头进同一一头出；</p>
<p>ECMAScript 数组提供了一种让数组的行为类似于其他数据结构的方法。也就是说，可 以让数组像栈一样，可以限制插入和删除项的数据结构。栈是一种数据结构(后进先出)，也 就是说最新添加的元素最早被移除。而栈中元素的插入(或叫推入)和移除(或叫弹出)，只发 生在一个位置——栈的顶部。ECMAScript 为<strong>数组</strong>专门提供了 <strong>push()</strong>和 <strong>pop()</strong>方法。</p>
<p><img src="C:\Users\罗中运\AppData\Local\Temp\chrome_drag6452_26913\Image.png" alt="Image"></p>
<h4 id="1、进栈："><a href="#1、进栈：" class="headerlink" title="1、进栈："></a>1、进栈：</h4><blockquote>
<p> push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回最该后数组的长度。</p>
</blockquote>
<p>push</p>
<p>格式：数组.push（参数一，参数二，。。。）；</p>
<p>功能：给原来的数组末尾加元素，直接修改原数组；</p>
<p>返回值：插完元素后，数组的长度；</p>
<h4 id="2、出栈："><a href="#2、出栈：" class="headerlink" title="2、出栈："></a>2、出栈：</h4><blockquote>
<p>二pop()方法则从数组末尾移除最后一个元素，减少数组的length值，然后返回移除的元素。</p>
</blockquote>
<p>pop</p>
<p>格式：数组.pop();</p>
<p>功能：在原来数组末尾取出一个元素；</p>
<p>返回值：取出的元素；</p>
<h3 id="2、队列方法（模拟队列）"><a href="#2、队列方法（模拟队列）" class="headerlink" title="2、队列方法（模拟队列）"></a>2、队列方法（模拟队列）</h3><p>特点：先进先出，从头部进，从尾部出；</p>
<p>队列在数组的末端添加元素，从数组的前端移除元素。通过push()想数组末尾添加一个元素，然后通过shift()方法从数组前端移除一个元素。</p>
<p><img src="C:\Users\罗中运\AppData\Local\Temp\chrome_drag6452_6292\Image.png" alt="Image"></p>
<p>1、shift() </p>
<blockquote>
<p> 方法可以移除数组首元素，并且返回长度</p>
</blockquote>
<p>孪生元素：unshift（）：从数组头部插入元素，返回插入后数组的长度；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alert(box.push(<span class="string">"深圳”));      //数组末尾添加一个元素，并且返回长度</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">alert(box.shift());                 //移除数组开头元素，并返回移除元素</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">alert(box.unshift());             //数组开头添加两个元素</span></span><br></pre></td></tr></table></figure>
<p>2.push（）</p>
<h2 id="复合数据类型与基本数据类型"><a href="#复合数据类型与基本数据类型" class="headerlink" title="复合数据类型与基本数据类型"></a>复合数据类型与基本数据类型</h2><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><strong>基本数据类型</strong></h4><h5 id="在声明变量，var-num2-num1赋值的时候引用没变，只是数值变了；"><a href="#在声明变量，var-num2-num1赋值的时候引用没变，只是数值变了；" class="headerlink" title="在声明变量，var num2 = num1赋值的时候引用没变，只是数值变了；"></a>在声明变量，var num2 = num1赋值的时候引用没变，只是数值变了；</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num2 = num1;</span><br><span class="line"></span><br><span class="line">num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">alert(num1);<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">alert(num2);<span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h4><h5 id="gt-在进行arr2-arr1的时候实际上是将引用赋值了过去；这时候他们的引用（地址）不同但是所指向的内容（堆）相同；"><a href="#gt-在进行arr2-arr1的时候实际上是将引用赋值了过去；这时候他们的引用（地址）不同但是所指向的内容（堆）相同；" class="headerlink" title="&gt; 在进行arr2=arr1的时候实际上是将引用赋值了过去；这时候他们的引用（地址）不同但是所指向的内容（堆）相同；"></a>&gt; 在进行arr2=arr1的时候实际上是将引用赋值了过去；这时候他们的引用（地址）不同但是所指向的内容（堆）相同；</h5><p>​    程序在运行之前，会给程序预先分配好程序运行的空间；    </p>
<p>​    程序运行段 程序运行内存；这部分一旦被申请，就没法修改；</p>
<p>​    复合数据类型存储在叫做<strong>堆</strong>的内存中；</p>
<p><strong>也就是内容实际是存在堆里面，程序运行段内存存的是堆的引用；</strong></p>
<h5 id="在复合数据类型变量里面，只存这个数据的地址；"><a href="#在复合数据类型变量里面，只存这个数据的地址；" class="headerlink" title="在复合数据类型变量里面，只存这个数据的地址；"></a>在复合数据类型变量里面，只存这个数据的地址；</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">"num1"</span>,<span class="string">"num2"</span>,<span class="string">"num3"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = arr1;</span><br><span class="line"></span><br><span class="line">arr2.push(<span class="string">"num4"</span>);</span><br><span class="line"></span><br><span class="line">alert(arr1);<span class="comment">//num1,num2,num3,num4</span></span><br><span class="line"></span><br><span class="line">alert(arr2);<span class="comment">//num1,num2,num3,num4</span></span><br></pre></td></tr></table></figure>
<h3 id="concat方法"><a href="#concat方法" class="headerlink" title="concat方法"></a>concat方法</h3><p>1、功能1：生成一个新数组；</p>
<p>2、功能 2：进行数组合并，生成一个合并后的新数组；</p>
<p>​    格式：数组2 = concat（数组1，元素1，元素2，…）；</p>
<p>var arr2 = arr1.concat();//生成了一个新数组赋值给arr2，而不是将引用（地址）赋值给arr2；</p>
<p><img src="https://img-blog.csdn.net/20161022234725144" alt="这里写图片描述">；</p>
<h3 id="slice方法"><a href="#slice方法" class="headerlink" title="slice方法"></a>slice方法</h3><p>格式： 数组.slice（start，end）；</p>
<p>参数：start 开始提取的位置</p>
<p>​    end 结束提取的位置</p>
<p>​    提取的元素范围[start,end)；</p>
<h5 id="提取元素但不会修改原数组"><a href="#提取元素但不会修改原数组" class="headerlink" title="提取元素但不会修改原数组"></a>提取元素但不会修改原数组</h5><p>返回值：提取到的元素，组成的元素；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&quot;num1&quot;,&quot;num2&quot;,&quot;num3&quot;];</span><br><span class="line">var arr2 = arr1.slice(1,2);//num2</span><br></pre></td></tr></table></figure>
<h3 id="splice方法"><a href="#splice方法" class="headerlink" title="splice方法"></a>splice方法</h3><p>功能：增删改数组</p>
<blockquote>
<p>格式：数组.splice(start,length,元素1，元素2，…)；</p>
<p>功能1：删除选中的元素：数组.splice(start,length）；</p>
<p>功能2：插入元素数组.splice(start,0，元素1，元素2，….）；</p>
<p>功能3：混合使用 数组.splice(start,1，元素);//替换了start位置的元素；</p>
<p>返回值是删除元素的数组；</p>
<p>第一个参数：开始截取的下标</p>
<p>第二个参数：截取元素的长度</p>
<p>第三个和之后的参数，插入的元素</p>
</blockquote>
<h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><p>将数组的元素组起一个字符串，</p>
<blockquote>
<p>格式“数组.jion（字符串）；</p>
<p>参数：拼接的拼接符</p>
<p>返回值：拼接完成的字符串；</p>
</blockquote>
<h4 id="reverse方法"><a href="#reverse方法" class="headerlink" title="reverse方法"></a>reverse方法</h4><blockquote>
<p>数组逆置 </p>
</blockquote>
<p>ps :<strong>concat slice jion不修改原数组；</strong></p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2018/10/19/js数组/">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-js作用域">
    <header class="cube-excerpt-header">
        <h1><a href="/2018/10/19/js作用域/">js作用域</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2018-10-19
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/H5-js/" class="cube-excerpt-tag-link">#H5 js</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>[TOC]</p>
<p>程序必须读到内存中，才能被CPU运行。</p>
<p>声明变量 分配内存空间的过程。</p>
<p>函数调用，函数运行的时候，需要内存空间来运行；</p>
<p>【注】</p>
<p>​    在某一函数内声明的变量或形参（形参在函数内和变量基本一致），它的生命周期是这个函数调用开始到这个函数调用结束，销毁；</p>
<h4 id="作用域："><a href="#作用域：" class="headerlink" title="作用域："></a>作用域：</h4><p>​    局部作用域：每一个函数都死一个局部作用域。</p>
<p>​            在局部作用域里面声明的变量和形参，叫局部变量；</p>
<p>​    全局作用域：在全局作用域里面声明的变量和形参，叫做全局变量；</p>
<h5 id="js中只有全局作用域和函数作用域"><a href="#js中只有全局作用域和函数作用域" class="headerlink" title="js中只有全局作用域和函数作用域"></a>js中只有全局作用域和函数作用域</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i =<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以执行，结果为10</p>
</blockquote>
<p>为什么呢，因为在JavaScript中不同于Java他没有块作用域；</p>
<p>当然在JavaScript中我们也可以实现块作用域的功能。如以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">)()</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种写法叫做立即调用函数表达式</p>
</blockquote>
<h4 id="访问数据："><a href="#访问数据：" class="headerlink" title="访问数据："></a>访问数据：</h4><p>​    1、就近原则</p>
<p>​    2、访问数据，如果当前作用域没有该数据，则从大一级的作用域寻找；</p>
<p>##### </p>
<h4 id="全局函数："><a href="#全局函数：" class="headerlink" title="全局函数："></a>全局函数：</h4><p>​    var a =function(x){</p>
<p>​        var b = ‘bb’;</p>
<p>​        return b;</p>
<p>​    }</p>
<p>【注】：如果不写var直接声明变量，那么这个变量将会被声明为全局变量。</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/2018/10/19/js作用域/">Read More</a>
    </footer>
</div>



<ul class="cube-pagination cube-pagination-9">
    
    <li class="cube-pagination-prev">
        <a href="/">« Prev</a>
    </li>
    
    
        
            
                
                <li class="cube-pagination-index">
                    <a href="/">1</a>
                </li>
                
            
                
                <li class="cube-pagination-index disabled">
                    <span>2</span>
                </li>
                
            
                
                <li class="cube-pagination-index">
                    <a href="/page/3">3</a>
                </li>
                
            
                
                <li class="cube-pagination-index">
                    <a href="/page/4">4</a>
                </li>
                
            
                <li class="cube-pagination-ellipses">
                    <span>...</span>
                </li>
                <li class="cube-pagination-index">
                    <a href="/page/6">6</a>
                </li>
        
    

    
    <li class="cube-pagination-next">
        <a href="/page/3/">Next »</a>
    </li>
    
</ul>

<!--其他组件后续添加-->
        </div>
        <div class="cube-right">
            

<div class="cube-search cube-sidebar" id="cube-search">
    <div class="search-container">
        <input type="text" placeholder="Search" class="cube-search-input" id="cube-search-input">
        <i class="cube-icon cube-icon-search cube-search-submit" aria-hidden="true"></i>
    </div>
    <!-- TODO 通过给window赋一个全局变量，通过脚本赋值 -->
</div>
<script>
    (function (window) {
        'use strict';
        window.searchModule = {}
        window.searchModule.JSONUrl = '/content.json'
        window.searchModule.rootUrl = '/'
    })(window)
</script>
<div class="cube-search-form">
    <div class="cube-search-control">
        <input type="text" placeholder="Search" class="search-input">
        <a class="close-button">
            <i class="cube-icon cube-close" aria-hidden="true"></i>
        </a>
    </div>
    <div class="cube-search-result"></div>
</div>


<div class="cube-author cube-sidebar" id="cube-author">
    
    
    <span>luozy</span>
    
    
    <a title="���������������������̰���������ܼ�������̰����">���������������������̰���������ܼ�������̰����</a>
    
    <div class="count">
        <a class="count articles"><span>55</span>Article</a>
        <a class="count tags"><span>13</span>Tags</a>
        <a class="count categories"><span>0</span>Categories</a>
    </div>
</div>



<div class="cube-music cube-sidebar" id="cube-music">
    <div class="cube-player aplayer" id="cube-player"></div>
</div>
<script>
    (function (window) {
        window.musicModule = {}
        window.musicModule.musicConfig = '{"narrow":false,"autoplay":false,"showlrc":3,"theme":"#b7daff","mutex":true,"mode":"circulation","preload":"auto","listmaxheight":"513px","music":[{"title":"Dear friends","author":"TRIPLANE","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/TRIPLANE - Dear friends.mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/Dear friends - TRIPLANE.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/TRIPLANE - Dear friends.jpg"},{"title":"Butter-Fly","author":"和田光司","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/和田光司 - Butter-Fly (ピアノヴァージョン).mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/Butter-Fly (ピアノヴァージョン) - 和田光司.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/和田光司 - Butter-Fly (ピアノヴァージョン).jpg"},{"title":"宵闇花火","author":"葉月ゆら","url":"http://cube-1252774894.cosgz.myqcloud.com/music/source/葉月ゆら - 宵闇花火.mp3","lrc":"http://cube-1252774894.cosgz.myqcloud.com/music/lrc/宵闇花火 - 葉月ゆら.lrc","pic":"http://cube-1252774894.cosgz.myqcloud.com/music/image/葉月ゆら - 宵闇花火.jpg"}]}'
        window.musicModule.lrcConfig = {
            open: 'Open Lyrics',
            close: 'Close Lyrics'
        }
    })(window)
</script>



<div class="cube-recent-posts cube-sidebar" id="cube-recent-posts">
    <div class="title">
        <a>Recent Posts</a>
    </div>
    <ul class="list">
        
        
        <li>
            <!-- TODO 如果文章要显示图片，那么在front-matter上添加preview属性(url or path) -->
            
            <div class="normal">
                <p class="index first">
                    <span>1</span>
                </p>
                <p class="title">
                    <a href="/2018/11/06/怪异盒模型/" title=""></a>
                </p>
            </div>
            
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>2</span>
                </p>
                <p class="title">
                    <a href="/2018/11/06/TCP、UDP/" title="TCP、UDP">TCP、UDP</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>3</span>
                </p>
                <p class="title">
                    <a href="/2018/11/06/ECMA5、6/" title="ECMA5、6">ECMA5、6</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>4</span>
                </p>
                <p class="title">
                    <a href="/2018/11/03/js控制style/" title="js控制style">js控制style</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>5</span>
                </p>
                <p class="title">
                    <a href="/2018/11/02/正则表达式/" title="正则表达式">正则表达式</a>
                </p>
            </div>
        </li>
        
        
    </ul>
</div>





<div class="cube-tagcloud cube-sidebar" id="cube-tagcloud">
    <div class="title">
        <a href="/tags">Tagcloud</a>
    </div>
    <div class="cube-boxs">
        
        
        <div class="cube-box ">
            <a href="/tags/js/">#js</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/H5/">#H5</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/H5-js/">#H5 js</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/学习/">#学习</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/github/">#github</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/H5-js-函数/">#H5 js 函数</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/H5-js-循环/">#H5 js 循环</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/js-H5/">#js H5</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/jsp/">#jsp</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/算法/">#算法</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/网页推荐/">#网页推荐</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/前端/">#前端</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/对象/">#对象</a>
        </div>
        
    </div>
</div>



<div class="cube-links cube-sidebar" id="cube-links">
    <div class="title">
        <a>Links</a>
    </div>
    <ul class="list">
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/GitHub.png">
            
            <a href="https://github.com/luozygithub" target="_blank">GitHub</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/Coding.png">
            
            <a href="https://coding.net/u/SORA1" target="_blank">Coding</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/SF.png">
            
            <a href="https://segmentfault.com/u/aonosora" target="_blank">SF社区</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/开发者头条.png">
            
            <a href="https://toutiao.io/u/148070" target="_blank">开发者头条</a>
        </li>
        
    </ul>
</div>



<div class="cube-friend-links cube-sidebar" id="cube-friend-links">
    <div class="title">
        <a>Friend Links</a>
    </div>
    <ul class="list">
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="http://cube-1252774894.cosgz.myqcloud.com/friend_links/micblo.png">
            <a href="https://blog.micblo.com/" target="_blank">罗大佬</a>
        </li>
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="http://cube-1252774894.cosgz.myqcloud.com/friend_links/DIYgod.jpg">
            <a href="https://www.anotherhome.net/" target="_blank">DIYgod</a>
        </li>
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="/images/friend_links.jpg ">
            <a href="https://aonosora.com/" target="_blank">咪西西の部落格</a>
        </li>
        
    </ul>
</div>


        </div>
    </div>
</div>
<footer class="cube-footer">
    
© 2017 luozy

<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.&nbsp;Theme by <a href="https://github.com/ZEROKISEKI" target="_blank">AONOSORA</a>
</footer>
<!-- inject:script -->
<script src="/js/script.js"></script>
<!-- endinject -->
<div class="cube-loading out"></div>
</body>
</html>