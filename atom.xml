<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chentj&#39;s Blog</title>
  
  <subtitle>Inflexible thinking, bad humor</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tianjiec.top/"/>
  <updated>2019-02-06T12:46:38.853Z</updated>
  <id>https://tianjiec.top/</id>
  
  <author>
    <name>chentj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue常用插件</title>
    <link href="https://tianjiec.top/2019/02/06/vue%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://tianjiec.top/2019/02/06/vue常用插件/</id>
    <published>2019-02-06T12:44:59.000Z</published>
    <updated>2019-02-06T12:46:38.853Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener">element</a> ★13489 - 饿了么出品的Vue2的web UI工具套件</li><li><a href="https://github.com/airyland/vux" target="_blank" rel="noopener">Vux</a> ★8133 - 基于Vue和WeUI的组件库</li><li><a href="https://github.com/iview/iview" target="_blank" rel="noopener">iview</a> ★6634 - 基于 Vuejs 的开源 UI 组件库</li><li><a href="https://github.com/ElemeFE/mint-ui" target="_blank" rel="noopener">mint-ui</a> ★6253 - Vue 2的移动UI元素</li><li><a href="https://github.com/museui/muse-ui" target="_blank" rel="noopener">muse-ui</a> ★3705 - 三端样式一致的响应式 UI 库</li><li><a href="https://github.com/marcosmoura/vue-material" target="_blank" rel="noopener">vue-material</a> ★3328 - 通过Vue Material和Vue 2建立精美的app应用</li><li><a href="https://github.com/vuetifyjs/vuetify" target="_blank" rel="noopener">vuetify</a> ★2925 - 为移动而生的Vue JS 2组件框架</li><li><a href="https://github.com/JosephusPaye/Keen-UI" target="_blank" rel="noopener">Keen-UI</a> ★2749 - 轻量级的基本UI组件合集</li><li><a href="https://github.com/wangdahoo/vonic" target="_blank" rel="noopener">vonic</a> ★1913 - 快速构建移动端单页应用</li><li><a href="https://github.com/monterail/vue-multiselect" target="_blank" rel="noopener">vue-multiselect</a> ★1539 - Vue.js选择框解决方案</li><li><a href="https://github.com/egoist/eme" target="_blank" rel="noopener">eme</a> ★1529 - 优雅的Markdown编辑器</li><li><a href="https://github.com/taylorchen709/vueAdmin" target="_blank" rel="noopener">vueAdmin</a> ★1455 - 基于vuejs2和element的简单的管理员模板</li><li><a href="https://github.com/pi0/bootstrap-vue" target="_blank" rel="noopener">bootstrap-vue</a> ★1267 - 应用于Vuejs2的Twitter的Bootstrap 4组件</li><li><a href="https://github.com/David-Desmaisons/Vue.Draggable" target="_blank" rel="noopener">Vue.Draggable</a> ★1191 - 实现拖放和视图模型数组同步</li></ul><p>[详情地址][<a href="https://blog.csdn.net/osdfhv/article/details/78892477" target="_blank" rel="noopener">https://blog.csdn.net/osdfhv/article/details/78892477</a>]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ElemeFE/element&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;element&lt;/a&gt; ★13489 - 饿了么出品的Vue2的web UI工具套件&lt;/li&gt;
&lt;li&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="-插件" scheme="https://tianjiec.top/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>react常用插件</title>
    <link href="https://tianjiec.top/2019/02/06/react%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://tianjiec.top/2019/02/06/react常用插件/</id>
    <published>2019-02-06T12:43:32.000Z</published>
    <updated>2019-02-06T12:44:32.466Z</updated>
    
    <content type="html"><![CDATA[<p>axios(http请求模块，可用于前端任何场景，很强大)<br>echarts-for-react(可视化图表，别人基于react对echarts的封装，足够用了)<br>recharts(另一个基于react封装的图表，个人觉得是没有echarts好用)<br>nprogress(顶部加载条，蛮好用)<br>react-draft-wysiwyg(别人基于react的富文本封装，如果找到其他更好的可以替换)<br>react-draggable(拖拽模块，找了个简单版的)<br>screenfull(全屏插件)<br>photoswipe(图片弹层查看插件，不依赖jQuery，还是蛮好用)<br>animate.css(css动画库)<br>redux Web 应用是一个状态机，视图与状态是一一对应的.所有的状态，保存在一个对象里面<br>redux-logger 日志<br>Reselect 记忆组件<br>redux-thunk 为了解决异步action的问题<br>redux-saga 为了解决异步action的问题<br>react-router-redux 保持路由与应用状态(state)同步</p><p>react-router-dom</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;axios(http请求模块，可用于前端任何场景，很强大)&lt;br&gt;echarts-for-react(可视化图表，别人基于react对echarts的封装，足够用了)&lt;br&gt;recharts(另一个基于react封装的图表，个人觉得是没有echarts好用)&lt;br&gt;npro
      
    
    </summary>
    
    
      <category term="-插件" scheme="https://tianjiec.top/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>React项目</title>
    <link href="https://tianjiec.top/2019/01/16/React%E9%A1%B9%E7%9B%AE/"/>
    <id>https://tianjiec.top/2019/01/16/React项目/</id>
    <published>2019-01-16T12:19:48.000Z</published>
    <updated>2019-01-16T13:11:03.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、初始化项目"><a href="#一、初始化项目" class="headerlink" title="一、初始化项目"></a>一、初始化项目</h2><p>初始化            create-react-app react-pro</p><p>抽离配置文件        yarn eject</p><p>安装相关依赖        cnpm install node-sass -D     、    cnpm i redux redux-thunk react-redux axios -S</p><h2 id="二、搭建项目结构-创建-Store"><a href="#二、搭建项目结构-创建-Store" class="headerlink" title="二、搭建项目结构 创建 Store"></a>二、搭建项目结构 创建 Store</h2><p>删除无用文件</p><h3 id="搭建项目结构："><a href="#搭建项目结构：" class="headerlink" title="搭建项目结构："></a>搭建项目结构：</h3><p>src        /assert</p><p>​        /components    /commons</p><p>​                        /pages</p><p>​                        /template-css</p><p>​                            index.js</p><p>​                            index.scss</p><p>​        /modules</p><p>​                        rem.js : 用来定义html字体，实现rem布局</p><p>​                        /axios-util</p><p>​                            get.js、post.js、index.js：提供请求数据方法</p><p>​                        /groups</p><p>​                            actionCreators.js：把所有actionCreators 这回合到这里 </p><p>​                            index.js：把react-redux的connect要处理的代码封装到这里，</p><p>​                            调用的时候 通过传参数决定 容器props的数据 和方法</p><p>​        /store（redux仓库配置）</p><p>​                        /commons(state.js, actionCreator.js, reducer.js, const.js)</p><p>​                        /index.js : 借助reducer创建 store</p><p>​                        /reducer.js :总reducer，聚合模块的reducer(conbineReducer({commons}))</p><p>​        App.js</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、初始化项目&quot;&gt;&lt;a href=&quot;#一、初始化项目&quot; class=&quot;headerlink&quot; title=&quot;一、初始化项目&quot;&gt;&lt;/a&gt;一、初始化项目&lt;/h2&gt;&lt;p&gt;初始化            create-react-app react-pro&lt;/p&gt;
&lt;p&gt;抽
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react-router</title>
    <link href="https://tianjiec.top/2019/01/14/react-router/"/>
    <id>https://tianjiec.top/2019/01/14/react-router/</id>
    <published>2019-01-14T12:46:05.000Z</published>
    <updated>2019-01-14T12:46:25.211Z</updated>
    
    <content type="html"><![CDATA[<h4 id="React-router-4"><a href="#React-router-4" class="headerlink" title="React-router 4+"></a>React-router 4+</h4><p>在这里，我们学react-router 4.0版本，需要注意的是，在4.0中，路由的搭建更灵活，我们不会基于全局的对于路由进行管理，而是在使用的时候进行路由的配置</p><p>我们需要下载的也不是react-router了，而是 react-router-dom</p><p><a href="https://www.cnblogs.com/zhanghuiming/p/7592132.html" target="_blank" rel="noopener">文档</a></p><ol><li><p>首先现在最外层包裹上Router，Router分为两种：BrowserRouter/HashRouter</p><p>BrowserRouter监听的是地址栏path的变化，HashRouter监听的是hash值的变化，注意HashRouter在某些时候会报一个警告，不允许重复跳转</p><p>  使用BrowserRouter需要后端去进行一个配置</p></li><li><p>在需要切换路由的时候，引入Route，path指定路径，component指定要渲染的组件，render可以传入一个函数，在这里逻辑判断之后再去返回一个组件，exact属性设置之后，只有完全匹配之后才能使用</p></li><li><p>switch 里面只运行渲染一个路由，可以有效的防止同级路由多次渲染</p></li></ol><switch><br>       <route exact="" path="/" component="{Home}"><br><br>       <route path="/render" render="{()" ==""> {<br>           //做出一些逻辑操作之后，返回一个组件<br>           return <div classname="content">render</div><br>       }} /&gt;<br><br>       <route path="/a/b" render="{()" ==""> {<br>           //做出一些逻辑操作之后，返回一个组件<br>           return <div classname="content">ab</div><br>       }} /&gt;<br><br>       <route path="/a" render="{()" ==""> {<br>           //做出一些逻辑操作之后，返回一个组件<br>           return <div classname="content">a</div><br>       }} /&gt;<br></route></route></route></route></switch><ol><li><p>重定向，可以使用Redirect组件，添加from、to属性进行重定向跳转</p></li><li><p>react-router中提供了Link和NavLink，都可以使用to属性进行跳转，NavLink可以对现在路由做出判断后给a标签加上样式或者类名，exact完全匹配</p></li><li><p>路由传参数,react-router4里只有一种参数就是路由参数，需要配置 /detail/:id,而query参数能传，但是传的时候，和取的 时候都没有对应的api来使用</p><p>它们都可以在this.props中的match、location里得到</p></li><li><p>withRouter高阶组件.高阶组件：就是一个函数，任务是为其他的组件添加一些属性和方法api，例如connect，可以将store中的一些东西安装到新生成的容器组件上   withRuter(App)    </p><p>withRouter可以根据传入的组件生成一个新的组件，并且为新组件添加上router相关的api</p></li><li><p>编程式导航： 在组件中获取到history的api进行跳转，如果是路由组件，直接从this.props中取出，如果不是的话，可以让外面的路由组件传入，或者可以使用withRouter高阶组件处理之后使用</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;React-router-4&quot;&gt;&lt;a href=&quot;#React-router-4&quot; class=&quot;headerlink&quot; title=&quot;React-router 4+&quot;&gt;&lt;/a&gt;React-router 4+&lt;/h4&gt;&lt;p&gt;在这里，我们学react-router 
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react-pro</title>
    <link href="https://tianjiec.top/2019/01/14/react-pro/"/>
    <id>https://tianjiec.top/2019/01/14/react-pro/</id>
    <published>2019-01-14T12:45:27.000Z</published>
    <updated>2019-01-14T12:45:42.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react项目搭建流程"><a href="#react项目搭建流程" class="headerlink" title="react项目搭建流程"></a>react项目搭建流程</h2><p>1.初始化项目  create-react-app react-pro<br>  抽离配置文件  yarn eject<br>  安装相关依赖<br>  yarn add node-sass -D<br>  yarn add redux redux-thunk react-redux axios -S</p><ol><li><p>搭建项目结构  并且  创建Store<br>src/assets<br>   /stylesheets/main.scss(_base.scss,_common.scss,_mixin.scss,_reset.scss)<br>   /components/commons<br>​              /pages<br>​              /template<br>​              /template-css<br>​               index.js<br>​               index.scss<br>   /store/commons(state.js,actionCreators.js,reducer.js,const.js)<br>​         /index.js (createStore(reducer,applyMiddlermare(thunk)))<br>​         /reducer.js (combineReducers({commons}))</p><p>   /modules/rem.js<br>​           /axios-util/</p></li><li><p>rem设置</p></li></ol><ol><li><p>配置axios<br><a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">https://www.kancloud.cn/yunye/axios/234845</a></p><p>src/modules/axios-util<br>​          (get.js/post.js/index.js)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//index.js文件</span><br><span class="line">import Post from &quot;./post&quot;</span><br><span class="line">import Get from &quot;./get&quot;</span><br><span class="line">import &#123;Component&#125; from &quot;react&quot;</span><br><span class="line">//方便在react组件中直接通过this.$post/this.$get直接请求数据</span><br><span class="line">Component.prototype.$post = Post;</span><br><span class="line">Component.prototype.$get = Get;</span><br><span class="line">//为了方便其他地方去使用请求，例如非组件的模块  actionCreators?可以发送异步请求</span><br><span class="line">export &#123;</span><br><span class="line">      Post,</span><br><span class="line">      Get</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一级路由的配置<br>cnpm install react-router-dom -S<br>  1)首先现在最外层包裹上Router，Router分为两种：BrowserRouter/HashRouter<br>  2)在需要切换路由的时候，引入Route，path指定路径，component指定要渲染的组件<br> exact属性设置之后，只有完全匹配之后才能使用<br>  3)switch 里面只运行渲染一个路由，可以有效的防止同级路由多次渲染</p>   <switch><br>​         <route path="/" component="{Home}" exact=""><br>​         <route path="/list" component="{List}"><br>​         <route path="/buycar" component="{BuyCar}"><br>​         <route path="/mine" component="{Mine}"><br>   </route></route></route></route></switch><p>   renderRoutes(){<br>   let {routes} = this.props;<br>   return (<br>​         <switch><br>​         {<br>​         routes.map(item=&gt;(<route key="{item.id}" path="{item.path}" component="{item.component}" exact="{item.exact}">))<br>​         }<br>​         </route></switch><br>   )<br>   }</p></li><li><p>AppFooter的设置<br>将通用的AppFooter放入在commons文件夹里面<br>用到AppFooter了，将他放入哪里呢？<br>1）第一种放入App.js文件里面 我们需要对于不需要底部的例如mine不需要，单独处理<br>2）第二种哪里需要直接扔哪里</p></li></ol><p>思考？<br>​      把AppFooter放入App.js文件里面，那么所有的页面都会有footer了,如果mine组件不希望有footer，怎么处理？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">让App组件监听路由的变化，然后做出判断，选择性的去渲染AppFooter</span><br><span class="line"></span><br><span class="line">*Mine组件是路由组件，app组件不是路由组件</span><br><span class="line">*Mine组件的属性上后history/location/match,app组件上没有</span><br><span class="line">-&gt;路由自身的属性上有history/location/match这些属性！</span><br><span class="line"></span><br><span class="line">*当路由切换的时候，App组件render函数会重新执行</span><br><span class="line">*只有属性或者状态改变的时候，render函数才会重新执行</span><br><span class="line">*发现app组件没有状态，属性也没用发生改变（componentWillReceiveProps不会执行），那为什么它的render函数会重新执行呢？</span><br><span class="line">*原因就是父组件Router的属性或者状态发生变化了，render了，导致子组件APP也进行了渲染，所以App的render函数会重新执行！可不可以在shouldComponentUpdate钩子函数里面进行状态的更改呢？不可以的，因为在这里设置状态，会导致死循环！</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*当hash值变化的时候，Mine组件的render函数会重新执行</span><br><span class="line">*只有属性或者状态更改的时候render函数才会重新执行</span><br><span class="line">*Mine组件没有状态，但是发现componentWillReceiveProps钩子函数每当路由变化的时候会重新执行</span><br><span class="line">-&gt;路由变化的时候，Mine组件的属性就会发生变化</span><br><span class="line">-&gt;路由变化的时候路由组件的属性会发生变化，如果我们想在路由组件中监听路由的变化，只需要在componentWillReceiveProps里面写代码即可</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*问题是： 路由组件可以监听路由的变化，但是app组件不是路由组件，如何也能让他监听路由的变化呢？</span><br><span class="line">*只要App组件外面也套一个Route路由组件，就可以监听到路由的变化了！</span><br><span class="line">*解决办法  需要引入withRouter,作用就是将不是路由组件的普通组件变成伪路由组件，不会跳转，但是呢，可以监听到路由的变化！     </span><br><span class="line">-&gt;只要引入withRouter,就可以变成伪路由组件，不是真正的路由组件，但是Route相关的属性或者方法。</span><br></pre></td></tr></table></figure><p>​<br>​       </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;react项目搭建流程&quot;&gt;&lt;a href=&quot;#react项目搭建流程&quot; class=&quot;headerlink&quot; title=&quot;react项目搭建流程&quot;&gt;&lt;/a&gt;react项目搭建流程&lt;/h2&gt;&lt;p&gt;1.初始化项目  create-react-app react-pr
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react相关知识点</title>
    <link href="https://tianjiec.top/2019/01/14/react%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://tianjiec.top/2019/01/14/react相关知识点/</id>
    <published>2019-01-14T12:42:35.000Z</published>
    <updated>2019-01-14T12:43:23.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React相关知识点"><a href="#React相关知识点" class="headerlink" title="React相关知识点"></a>React相关知识点</h2><p>React核心是组件！<br>React精髓是函数式编程！</p><p>1.react和vue对比：<br>   vue状态改变，只改变自己的视图<br>   vue很多的思想都是借鉴的react组件，并且又做了一些优化<br>   核心库都关注与视图层</p><p>2.React项目开源时间是：41395</p><p>3.React 16 将提供一个内置函数 componentDidCatch，如果 render() 函数抛出错误，则会触发该函数<br>componentDidCatch钩子函数是当项目发生错误的时候触发的</p><p>4.Redux中哪个方法收到action？<br>  dispatch方法负责收到、派发action (dispatch(action))<br>  actionCreator负责创建action<br>  reducer负责接收store传递过来的action</p><p>5.react－router4.0 核心对象包含Router/BrowserRouter/hashRouter/Route/Switch/withRouter等</p><p>6.react-router2.0中路由容器是｛this.props.children｝</p><ol><li>react中key值作用：<br>keys是什么帮助 React 跟踪哪些项目已更改、添加或从列表中删除。<br>每个 keys 在兄弟元素之间是独一无二的。<br>keys 使处理列表时更加高效，因为 React 可以使用子元素上的 keys 快速知道元素是新的还是在比较树时才被移动。<br>keys 不仅使这个过程更有效率，而且没有 keys ，React 不知道哪个本地状态对应于移动中的哪个项目。</li></ol><p>8.无状态组件与有状态的组件的区别是什么？<br>  没有状态，没有生命周期，只是简单的接受 props 渲染生成 DOM 结构。<br>  无状态组件非常简单，开销很低，如果可能的话尽量使用无状态组件。<br>  无状态的函数创建的组件是无状态组件，它是一种只负责展示的纯组件，<br>  无状态组件可以使用纯函数来实现。</p><p>  无状态组件定义函数方式如：（就是一个函数，根据接受到的属性来做不同的操作渲染）<br>​    const app = (props)=&gt;{return (<div>aaa</div>)}</p><p>9.在自定义的React组件当中，哪个生命周期函数必写？render函数</p><h2 id="flux知识点汇总：-https-www-cnblogs-com-fliu-articles-5245923-html"><a href="#flux知识点汇总：-https-www-cnblogs-com-fliu-articles-5245923-html" class="headerlink" title="flux知识点汇总：[https://www.cnblogs.com/fliu/articles/5245923.html]"></a>flux知识点汇总：[<a href="https://www.cnblogs.com/fliu/articles/5245923.html" target="_blank" rel="noopener">https://www.cnblogs.com/fliu/articles/5245923.html</a>]</h2><p>1.flux中能够调用setState方法的对象是(顶层容器)<br>2.Flux架构包含哪些部分?<br>​    View： 视图层<br>​    Action（动作）：视图层发出的消息（比如mouseClick）<br>​    Dispatcher（派发器）：用来接收Actions、执行回调函数、是中心枢纽<br>​    Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面</p><ol><li>Flux 的最大特点，就是数据的”单向流动”。<br>用户访问 View<br>View 发出用户的 Action<br>Dispatcher 收到 Action，要求 Store 进行相应的更新<br>Store 更新后，发出一个”change”事件<br>View 收到”change”事件后，更新页面</li></ol><p>可以通过redux与flux架构进行react的状态管理</p><h2 id="虚拟dom理解？-https-www-jianshu-com-p-616999666920"><a href="#虚拟dom理解？-https-www-jianshu-com-p-616999666920" class="headerlink" title="虚拟dom理解？[https://www.jianshu.com/p/616999666920]"></a>虚拟dom理解？[<a href="https://www.jianshu.com/p/616999666920" target="_blank" rel="noopener">https://www.jianshu.com/p/616999666920</a>]</h2><p>所谓virtual，指的是对真实DOM的一种模拟。相对于直接操作真实的DOM结构，我们构建一棵虚拟的树，将各种数据和操作直接应用在这棵虚拟的树上，然后再将对虚拟的树的修改应用到真实的DOM结构上。<br>通过虚拟dom可能会减少真实DOM操作次数，带来性能上的提升，即使我们频繁操作虚拟DOM，我们只需要一定时刻一次性同步修改到真实DOM上即可.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React相关知识点&quot;&gt;&lt;a href=&quot;#React相关知识点&quot; class=&quot;headerlink&quot; title=&quot;React相关知识点&quot;&gt;&lt;/a&gt;React相关知识点&lt;/h2&gt;&lt;p&gt;React核心是组件！&lt;br&gt;React精髓是函数式编程！&lt;/p&gt;
&lt;p&gt;1
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react学习2</title>
    <link href="https://tianjiec.top/2019/01/12/react%E5%AD%A6%E4%B9%A02/"/>
    <id>https://tianjiec.top/2019/01/12/react学习2/</id>
    <published>2019-01-12T09:37:50.000Z</published>
    <updated>2019-01-12T09:38:55.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React框架学习"><a href="#React框架学习" class="headerlink" title="React框架学习"></a>React框架学习</h1><h5 id="React中的事件对象"><a href="#React中的事件对象" class="headerlink" title="React中的事件对象"></a>React中的事件对象</h5><p>react中对于事件进行了处理，解决了一些兼容性问题，react事件对象上面挂载着nativeEvent，这个就是原生的事件对象</p><p>react对事件对象做了优化，如果不取值的话，值都是null</p><h5 id="React中组件通信方式"><a href="#React中组件通信方式" class="headerlink" title="React中组件通信方式"></a>React中组件通信方式</h5><p>父组件与子组件通信</p><ol><li>父组件将自己的状态传递给子组件，子组件当做属性来接收，当父组件更改自己状态的时候，子组件接收到的属性就会发生改变</li><li>父组件利用ref对子组件做标记，通过调用子组件的方法以更改子组件的状态..</li></ol><p>子组件与父组件通信</p><p>父组件将自己的某个方法传递给子组件，在方法里可以做任意操作，比如可以更改状态，子组件通过this.props接收到父组件的方法后调用。</p><p>兄弟组件通信</p><p>在react没有类似vue中的事件总线来解决这个问题，我们只能借助它们共同的父级组件来实现，将非父子关系装换成多维度的父子关系</p><p>复杂的非父子组件通信在react中很难处理，多组件间的数据共享也不好处理，所以我们会使用flux、redux来实现这样的功能，解决这个问题</p><h5 id="React中表单元素默认值"><a href="#React中表单元素默认值" class="headerlink" title="React中表单元素默认值"></a>React中表单元素默认值</h5><p>在react中，如果需要 给表单元素设置默认value或者checked，需要设置成defaultValue/defaultChecked，否则设置默认值以后，用户无法更改</p><h5 id="React-keys"><a href="#React-keys" class="headerlink" title="React-keys"></a>React-keys</h5><p>我们在react中循环列表数据的时候，需要对循环出来的虚拟jsx节点传入上key这个数据，</p><p>Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。</p><h5 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h5><p>就是如果有多个组件共享一个数据，把这个数据放到共同的父级组件中来管理</p><h5 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h5><p>在vue中有一个内容分发叫slot，在react中也有实现，就是可以在使用组件的时候，在组件标签内部放入一些不固定的内容，在该组件的模板中，只有{this.props.children}来表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//App</span><br><span class="line">&lt;Dialog</span><br><span class="line">close=&#123;this.ToggleDialogShow&#125; isShow=&#123;isDialogShow&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;ContentA/&gt;</span><br><span class="line">    &lt;ContentA/&gt;</span><br><span class="line">    &lt;ContentB/&gt;</span><br><span class="line">&lt;/Dialog&gt;</span><br><span class="line"></span><br><span class="line">//dialog</span><br><span class="line">&lt;div style=&#123;&#123;display:isShow?&apos;block&apos;:&apos;none&apos;&#125;&#125; className=&quot;dialog&quot;&gt;</span><br><span class="line">    &lt;Button handler=&#123;this.props.close&#125; text=&quot;关闭&quot;/&gt;   </span><br><span class="line">    &#123;this.props.children&#125;//这里就是slot</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React框架学习&quot;&gt;&lt;a href=&quot;#React框架学习&quot; class=&quot;headerlink&quot; title=&quot;React框架学习&quot;&gt;&lt;/a&gt;React框架学习&lt;/h1&gt;&lt;h5 id=&quot;React中的事件对象&quot;&gt;&lt;a href=&quot;#React中的事件对象&quot; c
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react学习1</title>
    <link href="https://tianjiec.top/2019/01/12/react%E5%AD%A6%E4%B9%A01/"/>
    <id>https://tianjiec.top/2019/01/12/react学习1/</id>
    <published>2019-01-12T09:37:43.000Z</published>
    <updated>2019-01-12T09:38:19.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React框架学习"><a href="#React框架学习" class="headerlink" title="React框架学习"></a>React框架学习</h1><h3 id="React的起源和发展"><a href="#React的起源和发展" class="headerlink" title="React的起源和发展"></a>React的起源和发展</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">起初facebook在建设instagram（图片分享）的时候嘞，因为牵扯到一个东西叫数据流，那为了处理数据流并且还要考虑好性能方面的问题嘞，Facebook开始对市场上的各种前端MVC框架去进行一个研究，然而并没有看上眼的，于是Facebook觉得，还是自己开发一个才是最棒的，那么他们决定抛开很多所谓的“最佳实践”，重新思考前端界面的构建方式，他们就自己开发了一套，果然大牛创造力还是很强大的。</span><br></pre></td></tr></table></figure><h3 id="React的出发点"><a href="#React的出发点" class="headerlink" title="React的出发点"></a>React的出发点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基于HTML的前端界面开发正变得越来越复杂，其本质问题基本都可以归结于如何将来自于服务器端或者用户输入的动态数据高效的反映到复杂的用户界面上。而来自Facebook的React框架正是完全面向此问题的一个解决方案，按官网描述，其出发点为：用于开发数据不断变化的大型应用程序（Building large applications with data that changes over time）。相比传统型的前端开发，React开辟了一个相当另类的途径，实现了前端界面的高性能高效率开发。</span><br></pre></td></tr></table></figure><h3 id="React与传统MVC的关系"><a href="#React与传统MVC的关系" class="headerlink" title="React与传统MVC的关系"></a>React与传统MVC的关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">轻量级的视图层框架！</span><br><span class="line"></span><br><span class="line">React不是一个完整的MVC框架，最多可以认为是MVC中的V（View），甚至React并不非常认可MVC开发模式；</span><br></pre></td></tr></table></figure><h3 id="React高性能的体现：虚拟DOM"><a href="#React高性能的体现：虚拟DOM" class="headerlink" title="React高性能的体现：虚拟DOM"></a>React高性能的体现：虚拟DOM</h3><p>React高性能的原理：</p><p>在Web开发中我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而复杂或频繁的DOM操作通常是性能瓶颈产生的原因（如何进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标）。</p><p>React为此引入了虚拟DOM（Virtual DOM）的机制：在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。而且React能够批处理虚拟DOM的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从A-B,B-A，React会认为A变成B，然后又从B变成A  UI不发生任何变化，而如果通过手动控制，这种逻辑通常是极其复杂的。</p><p>尽管每一次都需要构造完整的虚拟DOM树，但是因为虚拟DOM是内存数据，性能是极高的，部而对实际DOM进行操作的仅仅是Diff分，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体的DOM元素，而只需要关心在任意一个数据状态下，整个界面是如何Render的。数据驱动，声明式</p><h3 id="React的特点和优势"><a href="#React的特点和优势" class="headerlink" title="React的特点和优势"></a>React的特点和优势</h3><ol><li>虚拟DOM</li></ol><p>我们以前操作dom的方式是通过document.getElementById()的方式，这样的过程实际上是先去读取html的dom结构，将结构转换成变量，再进行操作</p><p>而reactjs定义了一套变量形式的dom模型，一切操作和换算直接在变量中，这样减少了操作真实dom，性能真实相当的高，和主流MVC框架有本质的区别，并不和dom打交道</p><ol><li>组件系统</li></ol><p>react最核心的思想是将页面中任何一个区域或者元素都可以看做一个组件 component</p><p>那么什么是组件呢？  .vue  template script style lang=”scss” node-sass sass-loader</p><p>组件指的就是同时包含了html、css、js、image元素的聚合体</p><p>使用react开发的核心就是将页面拆分成若干个组件，并且react一个组件中同时耦合了css、js、image，这种模式整个颠覆了过去的传统的方式</p><ol><li>单向数据流  <father><son name=""></son></father>父子通信  vuex state—&gt;component(this.$store.state) —-&gt; actions（{commit}）(this.$store.dispatch()) —-&gt; mutations(this.$store.commit()) —–&gt; state</li></ol><p>其实reactjs的核心内容就是数据绑定，所谓数据绑定指的是只要将一些服务端的数据和前端页面绑定好，开发者只关注实现业务就行了  </p><ol><li>JSX  语法  </li></ol><p>在vue中，我们使用render函数来构建组件的dom结构性能较高，因为省去了查找和编译模板的过程，但是在render中利用createElement创建结构的时候代码可读性较低，较为复杂，此时可以利用jsx语法来在render中创建dom，解决这个问题，但是前提是需要使用工具来编译jsx</p><h3 id="创建第一个组件-15-16"><a href="#创建第一个组件-15-16" class="headerlink" title="创建第一个组件  15.  16"></a>创建第一个组件  15.  16</h3><p>react开发需要引入多个依赖文件：react.js、react-dom.js，分别又有开发版本和生成版本</p><p>在这里一开始，我们先学习es5的组件写法，React.createClass，需要引入的是15+</p><p>react.js中有React对象，帮助我们创建组件等功能</p><p>react-dom.js中有ReactDOM对象，渲染组件的虚拟dom为真实dom的爆发功能<br>​<br>在编写react代码的时候会大量的使用到jsx代码，但是需要编译：</p><ol><li>浏览器端编译，通过引入browser、babel等对引入的script内的代码做编译</li><li>利用webpack等开发环境进行编译，将编译好的文件引入到应用中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//创建组件</span><br><span class="line">var Hello = React.createClass(&#123;</span><br><span class="line">    render:function () &#123;</span><br><span class="line">        //render函数和Vue组件里的render完全一样，在vue组件中可以不用编写render函数，这个时候可以使用template模板来编写组件的虚拟dom结构，然后vue组件会自动讲模板compile成虚拟dom结构放入到render中执行，但是react需要编写render函数</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            //jsx语法</span><br><span class="line">            &lt;div&gt;asdasd&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//利用ReactDOM对象的render方法将组件渲染到某个节点里</span><br><span class="line">ReactDOM.render(&lt;Hello/&gt;,document.getElementById(&quot;app&quot;))</span><br></pre></td></tr></table></figure><p>组件是通过React.createClass创建的（ES5），在es6中直接通过class关键字来创建</p><p>组件其实就是一个构造器,每次使用组件都相当于在实例化组件</p><p>react的组件必须使用render函数来创建组件的虚拟dom结构</p><p>组件需要使用ReactDOM.render方法将其挂载在某一个节点上</p><p>组件的首字母必须大写</p><h3 id="JSX语法糖"><a href="#JSX语法糖" class="headerlink" title="JSX语法糖"></a>JSX语法糖</h3><p>JSX是一种语法，全称：javascript xml</p><p>JSX语法不是必须使用的，但是因为使用了JSX语法之后会降低我们的开发难度，故而这样的语法又被成为语法糖</p><p>在不使用JSX的时候，需要使用React.createElement来创建组件的dom结构，但是这样的写法虽然不需要编译，但是维护和开发的难度很高，且可读性很差</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var world = React.createElement(&apos;h1&apos;,&#123;className:&apos;abc&apos;,id:&apos;haha&apos;&#125;,[</span><br><span class="line">    React.createElement(&apos;span&apos;,null,&apos;Hello&apos;),</span><br><span class="line">    React.createElement(&apos;mark&apos;,null,&apos;React&apos;)</span><br><span class="line">])</span><br><span class="line">            </span><br><span class="line">//利用ReactDOM对象的render方法将组件渲染到某个节点里</span><br><span class="line">ReactDOM.render(world,document.getElementById(&quot;app1&quot;))</span><br></pre></td></tr></table></figure><p>及时使用了JSX语法了之后，也是需要将其编译成原生的createElement的</p><p>JSX就是在js中使用的xml，但是，这里的xml不是真正的xml，只能借鉴了一些xml的语法，例如：</p><p>最外层必须有根节点、标签必须闭合</p><p>jsx借鉴xml的语法而不是html的语法原因：xml要比html严谨，编译更方便</p><h3 id="组件dom添加样式"><a href="#组件dom添加样式" class="headerlink" title="组件dom添加样式"></a>组件dom添加样式</h3><p>在react里表达式的符号是 “{  }”,作用和vue的表达式作用是一样的</p><p>想给虚拟dom添加行内样式，需要使用表达式传入样式对象的方式来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style = &#123; &#123;color:&apos;red&apos;,fontSize:2+&apos;em&apos;&#125; &#125;&gt;Hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>行内样式需要写入一个样式对象，而这个样式对象的位置可以放在很多地方，例如React.createClass的配置项中、render函数里、组件原型上、外链js文件中</p><p>React推荐我们使用行内样式，因为react觉得每一个组件都是一个独立的整体</p><p>其实我们大多数情况下还是大量的在为元素添加类名、id以使用某些样式，但是需要注意的是，class需要写成className（因为毕竟是在写类js代码，会收到js规则的现在，而class是关键字）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p className=&quot;bg-p&quot; id=&quot;myp&quot; style = &#123; this.style &#125;&gt;Hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="React-Event"><a href="#React-Event" class="headerlink" title="React Event"></a>React Event</h3><p>在react中，我们想要给组件的dom添加事件的话，也是 需要在行内添加的方式，事件名字需要写成小驼峰的方式，值利用表达式传入一个函数即可</p><p>注意，在没有渲染的时候，页面中没有真实dom，所以是获取不到dom的</p><p>给虚拟dom结构中的节点添加样式。在行内添加,写成驼峰形式，值是一个函数名，需要用{}包裹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">handleClick:function () &#123;</span><br><span class="line">    alert(1)</span><br><span class="line">&#125;,</span><br><span class="line">render:function () &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick = &#123;this.handleClick&#125; className=&quot;click-btn&quot;&gt;click&lt;/button&gt;</span><br><span class="line">            &lt;button onDoubleClick = &#123;this.handleClick&#125; className=&quot;click-btn&quot;&gt;click&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h3><p>将一个组件渲染到某一个节点里的时候，会将这个节点里原有内容覆盖</p><p>组件嵌套的方式就是将子组件写入到父组件的模板中去，且react没有Vue中的内容分发机制（slot），所以我们在一个组件的模板中只能看到父子关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var Hello = React.createClass(&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;h1&gt;</span><br><span class="line">                Hello </span><br><span class="line">                &lt;World&gt;&lt;/World&gt;</span><br><span class="line">            &lt;/h1&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">var World = React.createClass(&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;mark&gt;</span><br><span class="line">                World-&lt;Person/&gt; </span><br><span class="line">            &lt;/mark&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//无状态组件</span><br><span class="line">var Person =function()&#123;</span><br><span class="line">    return (&lt;mark&gt;lilei&lt;/mark&gt;)</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;Hello/&gt;,app)</span><br></pre></td></tr></table></figure><blockquote><p>注意，react中jsx里的注释要写成{/<em>  </em>/}的方式</p></blockquote><h3 id="React中的数据承载-Props-State"><a href="#React中的数据承载-Props-State" class="headerlink" title="React中的数据承载-Props/State"></a>React中的数据承载-Props/State</h3><p>数据驱动、声明式渲染：</p><p>任意的视图变化都应该由数据来控制</p><p>//$(“.a”).html(0)</p><p>var num = 0<br>function renderNum () { $(“.a”).html(num) }</p><p>React也是基于数据驱动(声明式)的框架，组件中必然需要承载一些数据，在react中起到这个作用的是属性和状态（props &amp; state）</p><ol><li>属性（props）  在组件外部传入，或者内部设置，组件内部通过this.props获得</li><li>状态（state）  在组件内部设置或者更改，组件内部通过this.state获得</li></ol><h5 id="属性-props"><a href="#属性-props" class="headerlink" title="属性(props)"></a>属性(props)</h5><p>属性一般是外部传入的，组件内部也可以通过一些方式来初始化的设置，属性不能被组件自己更改</p><p>属性是描述性质、特点的，组件自己不能随意更改</p><p>使组件拥有属性的方式：</p><ol><li>在装载（mount）组件的时候给组件传入</li></ol><p>传入数据的时候，除了字符串类型，其他的都应该包上表达式，但是为了规整，所有的数据传递，最好都包上{}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var Gouzi = React.createClass(&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;我的名字：&#123;this.props.name&#125;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;我的性别：&#123;this.props.sex&#125;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;我的年龄：&#123;this.props.age&#125;&lt;/p&gt;  </span><br><span class="line">                &lt;p&gt;我的父亲是：&#123;this.props.father&#125;&lt;/p&gt;                                              </span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let info = &#123;</span><br><span class="line">    sex:&apos;male&apos;,</span><br><span class="line">    father:&apos;狗爸&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Gouzi &#123;...info&#125; name=&#123;&quot;大狗子&quot;&#125; age=&#123;26&#125;/&gt;,app)</span><br></pre></td></tr></table></figure><ol><li>父组件给子组件传入</li></ol><p>父组件在嵌套子组件的时候为子组件传入，传入的方式和上面的方式一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//父组件的render函数</span><br><span class="line">render()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;父组件：&lt;/p&gt;</span><br><span class="line">            &lt;hr/&gt;</span><br><span class="line">            &lt;Son name=&#123;&apos;大狗子&apos;&#125;/&gt;</span><br><span class="line">            &lt;Son name=&#123;&apos;二狗子&apos;&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>子组件自己设置</li></ol><p>子组件可以通过getDefaultProps来设置默认的属性</p><p>getDefaultProps的值是函数，这个函数会返回一个对象，我们在这里对象里为组件设置默认属性</p><p>这种方式设置的属性优先级低，会被外部传入的属性值所覆盖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getDefaultProps:function () &#123;</span><br><span class="line">    console.log(&apos;getDefaultProps&apos;)</span><br><span class="line">    return &#123;</span><br><span class="line">        name:&apos;狗爸&apos;,</span><br><span class="line">        sonname:&apos;二狗子&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">//render</span><br><span class="line">&lt;p&gt;我是&#123;this.props.sonname&#125;的父亲-&#123;this.props.name&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>根据属性或状态，我们可以在render中的表达式里做一些逻辑判断，可以使用||、三元表达式、子执行函数等等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">getName()&#123;</span><br><span class="line">    return this.props.name || &apos;野狗子&apos;</span><br><span class="line">&#125;,</span><br><span class="line">render:function () &#123;</span><br><span class="line">    let &#123;name&#125; = this.props</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;我是子组件-&#123;this.props.name || &apos;野狗子&apos;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;我是子组件-&#123;this.props.name?this.props.name:&apos;野狗子&apos;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;我是子组件-&#123;this.getName()&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;我是子组件-&#123;(function (obj) &#123;</span><br><span class="line">            return obj.props.name || &apos;野狗子&apos;</span><br><span class="line">        &#125;)(this)&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="状态-state"><a href="#状态-state" class="headerlink" title="状态(state)"></a>状态(state)</h5><p>状态就是组件描述某种显示情况的数据，由组件自己设置和更改，也就是说由组件自己维护，使用状态的目的就是为了在不同的状态下使组件的显示不同(自己管理)</p><p>在组件中只能通过getInitialState的钩子函数来给组件挂载初始状态,在组件内部通过this.state获取</p><p>this.props和this.state是纯js对象,在vue中，$data属性是利用Object.defineProperty处理过的，更改$data的数据的时候会触发数据的getter和setter，但是react中没有做这样的处理，如果直接更改的话，react是无法得知的，所以，需要使用特殊的更改状态的方法：</p><p>setState(params)</p><p>在setState中传入一个对象，就会将组件的状态中键值对的部分更改，还可以传入一个函数，这个回调函数必须返回像上面方式一样的一个对象，函数可以接收prevState和props</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//1.</span><br><span class="line">let doing = this.state.doing==&apos;学习&apos;+props.knowledge?&apos;玩游戏&apos;:&apos;学习&apos;+props.knowledge</span><br><span class="line">this.setState(&#123;doing&#125;)</span><br><span class="line"></span><br><span class="line">//2.</span><br><span class="line">this.setState((prevState,props)=&gt;&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        doing:prevState.doing==&apos;学习&apos;+props.knowledge?&apos;玩游戏&apos;:&apos;学习&apos;+props.knowledge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="实现下拉菜单的方式"><a href="#实现下拉菜单的方式" class="headerlink" title="实现下拉菜单的方式"></a>实现下拉菜单的方式</h5><ol><li>通过数据来控制元素的行内样式中display的值，或者去控制类名</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul style=&#123;&#123;display:isMenuShow?&apos;block&apos;:&apos;none&apos;&#125;&#125;&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;</span><br><span class="line">...</span><br><span class="line">&lt;ul className=&#123;isMenuShow?&apos;show&apos;:&apos;hide&apos;&#125;&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;</span><br></pre></td></tr></table></figure><ol><li>根据数据控制是否渲染改节点、组件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    isMenuShow?&lt;ul&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;:&apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过ref对dom、组件进行标记，在组件内部通过this.refs获取到之后，进行操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul ref=&apos;content&apos;&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;</span><br><span class="line">...</span><br><span class="line">this.refs.content.style.display = this.state.isMenuShow?&apos;block&apos;:&apos;none&apos;</span><br></pre></td></tr></table></figure><h5 id="属性和状态的对比"><a href="#属性和状态的对比" class="headerlink" title="属性和状态的对比"></a>属性和状态的对比</h5><p>相似点：都是纯js对象，都会触发render更新，都具有确定性（状态/属性相同，结果相同）</p><p>不同点： </p><ol><li>属性能从父组件获取，状态不能</li><li>属性可以由父组件修改，状态不能</li><li>属性能在内部设置默认值 ，状态也可以</li><li>属性不在组件内部修改   ，状态要改</li></ol><p>状态只和自己相关，由自己维护</p><p>属性不要自己修改，可以从父组件获取，也可以给子组件设置</p><p>组件在运行时自己需要修改的数据其实就是状态而已</p><h4 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h4><p>react中组件也有生命周期，也就是说也有很多钩子函数供我们使用，下面是生命周期的图示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./life.jpg" alt="生命周期" title="">                </div>                <div class="image-caption">生命周期</div>            </figure><p>组件是一个构造器，每一次使用组件都相当于在实例化组件，在这个时候，组件就会经历一次生命周期，从实例化实例开始到这个实例销毁的时候，都是一次完整的生命周期</p><p>组件的生命周期，我们会分为三个阶段，初始化、运行中、销毁</p><h5 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h5><ol><li><p>实例化组件之后，组件的getDefaultProps钩子函数会执行</p><p>这个钩子函数的目的是为组件的实例挂载默认的属性</p><p>这个钩子函数只会执行一次，也就是说，只在第一次实例化的时候执行，创建出所有实例共享的默认属性，后面再实例化的时候，不会执行getDefaultProps，直接使用已有的共享的默认属性</p><p>理论上来说，写成函数返回对象的方式，是为了防止实例共享，但是react专门为了让实例共享，只能让这个函数只执行一次</p><p>组件间共享默认属性会减少内存空间的浪费，而且也不需要担心某一个实例更改属性后其他的实例也会更改的问题，因为组件不能自己更改属性，而且默认属性的优先级低。</p></li><li><p>执行getInitialState为实例挂载初始状态，且每次实例化都会执行，也就是说，每一个组件实例都拥有自己独立的状态呢</p></li><li><p>执行componentWillMount，相当于Vue里的created+beforeMount，这里是在渲染之前最后一次更改数据的机会，在这里更改的话是不会触发render的重新执行</p><p>多做一些初始数据的获取</p></li><li><p>执行render，渲染dom</p></li><li><p>执行componentDidMount ，相当于Vue里的mounted,多用于操作真实dom</p></li></ol><h5 id="运行中阶段"><a href="#运行中阶段" class="headerlink" title="运行中阶段"></a>运行中阶段</h5><p>当组件mount到页面中之后，就进入了运行中阶段，在这里有5个钩子函数，但是这5个函数只有在数据（属性、状态）发送改变的时候才会执行</p><ol><li>componentWillReceiveProps</li></ol><p>当父组件给子组件传入的属性改变的时候，子组件的这个函数才会执行</p><p>当执行的时候，函数接收的参数是子组件接收到的新参数，这个时候，新参数还没有同步到this.props上,多用于判断新属性和原有属性的变化后更改组件的状态</p><ol><li><p>接下来就会执行shouldComponentUpdate,这个函数的作用：</p><p>当属性或状态发生改变后控制组件是否要更新，提高性能,返回true就更新，否则不更新，默认返回true</p><p>接收nextProp、nextState，根据根据新属性状态和原属性状态作出对比、判断后控制是否更新</p></li><li><p>componentWillUpdate,在这里，组件马上就要重新render了，多做一些准备工作，千万千万，不要在这里修改状态，否则会死循环<br>相当于Vue中的beforeUpdate</p></li><li><p>render，重新渲染dom</p></li><li><p>componentDidUpdate，在这里，新的dom结构已经诞生了,相当于Vue里的updated</p></li></ol><h5 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h5><p>当组件被销毁之前的一刹那，会触发componentWillUnmount，临死前的挣扎</p><p>相当于Vue里的beforeDestroy，所以说一般会做一些擦屁股的事情</p><p>为什么Vue中有destroyed，而react却没有componentDidUnmount</p><p>Vue在调用$destroy方法的时候就会执行beforeDestroy，然后组件被销毁，这个时候组件的dom结构还存在于页面结构中，也就说如果想要对残留的dom结构进行处理必须在destroyed处理，但是react执行完componentWillUnmount之后把事件、数据、dom都全部处理掉了，所以根本不需要其他的钩子函数了</p><p>怎么样就算组件被销毁：</p><ol><li>当父组件从渲染这个子组件变成不渲染这个子组件的时候，子组件相当于被销毁</li><li>调用ReactDOM.unmountComponentAtNode(node) 方法来将某节点中的组件销毁</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React框架学习&quot;&gt;&lt;a href=&quot;#React框架学习&quot; class=&quot;headerlink&quot; title=&quot;React框架学习&quot;&gt;&lt;/a&gt;React框架学习&lt;/h1&gt;&lt;h3 id=&quot;React的起源和发展&quot;&gt;&lt;a href=&quot;#React的起源和发展&quot; c
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react学习3</title>
    <link href="https://tianjiec.top/2019/01/12/react%E5%AD%A6%E4%B9%A03/"/>
    <id>https://tianjiec.top/2019/01/12/react学习3/</id>
    <published>2019-01-12T09:36:43.000Z</published>
    <updated>2019-01-12T09:36:59.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React框架学习"><a href="#React框架学习" class="headerlink" title="React框架学习"></a>React框架学习</h1><h2 id="开发依赖devDependencies与运行依赖dependencies"><a href="#开发依赖devDependencies与运行依赖dependencies" class="headerlink" title="开发依赖devDependencies与运行依赖dependencies"></a>开发依赖devDependencies与运行依赖dependencies</h2><p>npm自己的文档说dependencies是运行时依赖，devDependencies是开发时的依赖。即devDependencies 下列出的模块，是我们开发时用的，比如 我们安装 js的压缩包gulp-uglify 时，我们采用的是 “npm install –save-dev gulp-uglify ”命令安装，因为我们在发布后用不到它，而只是在我们开发才用到它。<br>dependencies 下的模块，则是我们发布后还需要依赖的模块，譬如像jQuery库或者Angular框架类似的，我们在开发完后后肯定还要依赖它们，否则就运行不了。</p><h3 id="webpack-facebook"><a href="#webpack-facebook" class="headerlink" title="webpack (facebook)"></a>webpack (facebook)</h3><p>前端工程化： npm、cnpm、yarn、bower | grunt 、 gulp 、webpack</p><p>gulp： 基于流的前端自动化构建工具，基于流的任务式的工具</p><p>webpack： 是一款模块化打包工具，webpack是基于配置的，通过配置一些选项来让webpack执行打包任务。</p><p>npm i webpack -g</p><p>npm i webpack-cli -g (4.0+)</p><p>npm i yarn -g    </p><p>webpack在打包的时候，依靠依赖关系图，在打包的时候需要告知webpack两个概念：入口和出口</p><p>一般情况下，我们需要使用webpack.config.js进行配置</p><h5 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h5><p>entry配置项目打包的入口，值可以为单个的字符串执行某一个文件的地址，这个时候该文件就是入口文件，webpack会根据入口文件里各模块间的关系形成依赖关系图，然后根据依赖关系图进行打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry:&apos;./src/app.js&apos;,</span><br><span class="line">output:&#123;</span><br><span class="line">    path:path.join(__dirname,&apos;build&apos;),</span><br><span class="line">    filename:&apos;app.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有的时候我们需要的是多入口，我们就写成数组的形式，数组里的每一个字符串地址指向的都是一个独立的入口，webpack会将这些入口的依赖打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry:[&apos;./src/app.js&apos;,&apos;./src/vendor.js&apos;],</span><br><span class="line">output:&#123;</span><br><span class="line">    path:path.join(__dirname,&apos;build&apos;),</span><br><span class="line">    filename:&apos;[name].js&apos;//不确定名字的时候，这里会打包成main.js</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚才的两种entry配置都只会打包出一个js文件，但是在某一个应用中我们可能需要将js根据依赖关系打包成多个js文件，并且在多页面应用中，我们也确实不可能只使用一个js文件，那么我们就可以使用如下的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">entry:&#123;</span><br><span class="line">    app:&apos;./src/app.js&apos;,</span><br><span class="line">    vendor:&apos;./src/vendor.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line">output:&#123;</span><br><span class="line">    path:path.join(__dirname,&apos;build&apos;),</span><br><span class="line">    filename:&apos;[name]_[hash].js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，因为filename里写成名字是[name],所以会根据entry的配置的键名来为打包出的js文件命名，hash是每次打包的一个随机的hash值，可以用来做版本控制</p><h5 id="output"><a href="#output" class="headerlink" title="output"></a>output</h5><p>在这里我们配置打包输出的一些选项</p><p>filename可以确定打包出来的文件的名字，在里面我们可以使用[name],[hash]这样的占位符</p><p>path配置打包出去的文件的路径，需要是绝对路径</p><h5 id="env"><a href="#env" class="headerlink" title="env"></a>env</h5><p>在命令行或者终端中执行 webpack –env hello命令，就相当于在打包的时候传入一个参数为hello</p><p>在webpack.config.js中可以暴露出一个函数，这个函数就可以接收到env参数，当然函数就可以根据env参数来有选择的返回某一个或多个配置对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = (env)=&gt;&#123;</span><br><span class="line">    if(env==&apos;production&apos;)&#123;</span><br><span class="line">        return productionConfig</span><br><span class="line">    &#125;</span><br><span class="line">    return developmentConfig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>–watch 可以让webpack去监听文件的改变。<br>可以在package.json里的scripts中配置一些快捷操作，通过npm run来运行</p><h5 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h5><p>在webpack编译用的是loader，但是有一些loader无法完成的任务，交由插件（plugin）来完成，插件的时候需要在配置项中配置plugins选项，值是数组，可以放入多个插件的使用，而一般的插件都是一个构造器，我们只需在plugins数组中放入该插件的实例即可</p><p>html-webpack-plugin</p><p>这个插件可以选择是否依据模板来生成一个打包好的html文件，在里面可以配置、title、template、filename、minify等选项，详情请查阅<a href="https://segmentfault.com/a/1190000007294861" target="_blank" rel="noopener">文档</a></p><p>plugins:[<br>​    new HtmlWebpackPlugin({<br>​        template:”./src/index.html”,<br>​        minify:{<br>​            collapseWhitespace:true<br>​        }<br>​    })<br>]</p><h4 id="LOADERS"><a href="#LOADERS" class="headerlink" title="LOADERS"></a>LOADERS</h4><p>在webpack中专门有一些东西用来编译文件、处理文件，这些东西就叫loader，loader的使用就是在配置项中，设置module，在module中设置rules值为数组，在数组里放入多个匹配规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;test:/\.css$/,use:&apos;css-loader&apos;&#125;</span><br><span class="line">    ],</span><br><span class="line">    //before</span><br><span class="line">    loaders:[</span><br><span class="line">        &#123;test:/\.css$/,loader:&apos;css-loader&apos;&#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test为此次匹配要匹配的文件正则规则，use代表要使用的loader</p><p>使用url-loader可以将css中引入的图片（背景图）、js中生成的img图片处理一下，生成到打包目录里</p><p>视图html-withimg-loader可以将html中img标签引入的img图片打包到打包目录</p><p>file-loader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:/\.(png|jpe?g|svg|gif)$/,</span><br><span class="line">    // use:&apos;url-loader?limit=1000&amp;name=images/[hash:8].[name].[ext]&apos;</span><br><span class="line">    use:[</span><br><span class="line">        &#123;</span><br><span class="line">            loader:&apos;url-loader&apos;,</span><br><span class="line">            options:&#123;</span><br><span class="line">                limit:1000,</span><br><span class="line">                name:&apos;/static/images/assets/[hash:8].[name].[ext]&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test:/\.html$/,</span><br><span class="line">    use:&apos;html-withimg-loader&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理css:</p><p>cnpm i css-loader style-loader –save-dev</p><p>配置：</p><p>{<br>​    test:/.css$/,<br>​    use:[‘style-loader’,’css-loader’]<br>}</p><p>注意。webpack中loader的使用是从后往前的</p><p>css-loader可以将引入到js中的css代码给抽离出来，style-loader可以将抽离出来的css代码放入到style标签中</p><p>处理sass</p><p>{<br>test:/.scss$/,<br>use:[‘style-loader’,’css-loader’,’sass-loader’]<br>},</p><h2 id="postcss-loader-兼容前缀"><a href="#postcss-loader-兼容前缀" class="headerlink" title="postcss-loader 兼容前缀"></a>postcss-loader 兼容前缀</h2><p>//<a href="https://www.cnblogs.com/RoadAspenBK/p/9342850.html" target="_blank" rel="noopener">https://www.cnblogs.com/RoadAspenBK/p/9342850.html</a><br>yarn add postcss-loader  autoprefixer</p><p>//根目录创建postcss.config.js<br>module.exports = {<br>​    plugins:[<br>​        require(“autoprefixer”)<br>​    ]<br>}</p><p>//loader配置<br>use: [‘style-loader’,’css-loader’,{<br>​        loader: ‘postcss-loader’,<br>​        options: {<br>​            config: {<br>​                path: ‘postcss.config.js’  // 这个得在项目根目录创建此文件<br>​            }<br>​        }<br>​        },’sass-loader’]</p><p>//package.json上面添加<br>“browserslist”: [<br>​    “defaults”,<br>​    “not ie &lt; 11”,<br>​    “last 2 versions”,<br>​    “&gt; 1%”,<br>​    “iOS 7”,<br>​    “last 3 iOS versions”<br>  ]</p><p>将引入项目的css文件、scss文件抽成一个文件，引入到页面中</p><p>因为ExtractTextWebpackPlugin对webpack4支持的不是很好，所以我们这样解决：</p><p>cnpm i extract-text-webpack-plugin@next -D<br>yarn add extract-text-webpack-plugin@next -D</p><p>@next下载的就是最新的版本，可能是开发版本   3.x的版本过时了<br>“extract-text-webpack-plugin”: “^4.0.0-beta.0”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const ExtractTextWebpackPlugin = require(&apos;extract-text-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">///plugin</span><br><span class="line">new ExtractTextWebpackPlugin(&quot;style.css&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">///loader</span><br><span class="line">&#123;</span><br><span class="line">test:/\.css$/,</span><br><span class="line">use:ExtractTextWebpackPlugin.extract(&#123;</span><br><span class="line">      fallback: &quot;style-loader&quot;,</span><br><span class="line">      use: &quot;css-loader&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">test:/\.scss/,</span><br><span class="line">use:ExtractTextWebpackPlugin.extract(&#123;</span><br><span class="line">      fallback: &quot;style-loader&quot;,</span><br><span class="line">      use: [&quot;css-loader&quot;,&quot;sass-loader&quot;]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const OptimizeCssAssetsPlugin = require(‘optimize-css-assets-webpack-plugin’);//压缩css插件</p><p>//plugins配置<br>new OptimizeCssAssetsPlugin()</p><p>css兼容优化处理：post-css 、autoprefixer</p><p>处理es6：</p><p>需要的依赖：</p><p>“babel”: “^6.23.0”,<br>“babel-core”: “^6.24.1”,<br>“babel-loader”: “^7.0.0”,<br>“babel-preset-es2015”: “^6.24.1”,<br>“babel-preset-react”: “^6.24.1”,</p><p>rules：<br>{<br>​    test:/.js$/,<br>​    exclude: /node_modules/,<br>​    loader:’babel-loader’,<br>​    query: {<br>​        presets: [‘es2015’,’react’]<br>​     }<br>}</p><h5 id="ES6中的react"><a href="#ES6中的react" class="headerlink" title="ES6中的react"></a>ES6中的react</h5><p>1.创建组件：</p><p>使用class来创建组件</p><p>class App extends React.Component {</p><p>}</p><p>2.默认状态的设置</p><p>在es6中不再使用getInitialState来设置默认状态，而是在constructor里面直接给this.state上挂载状态</p><p>class App extends Component {<br>​    constructor(props){<br>​        super(props)<br>​<br>​        this.state={<br>​            doing:’吃饭’<br>​        }<br>​    }<br>}</p><ol><li>默认属性的设置</li></ol><p>在es6中，通过给类设置defaultProps属性来设置默认属性</p><p>App.defaultProps = {<br>​    name:’App根组件’<br>}</p><ol><li>做属性传参验证</li></ol><p>import PropTypes from ‘prop-types’;</p><p>App.propTypes = {<br>​    name:PropTypes.string<br>}</p><p>5.钩子函数有变化</p><p>getDefaultProps、getInitialState没有了</p><p>多出了constructor,而这个函数本身是类的构造器，在这里相当于getDefaultProps、getInitialState的结合</p><h5 id="create-react-app-脚手架"><a href="#create-react-app-脚手架" class="headerlink" title="create-react-app 脚手架"></a>create-react-app 脚手架</h5><p>npm install creat-react-app -g</p><p>create-react-app my-app //生成一个react开发模板在my-app目录<br>//生成的过程特别缓慢，可以使用yarn工具来下载，也就是说先去下载安装yarn   ：npm install yarn -g</p><p>当我们要进行二次配置的时候，需要找到node_modules文件夹里的react-scripts进行配置，但是当我们执行npm run eject就可以将配置文件抽出，方便开发配置</p><h5 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h5><p>当我们使用某些组件的时候，发现，该组件不需要拥有自己的状态，只需要接收到外界传入的属性之后做出相应的反应即可</p><p>这样的话，我们可以利用纯函数的方式将其制作成无状态组件，提高性能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">const Button = (props)=&gt;&#123;</span><br><span class="line">return &lt;button onClick=&#123;props.handler&#125;&gt;我要花钱&lt;/button&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Button</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React框架学习&quot;&gt;&lt;a href=&quot;#React框架学习&quot; class=&quot;headerlink&quot; title=&quot;React框架学习&quot;&gt;&lt;/a&gt;React框架学习&lt;/h1&gt;&lt;h2 id=&quot;开发依赖devDependencies与运行依赖dependencies&quot;
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react+redux整合</title>
    <link href="https://tianjiec.top/2019/01/12/react-redux%E6%95%B4%E5%90%88/"/>
    <id>https://tianjiec.top/2019/01/12/react-redux整合/</id>
    <published>2019-01-12T09:35:21.000Z</published>
    <updated>2019-01-12T09:35:59.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React里面"><a href="#React里面" class="headerlink" title="React里面"></a>React里面</h2><p>index.js是入口 ，App.js是源组件，其他组件放在它里面。</p><p>然后App.js放在public index.html里面的div.root里面。</p><h2 id="reducer拆分"><a href="#reducer拆分" class="headerlink" title="reducer拆分"></a>reducer拆分</h2><p>store里面</p><p>index.js不变，唯一数据源</p><p>把和todo数据相关的 放入 todolist文件夹。</p><p>在store文件夹写一个 总的reducer</p><p>import todolist from “todulist/reducer”</p><p>const reducer = combineReducers({</p><p>todolist</p><p>})</p><p>然后组件要回去它的数据的话要通过 store.getState().todolist.todos拿到todos的数据</p><p>calculator文件夹里面</p><p>state.js存放数据</p><p>export default{</p><p>}</p><p>reducer.js</p><p>import state from “./state”</p><p>const reducer = (prevState = state, action=&gt;{</p><p>let new_state = {…prevState};</p><p>return new_state;</p><p>}</p><p>onchange绑定方法：  为性能考虑 在input change的时候 在</p><p>constructor里面通过bind将触发方法和 处理方法绑定起来，这样就值绑定一次</p><p>this.触发方法= this.处理方法.bind(this,”具体哪个类型”)</p><p>input 里面defaultvalue在数据变化的时候不会重新渲染</p><p>input只是渲染默认值的话，我们就是使用defaultvalue</p><p>如果input的值不仅仅是渲染初始值，而且你的状态变化的时候，也要去更改value的时候就不能使用defaultValue了 ，必须使用value</p><h1 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h1><p>核心组件</p><p>Prodiver 提供者 属性上的  将自身store属性传给需要使用的容器组件</p><p>容器组件可以监控状态改变，一旦有新的状态，就会给ui组件传递给 </p><p>包在 最外层 即 App组件的外层 规定必须传一个store属性</p><p>store={store}</p><p>获取数据</p><p>通过connect上下文环境 写容器组件</p><p>//当状态发生改变，容器组件就会监听到数据变化，把最新的数据返回给ui组件 UI组件通过props接收最新数据</p><p>显示数据的一个组件 容器组件 ui组件 木偶组件</p><p>这个方法返回什么 ui组件 props上面就是什么</p><p>const mapStateToProps = state =&gt;{//通过这个方法 //props上面挂了属性</p><p>return state</p><p>}</p><p>这样这个组件里面就可以通过 this.props.值 就可以获取值</p><p>export default connect（mapStateToProps）(TodoInfo);//通过上下文生成容器组件</p><p>hoc高阶组件  容器组件</p><p>状态以改变  容器组件就会监听转台改变=》通过属性的方式给ui组件传递新的数据。</p><p>export default connect（mapStateToProps，mapDispatchToProps）(TodoInfo);</p><p>mapDispatchToProps:将派发的一些action 进行挂载，ui组件props上面就会哟什么方法。</p><p>const mapDispatchToProps = dispatch=&gt;{</p><p>return {</p><p>addNewTodo(title){</p><p>let action = actionCreator.addNewTodo(title)</p><p>dispatch(action)//在这里将actionCreator的action方法拿过来用 并且react-redex把dispatch拿了过来，所以可以在这里派发给reducer</p><p>}</p><p>}</p><p>}</p><p>const mapDispatchToProps = dispatch=&gt;{</p><p>}</p><p>import {connect} from “react-redex”</p><p>import {bindActionCreator} from “redux”</p><p>//将state里面的数据绑定到ui组建的props上，将actioncreator方法绑定到props上</p><p>export default connect（state=&gt;state，dispatch=&gt;{</p><p>return bindActionCreators(actionCreators,dispatch)</p><p>}）(TodoInfo);</p><p>异步操作在action里面去做需要 安装redux 中间件 （因为在redux架构里面）</p><p>redux-thunk redux-saga redux-promise</p><p>cnpm install redux-thunk -S</p><p>在store/index.js 里面配置</p><p>import thunk from “redux-thunk”</p><p>import (applayMiddleware) from “redux”</p><p>action 方法里面</p><p>compute(){</p><p>return dispatch =&gt;{</p><p>seTimeout(()=&gt;{</p><p>let action= {</p><p>type: COMPUTE,</p><p>}</p><p>dispatch(action)</p><p>})</p><p>}</p><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React里面&quot;&gt;&lt;a href=&quot;#React里面&quot; class=&quot;headerlink&quot; title=&quot;React里面&quot;&gt;&lt;/a&gt;React里面&lt;/h2&gt;&lt;p&gt;index.js是入口 ，App.js是源组件，其他组件放在它里面。&lt;/p&gt;
&lt;p&gt;然后App.js
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react-redux</title>
    <link href="https://tianjiec.top/2019/01/11/react-redux/"/>
    <id>https://tianjiec.top/2019/01/11/react-redux/</id>
    <published>2019-01-11T07:02:49.000Z</published>
    <updated>2019-01-12T09:33:59.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h1><p>react-redux 辅助工具  react-redux</p><p>cnpm install react-redux -S</p><p>核心组件<br>​    Prodiver  提供者  属性上通过store将数据派给容器组件<br>​    connect() 返回一个函数，函数参数接受UI组件，返回容器组件<br>​    connect()(ui组件/木偶组件)  ===&gt; 容器组件（智能组件）</p><p>核心 API<br>​    //容器组件内部帮你做了 store.subscribe()<br>​    //状态变化 ==&gt; 容器组件监听状态改变了 ==&gt; 通过属性的方式给ui组件传递<br>​    const mapStateToProps = state=&gt;{<br>​        return state.todolist<br>​    }<br>​    connect(mapStateToProps)(ui组件)</p><p>做异步操作在action里面去实现！需要安装 redux中间件<br>redux-thunk  redux-saga redux-promise</p><p>cnpm install redux-thunk -S</p><p>在store/index.js里面配置<br>import {createStore,applyMiddleware} from “redux”<br>import reducer from “./reducer”<br>import thunk from “redux-thunk”<br>const store = createStore(reducer, applyMiddleware(thunk));<br>export default store;</p><p>//actionCeators.js<br>compute(){<br>​    return dispatch=&gt;{<br>​        setTimeout(() =&gt; {<br>​            let action = {<br>​                type: COMPUTE,<br>​            }<br>​            dispatch(action)<br>​        }, 1000);<br>​    }<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;react-redux&quot;&gt;&lt;a href=&quot;#react-redux&quot; class=&quot;headerlink&quot; title=&quot;react-redux&quot;&gt;&lt;/a&gt;react-redux&lt;/h1&gt;&lt;p&gt;react-redux 辅助工具  react-redux&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="redex" scheme="https://tianjiec.top/tags/redex/"/>
    
  </entry>
  
  <entry>
    <title>redux</title>
    <link href="https://tianjiec.top/2019/01/10/redux/"/>
    <id>https://tianjiec.top/2019/01/10/redux/</id>
    <published>2019-01-10T13:05:44.000Z</published>
    <updated>2019-01-11T06:59:48.563Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>redux有四个组成部分：</p><p>store用来存储数据<br>reducer：真正的来管理数据<br>actionCreator：创建action，交由reducer处理<br>view： 用来使用数据，在这里，一般用react组件来充当</p><h5 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h5><p>（1）web应用是一个状态机，视图与状态是一一对应的。</p><p>（2）所有的状态，保存在一个对象里面 单一数据源：store是唯一的</p><h3 id="使用的方法"><a href="#使用的方法" class="headerlink" title="使用的方法"></a>使用的方法</h3><ol><li><p>创建store</p><p>从redux工具中取出createStore去生成一个store</p></li><li><p>创建一个reducer，然后将其传入到createStore中辅助store的创建</p><p>reducer是一个纯函数，接收当前状态和action，返回一个状态，返回什么，store的状态就是什么，需要注意的是，不能直接操作当前状态，而是需要返回一个新的状态</p><p>想要给store创建默认状态其实就是给reducer一个参数创建默认值</p></li><li><p>组件通过调用store.getState方法来使用store中的数据</p></li><li><p>组件产生用户操作，调用actionCreator的方法创建一个action，利用store.dispatch方法传递给reducer</p></li><li><p>reducer对action上的标示性信息做出判断后对新状态进行处理，然后返回新状态，这个时候store的数据就会发生改变</p><p>ps:reducer是个纯函数，也就是 他不能改变原来的state，所以state里面的引用数据要深拷贝。比如 arr=date.slice()</p></li><li><p>我们可以在组件中，利用store.subscribe方法去订阅数据的变化，也就是可以传入一个函数，当数据变化的时候，传入的函数会执行，在这个函数中让组件去获取最新的状态</p></li></ol><h4 id="具体使用："><a href="#具体使用：" class="headerlink" title="具体使用："></a>具体使用：</h4><p>react js组件里面调用组件中的方法=》派发action actionCreator 通过actionCreator.方法名 // 在store/actionCreator中的方法 =》 render匹配 处理数据 在state里面获取旧数据 处理数据 返回新数据</p><h5 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h5><p>组件只有属性没有状态，其实就是一个函数，接收外部传入属性做出相应的渲染</p><h4 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h4><h5 id="在数据-初始获取地方-加入本地存储"><a href="#在数据-初始获取地方-加入本地存储" class="headerlink" title="在数据 初始获取地方 加入本地存储"></a>在数据 初始获取地方 加入本地存储</h5><p>const state = {</p><p>todos:localStorage.todos?JSON.parse(localStorage.todos):[]</p><p>}</p><p>export default state;</p><h5 id="在修改数据地方-存入本地存储"><a href="#在修改数据地方-存入本地存储" class="headerlink" title="在修改数据地方 存入本地存储"></a>在修改数据地方 存入本地存储</h5><p>localStorage.todos = JSON.stringify(new_state.todos)</p><p>reducer-&gt; strore - &gt; react显示</p><h5 id=""><a href="#" class="headerlink" title=" "></a> </h5><h4 id="用常量定义方法名-便于维护"><a href="#用常量定义方法名-便于维护" class="headerlink" title="用常量定义方法名 便于维护"></a>用常量定义方法名 便于维护</h4><p>const.js</p><p>const ADD_NEW_TODO =ADD_NEW_TODO;</p><p>export {ADD_NEW_TODO}</p><p>react显示</p><p>在</p><p>conponentWillMount里面设置state为store获取过来的数据</p><p>store.subscribe(()=&gt;{//通过这个方法订阅一下 视图层 得到数据重新渲染</p><p>​    this.setState( {</p><p>​        todo: store.getState().todos</p><p>​    });</p><p>});</p><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>store里面</p><p>state存放数据    react组件里面可以直接通过 store.getState() 获取数据</p><p>reducer处理数据  通过引入state 获取旧数据 然后 返回新数据</p><p>actionCreators 派发处理数据任务 里面有各类方法 ，通过action.type 派发给reducer 去根据不同action处理数据</p><p>index.js 用来通过reducer初始rudux</p><p>用户修改数据：组件里面 调用actionCreator里面的方法 =》 通过dispatch 将action派发给（store）reducer匹配action 然后处理数据 =》 reducer返回新的数据 =》用户获取新的数据</p><p>用户获取数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState( &#123;</span><br><span class="line"></span><br><span class="line">todo: store.getState().todos</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redux&quot;&gt;&lt;a href=&quot;#redux&quot; class=&quot;headerlink&quot; title=&quot;redux&quot;&gt;&lt;/a&gt;redux&lt;/h3&gt;&lt;p&gt;redux有四个组成部分：&lt;/p&gt;
&lt;p&gt;store用来存储数据&lt;br&gt;reducer：真正的来管理数据&lt;br&gt;ac
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="https://tianjiec.top/2019/01/09/webpack/"/>
    <id>https://tianjiec.top/2019/01/09/webpack/</id>
    <published>2019-01-09T08:55:22.000Z</published>
    <updated>2019-01-12T09:37:20.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React框架学习"><a href="#React框架学习" class="headerlink" title="React框架学习"></a>React框架学习</h1><h3 id="开发依赖devDependenvies与运行依赖dependencies"><a href="#开发依赖devDependenvies与运行依赖dependencies" class="headerlink" title="开发依赖devDependenvies与运行依赖dependencies"></a>开发依赖devDependenvies与运行依赖dependencies</h3><blockquote><p>npm自己的文档说dependencies是运行时依赖，devDependencies是开发时的依赖。即devDependencies 下列出的模块，是我们开发时用的，比如 我们安装 js的压缩包gulp-uglify 时，我们采用的是 “npm install –save-dev gulp-uglify ”命令安装，因为我们在发布后用不到它，而只是在我们开发才用到它。<br>dependencies 下的模块，则是我们发布后还需要依赖的模块，譬如像jQuery库或者Angular框架类似的，我们在开发完后后肯定还要依赖它们，否则就运行不了。</p></blockquote><h3 id="webpack（facebook）"><a href="#webpack（facebook）" class="headerlink" title="webpack（facebook）"></a>webpack（facebook）</h3><p>前端工程化：包管理器：npm、cnpm、yarn、bower | 构建工具：grunt、gulp、webpack</p><p>gulp： 基于流的前端自动化构建工具，基于流的任务式的工具</p><p>webpack： 是一款模块化打包工具，webpack是基于配置的，通过配置一些选项来让webpack执行打包任务。npm i webpack -g</p><p>npm i webpack-cli -g (4.0+)</p><p>npm i yarn -g    </p><p>webpack在打包的时候，依靠依赖关系图，在打包的时候需要告知webpack两个概念：入口和出口</p><p>一般情况下，我们需要使用webpack.config.js进行配置</p><h4 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h4><p>entry配置项目打包的入口，值可以为单个的字符串执行某一个文件的地址，这个时候该文件就是入口文件，webpack会根据入口文件里各个模块之间的关系形成依赖关系图，然后根据依赖关系图打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry:&apos;./src/app.js&apos;,</span><br><span class="line">output:&#123;</span><br><span class="line">    path:path.join(__dirname,&apos;build&apos;);</span><br><span class="line">    filename:&apos;app.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有的时候我么需要的是多入口，我们就需要写成数组的形式，数组里的每一个字符串地址指向的都是一个独立的入口，webpack会将这些入口依赖打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry:[&apos;./src/app.js&apos;,&apos;./src/vendor.js&apos;],</span><br><span class="line">output:&#123;</span><br><span class="line">    path:path.join(__dirname,&apos;build&apos;),</span><br><span class="line">    filename:&apos;[name]&apos;.js//不确定名字的时候，这里会打包成main.js</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，因为filename里写成名字是[name],所以会根据entry的配置的键名来为打包出的js文件命名，has是每次打包的一个随机的hash值，可以用来做版本控制</p><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><p>在这里我们配置打包输出的一些选项</p><p>filename可以确定打包出来的文件的名字，在我们里面可以使用[name],[hash]这样的占位符</p><p>path配置打包出去的文件路径，需要是绝对路径。</p><h4 id="env"><a href="#env" class="headerlink" title="env"></a>env</h4><p>在命令行或者终端中执行 wbpack –env hello命令，就相当于在打包的时候传入一个参数为 hello</p><p>在webpack.config.js中可以暴露出一个函数，这个函数就可以接收到env参数，当然函数就可以根据env参数来有选择的返回某一个或多个配置对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = (env)=&gt;&#123;</span><br><span class="line">    if(env==&apos;production&apos;)&#123;</span><br><span class="line">        return productionConfig</span><br><span class="line">    &#125;</span><br><span class="line">    return developmentConfig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>–watch 可以让webpack去监听文件的改变。<br>可以在package.json里的scripts中配置一些快捷操作，通过npm run来运行</p><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><p>在webpack编译用的是loader,但是有一些loader无法完成的任务，交由插件（plugin）来完成 插件的时候需要在配置项中配置plugins选项，值是数组，可以放入多个插件的使用，而一般的插件都是一个构造器，我们只需要在plugins数组中放入该插件的实例即可。</p><h4 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h4><p>这个插件可以选择是否依据模板来生成一个打包好的html文件，在里面可以配置、title、template、filename、minify等选项，详情请查阅<a href="https://segmentfault.com/a/1190000007294861" target="_blank" rel="noopener">文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">template:&apos;./src/index.html&apos;,</span><br><span class="line">        minify:&#123;</span><br><span class="line">            collapseWhitespace:true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="LOADERS"><a href="#LOADERS" class="headerlink" title="LOADERS"></a>LOADERS</h4><p>在webpack中专门有一些东西用来编译文件、处理文件，这些东西就叫loader，loader的使用就是在配置项中，设置module，在module中设置rules值为数组，在数组里放入多个匹配规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;test:/\.css$/,use:&apos;css-loader&apos;&#125;</span><br><span class="line">    ],</span><br><span class="line">    //before</span><br><span class="line">        loaders:[</span><br><span class="line">            &#123;test:/\.css$/,loader:&apos;css-loader&apos;&#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test为此次匹配要匹配的文件正则规则，use代表要使用的loader</p><p>使用url-loader可以将css中引入的图片（背景图）、js中生成的img图片处理一下，生成到打包目录里</p><p>视图html-withimg-loader可以将html中img标签引入的img图片打包到打包目录</p><p>file-loader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:/\.(png|jpe?g|svg|gif)$/,</span><br><span class="line">    // use:&apos;url-loader?limit=1000&amp;name=images/[hash:8].[name].[ext]&apos;</span><br><span class="line">    use:[</span><br><span class="line">        &#123;</span><br><span class="line">            loader:&apos;url-loader&apos;,</span><br><span class="line">            options:&#123;</span><br><span class="line">                limit:1000,</span><br><span class="line">                name:&apos;/static/images/assets/[hash:8].[name].[ext]&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test:/\.html$/,</span><br><span class="line">    use:&apos;html-withimg-loader&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理css:</p><p>cnpm i css-loader style-loader –save-dev</p><p>配置：</p><p>{<br>​    test:/.css$/,<br>​    use:[‘style-loader’,’css-loader’]<br>}</p><p>注意。webpack中loader的使用是从后往前的</p><p>css-loader可以将引入到js中的css代码给抽离出来，style-loader可以将抽离出来的css代码放入到style标签中</p><p>处理sass</p><p>{<br>test:/.scss$/,<br>use:[‘style-loader’,’css-loader’,’sass-loader’]<br>},</p><h2 id="postcss-loader兼容前缀"><a href="#postcss-loader兼容前缀" class="headerlink" title="postcss-loader兼容前缀"></a>postcss-loader兼容前缀</h2><p>//<a href="https://www.cnblogs.com/RoadAspenBK/p/9342850.html" target="_blank" rel="noopener">https://www.cnblogs.com/RoadAspenBK/p/9342850.html</a></p><p>yarn add postcss-loader autoprefixer</p><p>//根目录创建postcss.config.js<br>module.exports = {<br>​    plugins:[<br>​        require(“autoprefixer”)<br>​    ]<br>}</p><p>//loader配置<br>use: [‘style-loader’,’css-loader’,{<br>​        loader: ‘postcss-loader’,<br>​        options: {<br>​            config: {<br>​                path: ‘postcss.config.js’  // 这个得在项目根目录创建此文件<br>​            }<br>​        }<br>​        },’sass-loader’]</p><p>//package.json上面添加<br>“browserslist”: [<br>​    “defaults”,<br>​    “not ie &lt; 11”,<br>​    “last 2 versions”,<br>​    “&gt; 1%”,<br>​    “iOS 7”,<br>​    “last 3 iOS versions”<br>  ]</p><p>将引入项目的css文件、scss文件抽成一个文件，引入到页面中</p><p>因为ExtracTextWebPackPlugin对webpack4支持不是很好，所以我们这样解决：</p><p>cnpm i extract-text-webpack-plugin@next -D</p><p>yarn add extract-text-webpack-plugin@next -D</p><p>@next下载的就是最新的版本，可能是开发版本   3.x的版本过时了<br>“extract-text-webpack-plugin”: “^4.0.0-beta.0”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React框架学习&quot;&gt;&lt;a href=&quot;#React框架学习&quot; class=&quot;headerlink&quot; title=&quot;React框架学习&quot;&gt;&lt;/a&gt;React框架学习&lt;/h1&gt;&lt;h3 id=&quot;开发依赖devDependenvies与运行依赖dependencies&quot;
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>vuex</title>
    <link href="https://tianjiec.top/2019/01/08/vuex/"/>
    <id>https://tianjiec.top/2019/01/08/vuex/</id>
    <published>2019-01-08T09:18:59.000Z</published>
    <updated>2019-01-08T09:20:59.079Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>是vue提供的一个全局的状态管理工具，主要处理项目中多组件间状态共享</p><p>当你不知道该不该使用vuex的时候，你就不需要使用vuex</p><p>整个vuex的使用都是从创建store开始的</p><p>store中包含了这样的几个部分：</p><p>state（存储状态的）</p><p>getters （用来派生新状态）</p><p>mutations （负责更改state）</p><p>actions （负责做异步操作）</p><p>在这里以一个购物车的小例子来学习，因为没有后端，所以数据交互只能与localStorage交互了</p><p>路由组件： 列表组件、购物车组件</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li><p>创建一个store</p></li><li><p>将创建好的store注入到根实例里,目的就是在任意组件中都可以使用到$store的api，用以使用vuex</p></li><li><p>创建state交由store来管理</p></li><li><p>在组件中使用state中的数据</p><p>组件可以直接从$store.state中得到vuex管理的状态，但是，不要这么用！</p><p>如果在视图中直接使用$store.state.num，num更改后组件的视图会更改，但是我们一般使用的时候都是在data里挂载，或者说直接this.num去使用，这样的话，当num更改的时候，组件无法得到更新</p><p>所以。vuex规定，我们要利用计算属性来使用vuex中的数据</p><p>其实大部分情况下，我们都会使用mapState这个辅助函数（作用：将vuex中state管理的状态通过计算属性放入到组件中）</p></li><li><p>如果需要从现有的状态派生出一个新的状态，使用getters，例如，已经有了一个num，现在需要再来一个doubleNum</p><p>getters里的数据，在组件中，我们也需要使用计算属性来接收，在这里也可以使用mapGetters的辅助函数，注意，mapGetters的使用方法和mapState一模一样</p></li><li><p>mutations是专门更改state的，也就是说，想要改state必须通过mutations才能改<br>mutations里有很多方法，方法被调用的时候，更改state，而且，注意一定要很谨慎的使用mutations，所以，建议大家，给mutations挂载方法的时候，方法名字使用常量</p><p>在组件中通过this.$store.commit(methodname,params)</p><p>使用mapMutations辅助函数可以将mutations中的方法与组件的方法耦合起来，使用方法与mapState、mapGetters一样，只是要放入在methods</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意，要让mutations纯粹！！！！。里面只有数据的更改，没有其他的逻辑代码</span><br></pre></td></tr></table></figure><ol><li><p>当我们想要像后端发送请求，根据结果再来更改state，这个时候，注意，不能把获取数据的异步逻辑写在mutations，也不要写在组件里，不方便维护和复用，所以，需要把他们写在actions，也就是说，vuex中的actions专门负责异步操作</p><p>actions里面有很多方法，这些方法里面可以进行异步操作</p></li></ol><p>// vuex的模块处理</p><p>在vuex中，我们可以配置一些模块，在每一个模块中都去创建自己的state、mutations、actions、getters，这样的话，每一个部分，或者说每一个开发者，去管理自己的一个模块，方便于维护</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分开模块之后，注意，state中的数据在组件中使用的时候需要this.$store.statea.modulenme.num</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vuex&quot;&gt;&lt;a href=&quot;#Vuex&quot; class=&quot;headerlink&quot; title=&quot;Vuex&quot;&gt;&lt;/a&gt;Vuex&lt;/h3&gt;&lt;p&gt;是vue提供的一个全局的状态管理工具，主要处理项目中多组件间状态共享&lt;/p&gt;
&lt;p&gt;当你不知道该不该使用vuex的时候，你就
      
    
    </summary>
    
    
      <category term="vue学习" scheme="https://tianjiec.top/tags/vue%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vue学习6</title>
    <link href="https://tianjiec.top/2019/01/08/vue%E5%AD%A6%E4%B9%A06/"/>
    <id>https://tianjiec.top/2019/01/08/vue学习6/</id>
    <published>2019-01-08T09:18:41.000Z</published>
    <updated>2019-01-08T09:19:47.368Z</updated>
    
    <content type="html"><![CDATA[<h5 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h5><p>每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cn.vuejs.org/images/lifecycle.png" alt="生命周期图示" title="">                </div>                <div class="image-caption">生命周期图示</div>            </figure><ol><li>实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候，数据还没有挂载ね，只是一个空壳，无法访问到数据和真实的dom，一般不做操作</li><li>挂载数据，绑定事件等等，然后执行created函数，这个时候已经可以使用到数据，也可以更改数据,在这里同步更改数据不会触发updated函数，一般可以在这里做初始数据的获取</li><li>接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</li><li>接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情…</li><li>当组件或实例的数据更改之后，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿</li><li>当更新完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的dom</li><li>当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等</li><li>组件的数据绑定、监听…去掉后只剩下dom空壳，这个时候，执行destroyed，在这里做善后工作也可以</li></ol><p>//0-20k的小图片（图标等），可以放在src/assets文件夹中，让其转成base64<br>//base64是不需要http请求，<br>//虽然页面体积变大了，但是比请求的时间要短！ </p><p>//如果是大于20k的图片，导致页面体积太大，就没有必要转base64<br>// img src=”/static/…”</p><h5 id="vue-cli脚手架"><a href="#vue-cli脚手架" class="headerlink" title="vue-cli脚手架"></a>vue-cli脚手架</h5><p>现在使用前端工程化开发项目是主流的趋势，也就是说，我们需要使用一些工具来搭建vue的开发环境，一般情况下我们使用webpack来搭建，在这里我们直接使用vue官方提供的，基于webpack的脚手架工具：vue-cli</p><p>安装方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装 vue-cli</span><br><span class="line">cnpm install -g vue-cli</span><br><span class="line">cnpm install -g webpack</span><br><span class="line"></span><br><span class="line">cnpm install -g yarn</span><br><span class="line"></span><br><span class="line"># 创建一个基于 webpack 模板的新项目</span><br><span class="line">vue init webpack my-project</span><br><span class="line"></span><br><span class="line">n</span><br><span class="line"></span><br><span class="line"># 安装依赖，走你</span><br><span class="line">cd my-project</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>模板类型：<br>webpack 在配置的时候可以选择是否需要vue-router</p><p>注意的是，模板创建的时候会询问使用需要使用ESLINT来标准化我们的代码</p><p>在脚手架中，开发目录是src文件夹，build负责打包的，config是负责配置（内置服务器的端口、proxy代理），static是静态目录，test是测试</p><p>src中main.js是入口文件，在里面创建了一个根实例，根实例的模板就是根组件App的模板，其他的组件都在根组件里面进行嵌套实现。</p><p>每一个组件都是一个单文件组件，这种文件会被webpack利用vue-loader的工具进行编译</p><p>template部分负责写组件的模板内容，script中创建组件。style里写组件的样式</p><p>assets目录也是静态目录，在这个目标中的文件我们使用相对路径引入,而static目录中的文件使用绝对地址来引入</p><p>在style上添加scoped能使这个style里的样式只作用于当前的组件，不加scoped就是全局样式</p><p>习惯于在App.vue根组件的style里写全局样式，而每个组件的style最好都是局部的</p><p>配置sass编译环境</p><ol><li>下载对应工具：node-sass(4.0.0) sass-loader</li><li>在需要使用scss代码的组件的style标签中添加 lang=’scss’</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;组件的生命周期&quot;&gt;&lt;a href=&quot;#组件的生命周期&quot; class=&quot;headerlink&quot; title=&quot;组件的生命周期&quot;&gt;&lt;/a&gt;组件的生命周期&lt;/h5&gt;&lt;p&gt;每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
    
      <category term="vue学习" scheme="https://tianjiec.top/tags/vue%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vue学习5</title>
    <link href="https://tianjiec.top/2019/01/08/vue%E5%AD%A6%E4%B9%A05/"/>
    <id>https://tianjiec.top/2019/01/08/vue学习5/</id>
    <published>2019-01-08T09:18:36.000Z</published>
    <updated>2019-01-08T09:19:18.531Z</updated>
    
    <content type="html"><![CDATA[<h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><p>vue中可以设置filter(过滤器)来实现数据格式化，双花括号插值和 v-bind 表达式中使用</p><p>vue1.0的有默认的过滤器，但是在2.0的时候全部给去掉了</p><p>所以在vue中如果想要使用过滤器就需要自定义</p><p>自定义的方法有两种：全局定义和局部定义，全局定义的过滤器在任意的实例、组件中都可以使用，局部定义就是在实例、组件中定义，只能在这个实例或组件中使用</p><ol><li><p>全局定义</p><p>Vue.filter(name,handler)</p><p>name是过滤器的名字，handler是数据格式化处理函数，接收的第一个参数就是要处理的数据，返回什么数据，格式化的结果就是什么</p><p>在模板中通过 | (管道符) 来使用,在过滤器名字后面加（）来传参，参数会在handler函数中第二个及后面的形参来接收</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123;msg | firstUpper(3,2)&#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">Vue.filter(&apos;firstUpper&apos;,function (value,num=1,num2) &#123;</span><br><span class="line">    console.log(num2)</span><br><span class="line">    return value.substr(0,num).toUpperCase()+value.substr(num).toLowerCase()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li><p>局部定义</p><p>在实例、组件的配置项中设置 filters，键名为过滤器名，值为handler</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filters:&#123;</span><br><span class="line">    firstUpper:function (value,num=1,num2) &#123;</span><br><span class="line">    console.log(num2)</span><br><span class="line">    return value.substr(0,num).toUpperCase()+value.substr(num).toLowerCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h5><p>在Vue中可以使用v-if来控制模板里元素的显示和隐藏，值为true就显示，为false就隐藏</p><p>v-if控制的是是否渲染这个节点</p><p>当我们需要控制一组元素显示隐藏的时候，可以用template标签将其包裹，将指令设置在template上，等等vm渲染这一组元素的时候，不会渲染template</p><p>当有else分支逻辑的时候，可以给该元素加上v-else指令来控制，v-else会根据上面的那个v-if来控制，效果与v-if相反，注意，一定要紧挨着</p><p>还有v-else-if指令可以实现多分支逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;mode&quot;&gt;  </span><br><span class="line">  &lt;template  v-if=&quot;mode==&apos;A&apos;&quot;&gt;</span><br><span class="line">    &lt;h1&gt;1.title&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;我的第一个P标签&lt;/p&gt;  </span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"> &lt;template  v-else-if=&quot;mode==&apos;B&apos;&quot;&gt;</span><br><span class="line">    &lt;h1&gt;2.title&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;我的第二个P标签&lt;/p&gt;</span><br><span class="line"> &lt;/template&gt;</span><br><span class="line"> &lt;template  v-else-if=&quot;mode==&apos;C&apos;&quot;&gt;</span><br><span class="line">    &lt;h1&gt;3.title&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;我的第三个P标签&lt;/p&gt;</span><br><span class="line"> &lt;/template&gt;</span><br><span class="line"> &lt;template  v-else&gt;</span><br><span class="line">   </span><br><span class="line">    &lt;p&gt;不好意思，输入有误&lt;/p&gt;</span><br><span class="line"> &lt;/template&gt;</span><br></pre></td></tr></table></figure><p>需要注意的另一个地方是：Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这样确实能使Vue变得更快，性能更高，但是有的时候我们需要让实例去更新dom而不是复用，就需要给dom加上不同的key属性，因为vue在判断到底渲染什么的时候，包括哪些dom可以复用，都会参考key值，如果dom表现基本一致，符合复用的条件，但是key值不同，依然不会复用</p><p>Vue还提供了v-show指令，用法和v-if基本一样，控制的是元素的css中display属性，从而控制元素的显示和隐藏 ， 不能和v-else配合使用,且不能使用在template标签上，因为template不会渲染，再更改它的css属性也不会渲染，不会生效</p><h6 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h6><p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。<br>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p><h5 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h5><p>频繁且复杂的dom操作通常是前端性能瓶颈的产生点，Vue提供了虚拟dom的解决办法</p><p>虚拟的DOM的核心思想是：对复杂的文档DOM结构，提供一种方便的工具，进行最小化地DOM操作。这句话，也许过于抽象，却基本概况了虚拟DOM的设计思想</p><p>(1) 提供一种方便的工具，使得开发效率得到保证<br>(2) 保证最小化的DOM操作，使得执行效率得到保证</p><p>也就是说，虚拟dom的框架/工具都是这么做的：</p><ol><li>根据现有的虚拟dom来渲染真实dom树结构</li><li>当数据变化，或者说是页面需要重新渲染的时候，会重新生成一个新的完整的虚拟dom</li><li>拿新的虚拟dom来和旧的虚拟dom做对比（使用diff算法），。得到需要更新的地方之后，更新内容</li></ol><p>这样的话，就能大量减少真实dom的操作,提高性能</p><h5 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h5><p>模块化就是将系统功能分离成独立的功能部分的方法，一般指的是单个的某一种东西，例如js、css</p><p>而组件化针对的是页面中的整个完整的功能模块划分，组件是一个html、css、js、image等外链资源，这些部分组成的一个聚合体</p><p>优点：代码复用，便于维护</p><p>划分组件的原则：复用率高的，独立性强的</p><p>组件应该拥有的特性：可组合，可重用，可测试，可维护</p><h5 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h5><p> <hello></hello>   Vue.component(“hello”,{template:””})</p><p>在vue中，我们通过Vue.extend来创建Vue的子类，这个东西其实就是组件</p><p>也就是说Vue实例和组件的实例有差别但是差别不带，因为毕竟一个是父类一个是子类</p><p>一般的应用，会拥有一个根实例，在根实例里面都是一个一个的组件</p><p>因为组件是要嵌入到实例或者父组件里的，也就是说，组件可以互相嵌套，而且，所有的组件最外层必须有一个根实例，所以组件分为：全局组件和局部组件</p><p>全局组件在任意的实例、父级组件中都能使用，局部组件只能在创建自己的父级组件或者实例中使用</p><p>组件通过不同的注册方法成为全局、局部组件</p><p>创建组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.extend(options)</span><br></pre></td></tr></table></figure><p>全局注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var App = Vue.extend(&#123;</span><br><span class="line">    template:&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(&apos;my-app&apos;,App)</span><br></pre></td></tr></table></figure><p>简便写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建组件构造器和注册组件合并一起  </span><br><span class="line"> Vue.component(&apos;hello&apos;,&#123;//Vue会自动的将此对象给Vue.extend</span><br><span class="line">     template:&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>组件通过template来确定自己的模板,template里的模板必须有根节点，标签必须闭合</p><p>组件的属性挂载通过：data方法来返回一个对象作为组件的属性，这样做的目的是为了每一个组件实例都拥有独立的data属性</p><p>局部注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el:&quot;#app&quot;,</span><br><span class="line">    filters:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        &apos;my-app&apos;:App</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简便写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">    &apos;hello&apos;:&#123;</span><br><span class="line">        template:&quot;&lt;h1&gt;asdasdasdasdasdas&lt;/h1&gt;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实例或者组件中注册另一个组件，这个时候，被注册的组件只能在注册它的实例或组件的模板中使用，一个组件可以被多个组件或实例注册</p><h6 id="注意浏览器规则"><a href="#注意浏览器规则" class="headerlink" title="注意浏览器规则"></a>注意浏览器规则</h6><p>因为vue在解析模板的时候会根据某些html的规则，例如，在table里只能放tr,td,th..，如果放入组件不会解析 这个时候我们可以放入tr使用is方式来标识这个tr其实是组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;tr is=&quot;hello&quot;&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h6 id="template"><a href="#template" class="headerlink" title="template"></a>template</h6><p>我们可以在html的某个地方通过template标签来定义组件的模板，在组件的template属性中通过选择器指定对应的template标签内容就可以了,注意，需要给template标签加id来指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=&quot;my-hello&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;hello world&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;hahahah&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">//组件中</span><br><span class="line">Vue.component(&quot;hello&quot;,&#123;</span><br><span class="line">    template:&quot;#my-hello&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">###### is切换</span><br><span class="line"></span><br><span class="line">在实例、组件的模板中的某一个标签上，可以通过is属性来指定为另一个目标的组件，这个时候我们一般会使用component标签来占位、设置is属性来指定目标组件</span><br></pre></td></tr></table></figure><p><button @click="type=type==='aaa'?'bbb':'aaa"></button></p><component :is="type"></component><p>//组件中</p><p>data:{<br>​    type:’aaa’<br>},<br>components:{<br>​    ‘aaa’:{template:”</p><h1>AAAAAAAAAAAAA</h1>“},<br>​    ‘bbb’:{template:”<h1>BBBBBBBBBBBBB</h1>“}<br>}<p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###### 组件嵌套</span><br><span class="line"></span><br><span class="line">应用中划分的组件可能会很多，为了更好的实现代码复用，所以必然会存在组件的嵌套关系</span><br><span class="line"></span><br><span class="line">组件设计初衷就是要配合使用的，最常见的就是形成父子组件的关系：组件 A 在它的模板中使用了组件 B。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### prop 传递数据</span><br><span class="line"></span><br><span class="line">组件实例的作用域是孤立的,父组件不能直接使用子组件的数据，子组件也不能直接使用父组件的数据</span><br><span class="line"></span><br><span class="line">父组件在模板中使用子组件的时候可以给子组件传递数据</span><br></pre></td></tr></table></figure>  <bbb money="2"></bbb><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子组件需要通过props属性来接收后才能使用</span><br></pre></td></tr></table></figure><p>‘bbb’:{<br>​    props:[‘money’]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果父组件传递属性给子组件的时候键名有&apos;-&apos;，子组件接收的时候写成小驼峰的模式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bbb clothes-logo=&apos;amani&apos; clothes-price=&quot;16.58&quot;&gt;&lt;/bbb&gt;</span><br><span class="line">////</span><br><span class="line">props:[&apos;clothesLogo&apos;,&apos;clothesPrice&apos;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">我们可以用 v-bind 来动态地将 prop 绑定到父组件的数据。每当父组件的数据变化时，该变化也会传导给子组件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### 单向数据流</span><br><span class="line"></span><br><span class="line">Prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。</span><br><span class="line"></span><br><span class="line">另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### prop验证</span><br><span class="line"></span><br><span class="line">我们可以为组件的 prop 指定验证规则。如果传入的数据不符合要求，Vue 会发出警告。这对于开发给他人使用的组件非常有用</span><br><span class="line"></span><br><span class="line">验证主要分为：类型验证、必传验证、默认值设置、自定义验证</span><br></pre></td></tr></table></figure><p>props:{<br>​    //类型验证:<br>​    str:String,<br>​    strs:[String,Number],<br>​    //必传验证<br>​    num:{<br>​        type:Number,<br>​        required:true<br>​    },<br>​    //默认数据<br>​    bool:{<br>​        type:Boolean,<br>​        // default:true,<br>​        default:function(){</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">//自定义验证函数</span><br><span class="line">nums:&#123;</span><br><span class="line">    type:Number,</span><br><span class="line">    validator: function (value) &#123;</span><br><span class="line">        return value %2 == 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当父组件传递数据给子组件的时候，子组件不接收，这个数据就会挂载在子组件的模板的根节点上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### slot</span><br><span class="line"></span><br><span class="line">vue里提供了一种将父组件的内容和子组件的模板整合的方法：内容分发，通过slot插槽来实现</span><br><span class="line"></span><br><span class="line">1. 匿名插槽</span><br></pre></td></tr></table></figure><aaa>abc</aaa><p>template:”</p><h1><slot></slot></h1>“<p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在父组件中使用子组件的时候，在子组件标签内部写的内容，在子组件的模板中可以通过&lt;slot&gt;&lt;/slot&gt;来使用</span><br><span class="line"></span><br><span class="line">2. 具名插槽</span><br><span class="line"></span><br><span class="line">父组件在子组件标签内写的多个内容我们可以给其设置slot属性来命名，在子组件的模板通过通过使用带有name属性的slot标签来放置对应的slot，当slot不存在的时候，slot标签内写的内容就出现</span><br></pre></td></tr></table></figure><p><my-button>提交</my-button></p><p><my-button>重置</my-button></p><p><my-button></my-button></p><p>template:”<button><slot>按钮</slot></button>“</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">##### transition</span><br><span class="line"></span><br><span class="line">Vue提供了transition组件来帮助我们实现过渡效果，依据就是在控制元素显示隐藏的时候为dom在指定的时刻添加上对应的类名</span><br><span class="line"></span><br><span class="line">而我们只要在这些类名里写上对应的css样式</span><br><span class="line"></span><br><span class="line">在进入/离开的过渡中，会有 6 个 class 切换(v代表的是transition的name属性的值)。</span><br><span class="line"></span><br><span class="line">v-enter：定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。</span><br><span class="line"></span><br><span class="line">v-enter-active：定义过渡的状态。在元素整个过渡过程中作用，在元素被插入时生效，在 transition/animation 完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。</span><br><span class="line"></span><br><span class="line">v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入一帧后生效 (于此同时 v-enter 被删除)，在 transition/animation 完成之后移除。</span><br><span class="line"></span><br><span class="line">v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。</span><br><span class="line"></span><br><span class="line">v-leave-active：定义过渡的状态。在元素整个过渡过程中作用，在离开过渡被触发后立即生效，在 transition/animation 完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。</span><br><span class="line"></span><br><span class="line">v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发一帧后生效 (于此同时 v-leave 被删除)，在 transition/animation 完成之后移除。</span><br><span class="line"></span><br><span class="line">![className](https://cn.vuejs.org/images/transition.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果有多个元素需要用transition-group包裹，并且需要有key值做标记</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">animate.css:</span><br><span class="line"></span><br><span class="line">引入animate.css之后，按照下面的写法：</span><br></pre></td></tr></table></figure><transition ​="" leave-active-class="animated fadeOut" enter-active-class="animated slideInLeft"><br>​        <p v-if="isShow" class="box"></p><br></transition><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">##### Vue里组件的通信</span><br><span class="line"></span><br><span class="line">通信：传参、控制（A操控B做一个事件）、数据共享</span><br><span class="line"></span><br><span class="line">模式：父子组件间、非父子组件</span><br><span class="line"></span><br><span class="line">1. 父组件可以将一条数据传递给子组件，这条数据可以是动态的，父组件的数据更改的时候，子组件接收的也会变化</span><br><span class="line"></span><br><span class="line">    子组件被动的接收父组件的数据,子组件不要再更改这条数据了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 父组件如果将一个引用类型的动态数据传递给子组价的时候，数据会变成双向控制的，子组件改数据的时候父组件也能接收到数据变化,因为子组件改的时候不是在改数据(地址)，而是在改数据里的内容，也就是说引用类型数据的地址始终没有变化，不算改父组件数据</span><br><span class="line"></span><br><span class="line">    父子间数据共享（双向控制）,基本不会使用，违背了单向数据流</span><br><span class="line"></span><br><span class="line">3. 父组件可以将一个方法传递给子组件，子组件调用这个方法的时候，就可以给父组件传递数据</span><br><span class="line"></span><br><span class="line">    父组件被动的接收子组件的数据</span><br><span class="line"></span><br><span class="line">4. 父组件可以将一个事件绑定在子组件的身上，这个事件的处理程序是父组件某一个方法，当子组件触发自己的这个被绑定的事件的时候，相当于触发了父组件的方法</span><br><span class="line"></span><br><span class="line">    父组件被动的接收子组件的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5. 在组件间可以用过ref形成ref链，组件还拥有一个关系链（$parent,$children,$root）,通过这两种链；理论来说，任意的两个组件都可以互相访问，互相进行通信</span><br><span class="line"></span><br><span class="line">    任意组件通信，用的少...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6. event bus  事件总线  小天使  专注于非父子组件的通信，其实父子组件也可以使用，只是没有必要</span><br><span class="line"></span><br><span class="line">    在B组件的某个钩子函数为event_bus绑定一个事件，事件的处理程序是B想做的事情</span><br><span class="line"></span><br><span class="line">    在A组件的某一个操作里，触发event_bus绑定的事件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7. 大量组件间数据共享的时候  vuex</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;过滤器&quot;&gt;&lt;a href=&quot;#过滤器&quot; class=&quot;headerlink&quot; title=&quot;过滤器&quot;&gt;&lt;/a&gt;过滤器&lt;/h5&gt;&lt;p&gt;vue中可以设置filter(过滤器)来实现数据格式化，双花括号插值和 v-bind 表达式中使用&lt;/p&gt;
&lt;p&gt;vue1.0的有默
      
    
    </summary>
    
    
      <category term="vue学习" scheme="https://tianjiec.top/tags/vue%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vue学习4</title>
    <link href="https://tianjiec.top/2019/01/08/vue%E5%AD%A6%E4%B9%A04/"/>
    <id>https://tianjiec.top/2019/01/08/vue学习4/</id>
    <published>2019-01-08T09:16:56.000Z</published>
    <updated>2019-01-08T09:18:20.288Z</updated>
    
    <content type="html"><![CDATA[<h5 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h5><p>模块化就是将系统功能分离成独立的功能部分的方法，一般指的是单个的某一种东西，例如js、css</p><p>而组件化针对的是页面中的整个完整的功能模块划分，组件是一个html、css、js、image等外链资源，这些部分组成的一个聚合体</p><p>优点：代码复用，便于维护</p><p>划分组件的原则：复用率高的，独立性强的</p><p>组件应该拥有的特性：可组合，可重用，可测试，可维护</p><h5 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h5><p>在vue中，我们通过Vue.extend来创建Vue的子类，这个东西其实就是组件</p><p>也就是说Vue实例和组件的实例有差别但是差别不带，因为毕竟一个是父类一个是子类</p><p>一般的应用，会拥有一个根实例，在根实例里面都是一个一个的组件</p><p>因为组件是要嵌入到实例或者父组件里的，也就是说，组件可以互相嵌套，而且，所有的组件最外层必须有一个根实例，所以组件分为：全局组件和局部组件</p><p>全局组件在任意的实例、父级组件中都能使用，局部组件只能在创建自己的父级组件或者实例中使用</p><p>组件通过不同的注册方法成为全局、局部组件</p><p>创建组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.extend(options)</span><br></pre></td></tr></table></figure><p>全局注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var App = Vue.extend(&#123;</span><br><span class="line">    template:&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(&apos;my-app&apos;,App)</span><br></pre></td></tr></table></figure><p>简便写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建组件构造器和注册组件合并一起  </span><br><span class="line"> Vue.component(&apos;hello&apos;,&#123;//Vue会自动的将此对象给Vue.extend</span><br><span class="line">     template:&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>组件通过template来确定自己的模板,template里的模板必须有根节点，标签必须闭合</p><p>组件的属性挂载通过：data方法来返回一个对象作为组件的属性，这样做的目的是为了每一个组件实例都拥有独立的data属性</p><p>局部注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el:&quot;#app&quot;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        &apos;my-app&apos;:App</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简便写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">    &apos;hello&apos;:&#123;</span><br><span class="line">        template:&quot;&lt;h1&gt;asdasdasdasdasdas&lt;/h1&gt;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实例或者组件中注册另一个组件，这个时候，被注册的组件只能在注册它的实例或组件的模板中使用，一个组件可以被多个组件或实例注册</p><h6 id="注意浏览器规则"><a href="#注意浏览器规则" class="headerlink" title="注意浏览器规则"></a>注意浏览器规则</h6><p>因为vue在解析模板的时候会根据某些html的规则，例如，在table里只能放tr,td,th..，如果放入组件不会解析 这个时候我们可以放入tr使用is方式来标识这个tr其实是组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;tr is=&quot;hello&quot;&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h6 id="template"><a href="#template" class="headerlink" title="template"></a>template</h6><p>我们可以在html的某个地方通过template标签来定义组件的模板，在组件的template属性中通过选择器指定对应的template标签内容就可以了,注意，需要给template标签加id来指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=&quot;my-hello&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;hello world&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;hahahah&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">//组件中</span><br><span class="line">template:&quot;#my-hello&quot;</span><br></pre></td></tr></table></figure><h6 id="is切换"><a href="#is切换" class="headerlink" title="is切换"></a>is切换</h6><p>在实例、组件的模板中的某一个标签上，可以通过is属性来指定为另一个目标的组件，这个时候我们一般会使用component标签来占位、设置is属性来指定目标组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;component :is=&quot;type&quot;&gt;&lt;/component&gt;</span><br><span class="line"></span><br><span class="line">//组件中</span><br><span class="line">data:&#123;</span><br><span class="line">    type:&apos;aaa&apos;</span><br><span class="line">&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">    &apos;aaa&apos;:&#123;template:&quot;&lt;h1&gt;AAAAAAAAAAAAA&lt;/h1&gt;&quot;&#125;,</span><br><span class="line">    &apos;bbb&apos;:&#123;template:&quot;&lt;h1&gt;BBBBBBBBBBBBB&lt;/h1&gt;&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h6><p>应用中划分的组件可能会很多，为了更好的实现代码复用，所以必然会存在组件的嵌套关系</p><p>组件设计初衷就是要配合使用的，最常见的就是形成父子组件的关系：组件 A 在它的模板中使用了组件 B。</p><h6 id="prop-传递数据"><a href="#prop-传递数据" class="headerlink" title="prop 传递数据"></a>prop 传递数据</h6><p>组件实例的作用域是孤立的,父组件不能直接使用子组件的数据，子组件也不能直接使用父组件的数据</p><p>父组件在模板中使用子组件的时候可以给子组件传递数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bbb money=&quot;2&quot;&gt;&lt;/bbb&gt;</span><br></pre></td></tr></table></figure><p>子组件需要通过props属性来接收后才能使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;bbb&apos;:&#123;</span><br><span class="line">    props:[&apos;money&apos;]</span><br></pre></td></tr></table></figure><p>如果父组件传递属性给子组件的时候键名有’-‘，子组件接收的时候写成小驼峰的模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bbb clothes-logo=&apos;amani&apos; clothes-price=&quot;16.58&quot;&gt;&lt;/bbb&gt;</span><br><span class="line">////</span><br><span class="line">props:[&apos;clothesLogo&apos;,&apos;clothesPrice&apos;]</span><br></pre></td></tr></table></figure><p>我们可以用 v-bind 来动态地将 prop 绑定到父组件的数据。每当父组件的数据变化时，该变化也会传导给子组件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;组件化&quot;&gt;&lt;a href=&quot;#组件化&quot; class=&quot;headerlink&quot; title=&quot;组件化&quot;&gt;&lt;/a&gt;组件化&lt;/h5&gt;&lt;p&gt;模块化就是将系统功能分离成独立的功能部分的方法，一般指的是单个的某一种东西，例如js、css&lt;/p&gt;
&lt;p&gt;而组件化针对的是页面中的
      
    
    </summary>
    
    
      <category term="vue学习" scheme="https://tianjiec.top/tags/vue%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vue学习3</title>
    <link href="https://tianjiec.top/2019/01/08/vue%E5%AD%A6%E4%B9%A03/"/>
    <id>https://tianjiec.top/2019/01/08/vue学习3/</id>
    <published>2019-01-08T09:16:51.000Z</published>
    <updated>2019-01-08T09:24:31.907Z</updated>
    
    <content type="html"><![CDATA[<h5 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h5><p>这是一个指令，只要有v-的就是指令（directive 操作dom ）</p><p>在vue中可以通过v-for来循环数据的通知循环dom，语法是item in/of items，接收第二个参数是索引 (item,index) of items,还可以循环键值对，第一个参数是value，第二个是key，第三个依然是索引</p><h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h5><p>在vue中还有v-on来为dom绑定事件，在v-on：后面加上要绑定的事件类型，值里可以执行一些简单javascript表达式：++ – = …</p><p>可以将一些方法设置在methods里，这样就可以在v-on:click的值里直接写方法名字可以，默认会在方法中传入事件对象，当写方法的时候加了()就可以传参，这个时候如果需要事件对象，那就主动传入$event</p><p>v-on绑定的事件可以是任意事件,v-on:可以缩写为@</p><p>为什么在 HTML 中监听事件?</p><p>你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处：</p><ol><li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li><li>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</li><li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。</li></ol><h5 id="计算属性、监听"><a href="#计算属性、监听" class="headerlink" title="计算属性、监听"></a>计算属性、监听</h5><p>有的时候我们需要在模板中使用数据a，这个时候就需要用到表达式，但是有的地方我们需要对a数据进行一些简单的处理后才能使用，那么我们就会在表达式中写一些js逻辑运算</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样我们的维护就会非常困难，也不便于阅读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我们就可以在methods里设置一个方法，在模板的表达式中使用这个方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">// 在组件中</span><br><span class="line">methods: &#123;</span><br><span class="line">reversedMessage: function () &#123;</span><br><span class="line">    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">但是这个时候，只要vm中有数据变化，这个变化的数据可能和我们关注的数据无关，但是vm都会重新渲染模板，这个时候表达式中的方法就会重新执行，大大的影响性能</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个时候其实我们可以使用监听器里完成：</span><br><span class="line"></span><br><span class="line">在vm实例中设置watch属性，在里面通过键值对来设置一些监听，键名为数据名，值可以是一个函数，这个函数在数据改变之后才会执行，两个参数分别是性格前的值和更改后的值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a: function (val, oldVal) &#123;</span><br><span class="line">    console.log(&apos;new: %s, old: %s&apos;, val, oldVal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">值还可以是一个方法名字，当数据改变的时候这个方法会执行</span><br><span class="line"></span><br><span class="line">当数据为object的时候，object的键值对改变不会被监听到（数组的push等方法可以）,这个时候需要设置深度监听：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c: &#123;</span><br><span class="line">    deep:true,</span><br><span class="line">    handler:function (val, oldVal) &#123;</span><br><span class="line">        console.log(&apos;new: %s, old: %s&apos;, val, oldVal)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">监听的handler函数前面的这几种写法都是在数据变化的时候才会执行，初始化的时候不会执行，但是如果设置immediate为true就可以了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num:&#123;</span><br><span class="line">    immediate:true,</span><br><span class="line">    handler:function(val)&#123;</span><br><span class="line">        this.nums = val*2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在回到上面的问题，用监听器加上immediate属性就可以做到该效果，但是大家可以看到的是逻辑稍稍有点复杂</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我们一般都会用到一个叫计算属性的东西来解决：</span><br><span class="line"></span><br><span class="line">计算属性就是在实例配置项中通过computed来为vm设置一个新的数据，而这个新数据会拥有一个依赖（一条已经存在的数据），当依赖发生变化的时候，新数据也会发生变化</span><br><span class="line"></span><br><span class="line">与方法的方式相比，它性能更高，计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</span><br><span class="line"></span><br><span class="line">与watch相比，写起来简单，逻辑性更清晰，watch一般多用于，根据数据的变化而执行某些动作，而至于这些动作是在干什么其实无所谓，而计算属性更有针对性，根据数据变化而更改另一个数据</span><br><span class="line"></span><br><span class="line">计算属性也拥有getter和setter，默认写的是getter，设置setter可以当此计算属性数据更改的时候去做其他的一些事情，相当于watch这个计算属性</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xm:&#123;</span><br><span class="line">    get:function()&#123;//getter 当依赖改变后设置值的时候</span><br><span class="line">        return this.xing+&apos;丶&apos;+this.ming</span><br><span class="line">    &#125;,</span><br><span class="line">    set:function(val)&#123;//setter 当自身改变后执行</span><br><span class="line">        this.xing = val.split(&apos;丶&apos;)[0]</span><br><span class="line">        this.ming = val.split(&apos;丶&apos;)[1]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;v-for&quot;&gt;&lt;a href=&quot;#v-for&quot; class=&quot;headerlink&quot; title=&quot;v-for&quot;&gt;&lt;/a&gt;v-for&lt;/h5&gt;&lt;p&gt;这是一个指令，只要有v-的就是指令（directive 操作dom ）&lt;/p&gt;
&lt;p&gt;在vue中可以通过v-for来
      
    
    </summary>
    
    
      <category term="vue学习" scheme="https://tianjiec.top/tags/vue%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vue学习2</title>
    <link href="https://tianjiec.top/2019/01/08/vue%E5%AD%A6%E4%B9%A02/"/>
    <id>https://tianjiec.top/2019/01/08/vue学习2/</id>
    <published>2019-01-08T09:16:45.000Z</published>
    <updated>2019-01-08T09:23:53.147Z</updated>
    
    <content type="html"><![CDATA[<h5 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h5><p>这是一个指令，只要有v-的就是指令（directive 操作dom ）</p><p>在vue中可以通过v-for来循环数据的通知循环dom，语法是item in/of items，接收第二个参数是索引 (item,index) of items,还可以循环键值对，第一个参数是value，第二个是key，第三个依然是索引</p><h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h5><p>在vue中还有v-on来为dom绑定事件，在v-on：后面加上要绑定的事件类型，值里可以执行一些简单javascript表达式：++ – = …</p><p>可以将一些方法设置在methods里，这样就可以在v-on:click的值里直接写方法名字可以，默认会在方法中传入事件对象，当写方法的时候加了()就可以传参，这个时候如果需要事件对象，那就主动传入$event</p><p>v-on绑定的事件可以是任意事件,v-on:可以缩写为@</p><p>为什么在 HTML 中监听事件?</p><p>你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处：</p><ol><li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li><li>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</li><li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。</li></ol><h5 id="计算属性、监听"><a href="#计算属性、监听" class="headerlink" title="计算属性、监听"></a>计算属性、监听</h5><p>有的时候我们需要在模板中使用数据a，这个时候就需要用到表达式，但是有的地方我们需要对a数据进行一些简单的处理后才能使用，那么我们就会在表达式中写一些js逻辑运算</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样我们的维护就会非常困难，也不便于阅读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我们就可以在methods里设置一个方法，在模板的表达式中使用这个方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">// 在组件中</span><br><span class="line">methods: &#123;</span><br><span class="line">reversedMessage: function () &#123;</span><br><span class="line">    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">但是这个时候，只要vm中有数据变化，这个变化的数据可能和我们关注的数据无关，但是vm都会重新渲染模板，这个时候表达式中的方法就会重新执行，大大的影响性能</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个时候其实我们可以使用监听器里完成：</span><br><span class="line"></span><br><span class="line">在vm实例中设置watch属性，在里面通过键值对来设置一些监听，键名为数据名，值可以是一个函数，这个函数在数据改变之后才会执行，两个参数分别是性格前的值和更改后的值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a: function (val, oldVal) &#123;</span><br><span class="line">    console.log(&apos;new: %s, old: %s&apos;, val, oldVal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">值还可以是一个方法名字，当数据改变的时候这个方法会执行</span><br><span class="line"></span><br><span class="line">当数据为object的时候，object的键值对改变不会被监听到（数组的push等方法可以）,这个时候需要设置深度监听：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c: &#123;</span><br><span class="line">    deep:true,</span><br><span class="line">    handler:function (val, oldVal) &#123;</span><br><span class="line">        console.log(&apos;new: %s, old: %s&apos;, val, oldVal)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">监听的handler函数前面的这几种写法都是在数据变化的时候才会执行，初始化的时候不会执行，但是如果设置immediate为true就可以了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num:&#123;</span><br><span class="line">    immediate:true,</span><br><span class="line">    handler:function(val)&#123;</span><br><span class="line">        this.nums = val*2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在回到上面的问题，用监听器加上immediate属性就可以做到该效果，但是大家可以看到的是逻辑稍稍有点复杂</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我们一般都会用到一个叫计算属性的东西来解决：</span><br><span class="line"></span><br><span class="line">计算属性就是在实例配置项中通过computed来为vm设置一个新的数据，而这个新数据会拥有一个依赖（一条已经存在的数据），当依赖发生变化的时候，新数据也会发生变化</span><br><span class="line"></span><br><span class="line">与方法的方式相比，它性能更高，计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</span><br><span class="line"></span><br><span class="line">与watch相比，写起来简单，逻辑性更清晰，watch一般多用于，根据数据的变化而执行某些动作，而至于这些动作是在干什么其实无所谓，而计算属性更有针对性，根据数据变化而更改另一个数据</span><br><span class="line"></span><br><span class="line">计算属性也拥有getter和setter，默认写的是getter，设置setter可以当此计算属性数据更改的时候去做其他的一些事情，相当于watch这个计算属性</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xm:&#123;</span><br><span class="line">    get:function()&#123;//getter 当依赖改变后设置值的时候</span><br><span class="line">        return this.xing+&apos;丶&apos;+this.ming</span><br><span class="line">    &#125;,</span><br><span class="line">    set:function(val)&#123;//setter 当自身改变后执行</span><br><span class="line">        this.xing = val.split(&apos;丶&apos;)[0]</span><br><span class="line">        this.ming = val.split(&apos;丶&apos;)[1]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;v-for&quot;&gt;&lt;a href=&quot;#v-for&quot; class=&quot;headerlink&quot; title=&quot;v-for&quot;&gt;&lt;/a&gt;v-for&lt;/h5&gt;&lt;p&gt;这是一个指令，只要有v-的就是指令（directive 操作dom ）&lt;/p&gt;
&lt;p&gt;在vue中可以通过v-for来
      
    
    </summary>
    
    
      <category term="vue学习" scheme="https://tianjiec.top/tags/vue%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vue学习1</title>
    <link href="https://tianjiec.top/2019/01/08/vue%E5%AD%A6%E4%B9%A01/"/>
    <id>https://tianjiec.top/2019/01/08/vue学习1/</id>
    <published>2019-01-08T09:15:53.000Z</published>
    <updated>2019-01-08T09:16:29.005Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><blockquote><p>Vue是一个前端js框架，由尤雨溪开发，是个人项目</p></blockquote><p>Vue近几年来特别的受关注，三年前的时候angularJS霸占前端JS框架市场很长时间，接着react框架横空出世，因为它有一个特性是虚拟DOM，从性能上碾轧angularJS，这个时候，vue1.0悄悄的问世了，它的优雅，轻便也吸引了一部分用户，开始收到关注，16年中旬，VUE2.0问世，这个时候vue不管从性能上，还是从成本上都隐隐超过了react，火的一塌糊涂，这个时候，angular开发团队也开发了angular2.0版本，并且更名为angular，吸收了react、vue的优点，加上angular本身的特点，也吸引到很多用户，目前已经迭代到5.0了。</p><p>学习vue是现在前端开发者必须的一个技能。</p><h5 id="前端js框架到底在干嘛，为什么要用"><a href="#前端js框架到底在干嘛，为什么要用" class="headerlink" title="前端js框架到底在干嘛，为什么要用"></a>前端js框架到底在干嘛，为什么要用</h5><p>js框架帮助开发者写js逻辑代码，在开发应用的时候js的功能划分为如下几点：</p><ol><li>渲染数据</li><li>操作dom（写一些效果）</li><li>操作cookie等存储机制api</li></ol><p>在前端开发中，如何高效的操作dom、渲染数据是一个前端工程师需要考虑的问题，而且当数据量大，流向较乱的时候，如何正确使用数据，操作数据也是一个问题</p><p>而js框架对上述的几个问题都有自己趋于完美的解决方案，开发成本降低。高性能高效率。唯一的缺点就是需要使用一定的成本来学习。</p><h5 id="Vue官网介绍"><a href="#Vue官网介绍" class="headerlink" title="Vue官网介绍"></a>Vue官网介绍</h5><p>vue是渐进式JavaScript框架</p><p>vue的主张较弱</p><p>“渐进式框架”和“自底向上增量开发的设计”是Vue开发的两个概念</p><p>Vue可以在任意其他类型的项目中使用，使用成本较低，更灵活，主张较弱，在Vue的项目中也可以轻松融汇其他的技术来开发，并且因为Vue的生态系统特别庞大，可以找到基本所有类型的工具在vue项目中使用</p><p>特点：易用（使用成本低），灵活（生态系统完善，适用于任何规模的项目），高效（体积小，优化好，性能好）</p><p>Vue是一个MVVM的js框架，但是，Vue 的核心库只关注视图层，开发者关注的只是m-v的映射关系</p><h3 id="Vue的使用"><a href="#Vue的使用" class="headerlink" title="Vue的使用"></a>Vue的使用</h3><p>Vue不支持IE8，因为使用了ES5的很多特性  //Object.defineProperty(_data,”msg”,{get(),set()})  _data.msg</p><p>可以直接通过script标签来引入vue.js，有开发版本和生产版本，开发版本一般我们在开发项目的时候引入，当最后开发完成上线的时候引入生产版本，开发版本没有压缩的，并且有很多提示，而生产版本全部删掉了</p><p>在Vue中提供了一个脚手架（命令行工具）可以帮我们快速的搭建基于webpack的开发环境…</p><h4 id="Vue的实例"><a href="#Vue的实例" class="headerlink" title="Vue的实例"></a>Vue的实例</h4><p>每一个应用都有一个根实例，在根实例里我们通过组件嵌套来实现大型的应用</p><p>也就是说组件不一定是必须的，但是实例是必须要有的</p><p>在实例化实例的时候我们可以传入一个；配置项，在配置项中设置很多属性方法可以实现复杂的功能</p><p>在配置中可以设置el（挂载点）的属性，el属性代表的是此实例的作用范围</p><p>在配置中同过设置data属性来为实例绑定数据</p><h3 id="mvc-mvvm"><a href="#mvc-mvvm" class="headerlink" title="mvc/mvvm"></a>mvc/mvvm</h3><p><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">阮大神博客</a></p><p>mvc 分为三层，其实M层是数据模型层，它是真正的后端数据在前端js中的一个映射模型，他们的关系是：数据模型层和视图层有映射关系，model改变，view展示也会更改，当view产生用户操作或会反馈给controller，controller更改model，这个时候view又会进行新的数据渲染</p><p>view可以直接操作model （数据双向绑定）</p><p>MVVM：</p><p><a href="http://image.beekka.com/blog/2015/bg2015020110.png" target="_blank" rel="noopener">mvvm</a></p><p>MVVM和MVP及其相似，只是view和viewmodel的通信是双向绑定，view的操作会自动的像viewmodel通过</p><h5 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h5><p>这是一个指令，只要有v-的就是指令（directive 操作dom ）</p><p>在vue中可以通过v-for来循环数据的通知循环dom，语法是item in/of items，接收第二个参数是索引 (item,index) of items,还可以循环键值对，第一个参数是value，第二个是key，第三个依然是索引</p><h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h5><p>在vue中还有v-on来为dom绑定事件，在v-on：后面加上要绑定的事件类型，值里可以执行一些简单javascript表达式：++ – = …</p><p>可以将一些方法设置在methods里，这样就可以在v-on:click的值里直接写方法名字可以，默认会在方法中传入事件对象，当写方法的时候加了()就可以传参，这个时候如果需要事件对象，那就主动传入$event</p><p>v-on绑定的事件可以是任意事件,v-on:可以缩写为@</p><p>为什么在 HTML 中监听事件?</p><p>你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处：</p><ol><li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li><li>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</li><li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vue&quot;&gt;&lt;a href=&quot;#Vue&quot; class=&quot;headerlink&quot; title=&quot;Vue&quot;&gt;&lt;/a&gt;Vue&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Vue是一个前端js框架，由尤雨溪开发，是个人项目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vue近几年
      
    
    </summary>
    
    
      <category term="vue学习" scheme="https://tianjiec.top/tags/vue%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
