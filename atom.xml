<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chentj&#39;s Blog</title>
  
  <subtitle>Inflexible thinking, bad humor</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tianjiec.top/"/>
  <updated>2019-03-06T13:45:15.245Z</updated>
  <id>https://tianjiec.top/</id>
  
  <author>
    <name>chentj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习计划</title>
    <link href="https://tianjiec.top/2019/03/06/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>https://tianjiec.top/2019/03/06/学习计划/</id>
    <published>2019-03-06T13:42:09.000Z</published>
    <updated>2019-03-06T13:45:15.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="短期"><a href="#短期" class="headerlink" title="短期"></a>短期</h2><blockquote><p>熟悉项目</p><p>看vue文档，学习vue知识</p><p>复习html、css基础核心（css样式层叠、继承，盒模型、容器，溢出及元素类型；浏览器兼容及元宽高自适应；锚点    与透明；图片整合；表格，CSS属性与滤镜）</p><p>html5+css3（新增元素和属性、表单域增强元素；css3选择器；文字字体相关样式；css3位移与变形处理；css3 2D转换与过度动画；css3 3D转换与关键帧动画、弹性盒模型；媒体查询；响应式设计）</p></blockquote><h2 id="长期"><a href="#长期" class="headerlink" title="长期"></a>长期</h2><blockquote><p>培养逻辑能力</p><p>看thinkinjava</p></blockquote><p>1、层叠</p><blockquote><p>：CSS中的层叠就是让多个来源的样式叠加在一起，然后结合样式的特殊性（后面详细介绍）、继承性，确定最终应用的样式。</p></blockquote><p>2、定位</p><table><thead><tr><th>定位position</th><th>说明</th></tr></thead><tbody><tr><td>绝对定位absolute</td><td>给它一个<code>left top</code>相对浏览器跑<br>如果子盒想相对父盒子跑，子盒子为<code>relative</code>父盒子不设值<br>或者子盒子设置<code>absolute</code>，父盒子是<code>relative</code>（子绝父相）</td></tr><tr><td>相对定位relative</td><td>给他一个left、top相对父盒子跑</td></tr><tr><td>固定定位fixed</td><td>相对于屏幕 固定在屏幕某个地方</td></tr></tbody></table><p>3、溢出</p><blockquote><p>文本：overflow换行溢出：隐藏hidden；显示visible；自动auto出现滚动条 ； overflow-x/overflow-y：hidden出现水平/垂直滚动条；</p><p>文本溢出省略：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/*1.单行溢出隐藏显示...(在文字的容器上设置)*/</span></span><br><span class="line">&gt; <span class="selector-class">.text-box1</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">&gt;  white-space: nowrap;      /*超出的空白区域不换行*/</span><br><span class="line">&gt;  <span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;         <span class="comment">/*超出隐藏*/</span></span><br><span class="line">&gt;  <span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;  <span class="comment">/*文本超出显示省略号*/</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &lt;!<span class="selector-tag">--</span>多行溢出隐藏显示...（只兼容<span class="selector-tag">webkit</span>内核的浏览器）<span class="selector-tag">--</span>&gt;</span><br><span class="line">&gt; <span class="selector-class">.text-box2</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">&gt;  display: -webkit-box;             /*将对象转为弹性盒模型展示*/</span><br><span class="line">&gt;  <span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;     <span class="comment">/*设置弹性盒模型子元素的排列方式*/</span></span><br><span class="line">&gt;  <span class="selector-tag">-webkit-line-clamp</span>: 2;            <span class="comment">/*限制文本行数*/</span></span><br><span class="line">&gt;  <span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;                 <span class="comment">/*超出隐藏*/</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &lt;!<span class="selector-tag">--</span>多行溢出隐藏显示...(跨浏览器兼容+伪元素定位)<span class="selector-tag">--</span>&gt;</span><br><span class="line">&gt; &lt;div class="box text-box3"&gt;</span><br><span class="line">&gt;  &lt;p&gt;目录结构清晰是首要目标，至于命名只要能达到表意的目的即可。目录结构&lt;/p&gt;            </span><br><span class="line">&gt; &lt;/div&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/*3.多行溢出隐藏显示...(跨浏览器兼容+伪元素定位)*/</span></span><br><span class="line">&gt; <span class="selector-class">.text-box3</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">&gt;  position: relative;</span><br><span class="line">&gt;  <span class="selector-tag">line-height</span>: 1<span class="selector-class">.4em</span>;        <span class="comment">/*行高和height成倍数，这里以三行文本超出隐藏举例*/</span></span><br><span class="line">&gt;  <span class="selector-tag">height</span>: 4<span class="selector-class">.2em</span>;</span><br><span class="line">&gt;  <span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="selector-class">.text-box3</span> <span class="selector-tag">p</span><span class="selector-pseudo">::after</span>&#123;         <span class="comment">/*若要兼容IE8需用:after*/</span></span><br><span class="line">&gt;  content: "...";          /*替换内容比较灵活*/</span><br><span class="line">&gt;  <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">&gt;  <span class="selector-tag">bottom</span>: 2<span class="selector-tag">px</span>;</span><br><span class="line">&gt;  <span class="selector-tag">right</span><span class="selector-pseudo">:5px</span>;</span><br><span class="line">&gt;  <span class="selector-tag">padding</span>: 0 3<span class="selector-tag">px</span>;</span><br><span class="line">&gt;  <span class="selector-tag">background</span>:<span class="selector-id">#fff</span>;         <span class="comment">/*颜色和文字背景保持一致*/</span></span><br><span class="line">&gt;  <span class="selector-tag">box-shadow</span>: 0 0 10<span class="selector-tag">px</span> <span class="selector-id">#fff</span>;  <span class="comment">/*边缘处理*/</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; 借鉴博文：https://blog.csdn.net/sinat_38426472/article/details/79654816</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>图片：</p><p>overflow:hidden 超出裁剪</p><p>未加定位从左上按原像素开始显示</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;短期&quot;&gt;&lt;a href=&quot;#短期&quot; class=&quot;headerlink&quot; title=&quot;短期&quot;&gt;&lt;/a&gt;短期&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;熟悉项目&lt;/p&gt;
&lt;p&gt;看vue文档，学习vue知识&lt;/p&gt;
&lt;p&gt;复习html、css基础核心（css样式层叠、
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博客平台移动端</title>
    <link href="https://tianjiec.top/2019/03/03/%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    <id>https://tianjiec.top/2019/03/03/博客平台移动端/</id>
    <published>2019-03-03T03:18:38.000Z</published>
    <updated>2019-03-03T03:20:32.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>宽度查询onresize 在宽度小于900px时候 自动跳转到移动端页面reload</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;宽度查询onresize 在宽度小于900px时候 自动跳转到移动端页面reload&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>express博客应用markdown插件</title>
    <link href="https://tianjiec.top/2019/03/03/express%E5%8D%9A%E5%AE%A2%E5%BA%94%E7%94%A8markdown%E6%8F%92%E4%BB%B6/"/>
    <id>https://tianjiec.top/2019/03/03/express博客应用markdown插件/</id>
    <published>2019-03-03T00:20:30.000Z</published>
    <updated>2019-03-03T01:18:36.671Z</updated>
    
    <content type="html"><![CDATA[<h3 id="博客-markdown"><a href="#博客-markdown" class="headerlink" title="博客+markdown"></a>博客+markdown</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 博客平台文章txt显示太丑，用html去写文章再用swig模板语言&#123;% autoescape %&#125;&#123;&#123; content.content&#125;&#125;&#123;% endautoescape %&#125;去显示可以 但是 写文章时候太麻烦</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>所以可借用markdown相关插件 用markdown写 转成 html显示</p></blockquote><h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><p>借助bootstrap-markdown</p><p>在页面中引入bootstrap相关文件，jquery，以及bootstrap-markdown.min.css和bootstrap-markdown.js文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"bootstrap-markdown.min.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/bootstrap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"bootstrap-markdown.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;--使用Bootstrap-Markdown比那家亲的方法非常简单，你只需要在一个\&lt;textarea/&gt;元素中设置data-provide="markdown"属性，它就可以自动转换为Markdown编辑器。--&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">data-provide</span>=<span class="string">"markdown"</span> <span class="attr">rows</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果要制作一个内联的Markdown编辑器，可以添加data-provide=”markdown-editable”属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div data-provide=&quot;markdown-editable&quot;&gt;</span><br><span class="line">  &lt;h3&gt;这是可以编辑的标题&lt;/h3&gt;</span><br><span class="line">  &lt;p&gt;所有在 &quot;markdown-editable&quot; 这个div中的内容都是可以编辑的。&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="初始化插件"><a href="#初始化插件" class="headerlink" title="初始化插件"></a>初始化插件</h5><p>你也可以通过js的方式来初始化该Markdown编辑器插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#some-textarea&quot;).markdown(&#123;autofocus:false,savable:false&#125;)</span><br></pre></td></tr></table></figure><h2 id="看"><a href="#看" class="headerlink" title="看"></a>看</h2><h4 id="markdown转HTML-使用editor-md"><a href="#markdown转HTML-使用editor-md" class="headerlink" title="markdown转HTML(使用editor.md)"></a>markdown转HTML(使用editor.md)</h4><p>editor.md网站地址<a href="http://pandao.github.io/editor.md/" target="_blank" rel="noopener">http://pandao.github.io/editor.md/</a></p><p>首先需要引入对应的css跟js文件，jquery一定要在前面引入</p><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入样式文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"editor.md-master/examples/css/style.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"editor.md-master/css/editormd.preview.css"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入js文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/examples/js/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/lib/marked.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/lib/prettify.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/lib/raphael.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/lib/underscore.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/lib/sequence-diagram.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/lib/flowchart.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/lib/jquery.flowchart.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/editormd.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--输入需要转换的markdown文件开始--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>转换前<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"demo1"</span> <span class="attr">style</span>=<span class="string">"width:800px;height:300px;"</span>&gt;</span></span><br><span class="line">hadoop命令需在hadoop目录下使用</span><br><span class="line">        **常用命令**</span><br><span class="line">        HDFS格式化:</span><br><span class="line">bin/hadoop namenode -format    格式化namenode</span><br><span class="line">bin/hadoop datanode -format    格式化datanode</span><br><span class="line"></span><br><span class="line">*如不是第一次格式化，为了保证clusterID一致性,</span><br><span class="line">*需先删除hdfs临时目录,</span><br><span class="line">*即在配置文件中配置的hadoop.tmp.dir参数路径</span><br><span class="line">    <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--输入需要转换的markdown文件结束--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--点击该按钮进行转换--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"mdToHml();"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>点击转Html<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>=================  华丽丽的分割线 ====================<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>转换后<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在该div中展示,如有初始化的数据可以放在textarea中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"testEditorMdview"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"appendTest"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--js开始--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//markDown转HTMl的方法</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">mdToHml</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//先对容器初始化，在需要展示的容器中创建textarea隐藏标签，</span></span></span><br><span class="line"><span class="xml">        $("#testEditorMdview").html('<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"appendTest"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span>');</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> content=$(<span class="string">"#demo1"</span>).val();<span class="comment">//获取需要转换的内容</span></span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#appendTest"</span>).val(content);<span class="comment">//将需要转换的内容加到转换后展示容器的textarea隐藏标签中</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//转换开始,第一个参数是上面的div的id</span></span></span><br><span class="line"><span class="javascript">        editormd.markdownToHTML(<span class="string">"testEditorMdview"</span>, &#123;</span></span><br><span class="line"><span class="javascript">            htmlDecode: <span class="string">"style,script,iframe"</span>, <span class="comment">//可以过滤标签解码</span></span></span><br><span class="line"><span class="javascript">            emoji: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">            taskList:<span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">            tex: <span class="literal">true</span>,               <span class="comment">// 默认不解析</span></span></span><br><span class="line"><span class="javascript">            flowChart:<span class="literal">true</span>,         <span class="comment">// 默认不解析</span></span></span><br><span class="line"><span class="javascript">            sequenceDiagram:<span class="literal">true</span>,  <span class="comment">// 默认不解析</span></span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--js结束--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编译hexo博客时遇到的坑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;%%&#125; 语法文章不能直接放入 需要放在 代码里面，不然编译报错，应该是hexo的markdown转html会读到这些语法进行解析，解析报错。。。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;博客-markdown&quot;&gt;&lt;a href=&quot;#博客-markdown&quot; class=&quot;headerlink&quot; title=&quot;博客+markdown&quot;&gt;&lt;/a&gt;博客+markdown&lt;/h3&gt;&lt;blockquote&gt;
&lt;figure class=&quot;highlight
      
    
    </summary>
    
    
      <category term="博客" scheme="https://tianjiec.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>面试题总结</title>
    <link href="https://tianjiec.top/2019/02/26/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://tianjiec.top/2019/02/26/面试题总结/</id>
    <published>2019-02-26T12:51:36.000Z</published>
    <updated>2019-02-27T11:56:30.304Z</updated>
    
    <content type="html"><![CDATA[<p>1、函数变量提升优先于值变量提升，提升到作用域最前面<br>2、在react框架里面用的比较多的es6语法</p><blockquote><p>箭头函数，解构赋值，map方法。</p></blockquote><p>3、箭头this函数和普通函数区别，<br>4、map和foreach区别，map有返回值，返回新数组。为什么react用map ，<br>5、promise怎么传值  在这里面<br>6、 es6之前块级作用域，try catch</p><blockquote><p>catch中catch部分是属于块级作用域 error只在 其中有效 </p></blockquote><p>7、 this的理解<br>8、git的使用<br>9、 react 中setdate是异步还是同步的 异步 第二个参数作用 在这里面是setdate之后的状态。</p><p>10、组件复用怎么更新数据</p><p>业务、项目模块建议、总结、学习新知识分享、专业外相关知识学习</p><p>个人总结向其它方向发展</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、函数变量提升优先于值变量提升，提升到作用域最前面&lt;br&gt;2、在react框架里面用的比较多的es6语法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;箭头函数，解构赋值，map方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、箭头this函数和普通函数区别，&lt;br&gt;4、m
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>反向代理</title>
    <link href="https://tianjiec.top/2019/02/24/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://tianjiec.top/2019/02/24/反向代理/</id>
    <published>2019-02-24T13:36:10.000Z</published>
    <updated>2019-02-24T13:47:22.002Z</updated>
    
    <content type="html"><![CDATA[<p>针对于nginx来说</p><p><strong>什么是代理服务器</strong>？</p><blockquote><p>所谓代理服务器就是位于发起请求的客户端与原始服务器端之间的一台跳板服务器，正向代理可以隐藏客户端，反向代理可以隐藏原始服务器。</p></blockquote><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><blockquote><p>正常国内电脑访问谷歌访问不了</p><p>-&gt; 国外服务器可以访问谷歌</p><p>-&gt; 我的国内电脑远程操作服务器 来达到 国内访问谷歌目的（比较累）</p><p>-&gt; 我的国内电脑访问服务器 服务器帮我请求google并返回数据（正向代理）</p></blockquote><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><blockquote><p>反向代理与正向代理是相对的。正向代理是替代客户端去发送请求，二反向代理是替代理服务器接受客户端的请求</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://5b0988e595225.cdn.sohucs.com/images/20180614/3623fd7079f948d1bfa9046c1d4260d4.jpeg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure></blockquote><p>这时候这台代理服务器其实不掌握在我们用户手里了，而是google专门用来接受请求，同时还可以作为过滤不正常的请求，防止你们黑的的一个服务器。对我们客户端来说，不掌握在我手里的东西都是别人的，所以这台服务器是反向的</p><p>假如说正向代理是黑客手里的攻击长矛，反向代理就是google握着的一个盾牌</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;针对于nginx来说&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是代理服务器&lt;/strong&gt;？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所谓代理服务器就是位于发起请求的客户端与原始服务器端之间的一台跳板服务器，正向代理可以隐藏客户端，反向代理可以隐藏原始服务器。&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
    
      <category term="服务器" scheme="https://tianjiec.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>简历</title>
    <link href="https://tianjiec.top/2019/02/13/%E7%AE%80%E5%8E%86/"/>
    <id>https://tianjiec.top/2019/02/13/简历/</id>
    <published>2019-02-13T12:55:06.000Z</published>
    <updated>2019-02-22T11:00:32.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h3><blockquote><h5 id="姓名：罗中运-年龄：24"><a href="#姓名：罗中运-年龄：24" class="headerlink" title="姓名：罗中运   年龄：24"></a>姓名：<strong>罗中运</strong>   年龄：24</h5><p><strong>毕业院校</strong>： 鲁东大学 信息与电气工程学院 （2015.9 ~ 2019.6）</p><p><strong>专业</strong>： 软件工程</p><p><strong>学历</strong>：本科</p><p><strong>联系方式</strong>：17853516710    |   luozy1230@163.com</p></blockquote><h3 id="求职意向"><a href="#求职意向" class="headerlink" title="求职意向"></a>求职意向</h3><blockquote><p>期望职位：HTML5 开发工程师</p><p>目前状况：可立即上岗</p></blockquote><h3 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h3><blockquote><p> 1、熟悉div+css，html基本布局；掌握html5+css3新特性，根据设计图完成页面制作；</p><p> 2、熟练响应式布局和弹性盒布局</p><p> 3、熟练掌握javascript，jQuery各种方法</p><p> 4、熟悉面向对象，理解mvc模式mvvm模式</p><p> 5、掌握bootstrap，曾运用bootstrap进行后端开发实现响应式布局；熟练使用jQuery，运用jQuery实现对dom操作，请求数据并对数据进行相应渲染</p><p> 6、熟练运用swiper、animate.css、mint.ui、axios插件对项目进行快速开发</p><p> 7、熟练掌握MySQL、mongodb数据库、熟练运用localstorage、cookie</p><p> 8、熟练运用ajax、jsonp、json</p><p> 9、熟练vue、react框架，掌握vuex、redux对数据进行处理</p><p> 10、熟练VSCode、Sublime、Hbuilder、Navicat、Photoshop、谷歌插件工具；熟练使用less、sass、gulp等工具辅助编程</p><p> 11、熟悉java、对php、c语言有一定了解</p><p> 12、熟悉git、github版本控制、了解SVN；熟悉swig、ejs模板语言</p></blockquote><h3 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h3><blockquote><h5 id="1、做过大量静态页面"><a href="#1、做过大量静态页面" class="headerlink" title="1、做过大量静态页面"></a>1、做过大量静态页面</h5><h5 id="2、bootstrap-express等-博客项目"><a href="#2、bootstrap-express等-博客项目" class="headerlink" title="2、bootstrap+express等 博客项目"></a>2、bootstrap+express等 博客项目</h5><h5 id="3、仿淘票票的vue项目"><a href="#3、仿淘票票的vue项目" class="headerlink" title="3、仿淘票票的vue项目"></a>3、仿淘票票的vue项目</h5><p>​    所用技术：</p><p>​    1、vue-router实现单页面应用，</p><p>​    2、借用axios请求数据</p><p>​    3、用mint-ui、swiper快速添加成熟组件，animate添加动作</p><p>​    4、标签键值对、传函数、自定义事件，bus总线、vuex实现组件间传值</p><p>​    5、公共组件复用，rem布局</p><p>​    地址：<a href="http://106.13.43.222/taopiaopiao" target="_blank" rel="noopener">http://106.13.43.222/taopiaopiao</a></p><h5 id="4、仿识货的react项目"><a href="#4、仿识货的react项目" class="headerlink" title="4、仿识货的react项目"></a>4、仿识货的react项目</h5><p>​    所用技术：</p><p>​    1、用react-router-dom实现页面跳转</p><p>​    2、借助react-redux对数据进行管理</p><p>​    3、借助axios请求数据</p><p>​    地址：<a href="http://106.13.43.222/shihuo/" target="_blank" rel="noopener">http://106.13.43.222/shihuo/</a></p></blockquote><h3 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h3><blockquote><p>对前沿技术有浓厚兴趣，非常看重写代码时的注释。自主解决bug能力较强。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;个人信息&quot;&gt;&lt;a href=&quot;#个人信息&quot; class=&quot;headerlink&quot; title=&quot;个人信息&quot;&gt;&lt;/a&gt;个人信息&lt;/h3&gt;&lt;blockquote&gt;
&lt;h5 id=&quot;姓名：罗中运-年龄：24&quot;&gt;&lt;a href=&quot;#姓名：罗中运-年龄：24&quot; class=
      
    
    </summary>
    
    
      <category term="简历" scheme="https://tianjiec.top/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>vue常用插件</title>
    <link href="https://tianjiec.top/2019/02/06/vue%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://tianjiec.top/2019/02/06/vue常用插件/</id>
    <published>2019-02-06T12:44:59.000Z</published>
    <updated>2019-02-06T12:46:38.853Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener">element</a> ★13489 - 饿了么出品的Vue2的web UI工具套件</li><li><a href="https://github.com/airyland/vux" target="_blank" rel="noopener">Vux</a> ★8133 - 基于Vue和WeUI的组件库</li><li><a href="https://github.com/iview/iview" target="_blank" rel="noopener">iview</a> ★6634 - 基于 Vuejs 的开源 UI 组件库</li><li><a href="https://github.com/ElemeFE/mint-ui" target="_blank" rel="noopener">mint-ui</a> ★6253 - Vue 2的移动UI元素</li><li><a href="https://github.com/museui/muse-ui" target="_blank" rel="noopener">muse-ui</a> ★3705 - 三端样式一致的响应式 UI 库</li><li><a href="https://github.com/marcosmoura/vue-material" target="_blank" rel="noopener">vue-material</a> ★3328 - 通过Vue Material和Vue 2建立精美的app应用</li><li><a href="https://github.com/vuetifyjs/vuetify" target="_blank" rel="noopener">vuetify</a> ★2925 - 为移动而生的Vue JS 2组件框架</li><li><a href="https://github.com/JosephusPaye/Keen-UI" target="_blank" rel="noopener">Keen-UI</a> ★2749 - 轻量级的基本UI组件合集</li><li><a href="https://github.com/wangdahoo/vonic" target="_blank" rel="noopener">vonic</a> ★1913 - 快速构建移动端单页应用</li><li><a href="https://github.com/monterail/vue-multiselect" target="_blank" rel="noopener">vue-multiselect</a> ★1539 - Vue.js选择框解决方案</li><li><a href="https://github.com/egoist/eme" target="_blank" rel="noopener">eme</a> ★1529 - 优雅的Markdown编辑器</li><li><a href="https://github.com/taylorchen709/vueAdmin" target="_blank" rel="noopener">vueAdmin</a> ★1455 - 基于vuejs2和element的简单的管理员模板</li><li><a href="https://github.com/pi0/bootstrap-vue" target="_blank" rel="noopener">bootstrap-vue</a> ★1267 - 应用于Vuejs2的Twitter的Bootstrap 4组件</li><li><a href="https://github.com/David-Desmaisons/Vue.Draggable" target="_blank" rel="noopener">Vue.Draggable</a> ★1191 - 实现拖放和视图模型数组同步</li></ul><p>[详情地址][<a href="https://blog.csdn.net/osdfhv/article/details/78892477" target="_blank" rel="noopener">https://blog.csdn.net/osdfhv/article/details/78892477</a>]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ElemeFE/element&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;element&lt;/a&gt; ★13489 - 饿了么出品的Vue2的web UI工具套件&lt;/li&gt;
&lt;li&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="-插件" scheme="https://tianjiec.top/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>react常用插件</title>
    <link href="https://tianjiec.top/2019/02/06/react%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://tianjiec.top/2019/02/06/react常用插件/</id>
    <published>2019-02-06T12:43:32.000Z</published>
    <updated>2019-02-06T12:44:32.466Z</updated>
    
    <content type="html"><![CDATA[<p>axios(http请求模块，可用于前端任何场景，很强大)<br>echarts-for-react(可视化图表，别人基于react对echarts的封装，足够用了)<br>recharts(另一个基于react封装的图表，个人觉得是没有echarts好用)<br>nprogress(顶部加载条，蛮好用)<br>react-draft-wysiwyg(别人基于react的富文本封装，如果找到其他更好的可以替换)<br>react-draggable(拖拽模块，找了个简单版的)<br>screenfull(全屏插件)<br>photoswipe(图片弹层查看插件，不依赖jQuery，还是蛮好用)<br>animate.css(css动画库)<br>redux Web 应用是一个状态机，视图与状态是一一对应的.所有的状态，保存在一个对象里面<br>redux-logger 日志<br>Reselect 记忆组件<br>redux-thunk 为了解决异步action的问题<br>redux-saga 为了解决异步action的问题<br>react-router-redux 保持路由与应用状态(state)同步</p><p>react-router-dom</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;axios(http请求模块，可用于前端任何场景，很强大)&lt;br&gt;echarts-for-react(可视化图表，别人基于react对echarts的封装，足够用了)&lt;br&gt;recharts(另一个基于react封装的图表，个人觉得是没有echarts好用)&lt;br&gt;npro
      
    
    </summary>
    
    
      <category term="-插件" scheme="https://tianjiec.top/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>React项目</title>
    <link href="https://tianjiec.top/2019/01/16/React%E9%A1%B9%E7%9B%AE/"/>
    <id>https://tianjiec.top/2019/01/16/React项目/</id>
    <published>2019-01-16T12:19:48.000Z</published>
    <updated>2019-01-16T13:11:03.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、初始化项目"><a href="#一、初始化项目" class="headerlink" title="一、初始化项目"></a>一、初始化项目</h2><p>初始化            create-react-app react-pro</p><p>抽离配置文件        yarn eject</p><p>安装相关依赖        cnpm install node-sass -D     、    cnpm i redux redux-thunk react-redux axios -S</p><h2 id="二、搭建项目结构-创建-Store"><a href="#二、搭建项目结构-创建-Store" class="headerlink" title="二、搭建项目结构 创建 Store"></a>二、搭建项目结构 创建 Store</h2><p>删除无用文件</p><h3 id="搭建项目结构："><a href="#搭建项目结构：" class="headerlink" title="搭建项目结构："></a>搭建项目结构：</h3><p>src        /assert</p><p>​        /components    /commons</p><p>​                        /pages</p><p>​                        /template-css</p><p>​                            index.js</p><p>​                            index.scss</p><p>​        /modules</p><p>​                        rem.js : 用来定义html字体，实现rem布局</p><p>​                        /axios-util</p><p>​                            get.js、post.js、index.js：提供请求数据方法</p><p>​                        /groups</p><p>​                            actionCreators.js：把所有actionCreators 这回合到这里 </p><p>​                            index.js：把react-redux的connect要处理的代码封装到这里，</p><p>​                            调用的时候 通过传参数决定 容器props的数据 和方法</p><p>​        /store（redux仓库配置）</p><p>​                        /commons(state.js, actionCreator.js, reducer.js, const.js)</p><p>​                        /index.js : 借助reducer创建 store</p><p>​                        /reducer.js :总reducer，聚合模块的reducer(conbineReducer({commons}))</p><p>​        App.js</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、初始化项目&quot;&gt;&lt;a href=&quot;#一、初始化项目&quot; class=&quot;headerlink&quot; title=&quot;一、初始化项目&quot;&gt;&lt;/a&gt;一、初始化项目&lt;/h2&gt;&lt;p&gt;初始化            create-react-app react-pro&lt;/p&gt;
&lt;p&gt;抽
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react-router</title>
    <link href="https://tianjiec.top/2019/01/14/react-router/"/>
    <id>https://tianjiec.top/2019/01/14/react-router/</id>
    <published>2019-01-14T12:46:05.000Z</published>
    <updated>2019-01-14T12:46:25.211Z</updated>
    
    <content type="html"><![CDATA[<h4 id="React-router-4"><a href="#React-router-4" class="headerlink" title="React-router 4+"></a>React-router 4+</h4><p>在这里，我们学react-router 4.0版本，需要注意的是，在4.0中，路由的搭建更灵活，我们不会基于全局的对于路由进行管理，而是在使用的时候进行路由的配置</p><p>我们需要下载的也不是react-router了，而是 react-router-dom</p><p><a href="https://www.cnblogs.com/zhanghuiming/p/7592132.html" target="_blank" rel="noopener">文档</a></p><ol><li><p>首先现在最外层包裹上Router，Router分为两种：BrowserRouter/HashRouter</p><p>BrowserRouter监听的是地址栏path的变化，HashRouter监听的是hash值的变化，注意HashRouter在某些时候会报一个警告，不允许重复跳转</p><p>  使用BrowserRouter需要后端去进行一个配置</p></li><li><p>在需要切换路由的时候，引入Route，path指定路径，component指定要渲染的组件，render可以传入一个函数，在这里逻辑判断之后再去返回一个组件，exact属性设置之后，只有完全匹配之后才能使用</p></li><li><p>switch 里面只运行渲染一个路由，可以有效的防止同级路由多次渲染</p></li></ol><switch><br>       <route exact="" path="/" component="{Home}"><br><br>       <route path="/render" render="{()" ==""> {<br>           //做出一些逻辑操作之后，返回一个组件<br>           return <div classname="content">render</div><br>       }} /&gt;<br><br>       <route path="/a/b" render="{()" ==""> {<br>           //做出一些逻辑操作之后，返回一个组件<br>           return <div classname="content">ab</div><br>       }} /&gt;<br><br>       <route path="/a" render="{()" ==""> {<br>           //做出一些逻辑操作之后，返回一个组件<br>           return <div classname="content">a</div><br>       }} /&gt;<br></route></route></route></route></switch><ol><li><p>重定向，可以使用Redirect组件，添加from、to属性进行重定向跳转</p></li><li><p>react-router中提供了Link和NavLink，都可以使用to属性进行跳转，NavLink可以对现在路由做出判断后给a标签加上样式或者类名，exact完全匹配</p></li><li><p>路由传参数,react-router4里只有一种参数就是路由参数，需要配置 /detail/:id,而query参数能传，但是传的时候，和取的 时候都没有对应的api来使用</p><p>它们都可以在this.props中的match、location里得到</p></li><li><p>withRouter高阶组件.高阶组件：就是一个函数，任务是为其他的组件添加一些属性和方法api，例如connect，可以将store中的一些东西安装到新生成的容器组件上   withRuter(App)    </p><p>withRouter可以根据传入的组件生成一个新的组件，并且为新组件添加上router相关的api</p></li><li><p>编程式导航： 在组件中获取到history的api进行跳转，如果是路由组件，直接从this.props中取出，如果不是的话，可以让外面的路由组件传入，或者可以使用withRouter高阶组件处理之后使用</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;React-router-4&quot;&gt;&lt;a href=&quot;#React-router-4&quot; class=&quot;headerlink&quot; title=&quot;React-router 4+&quot;&gt;&lt;/a&gt;React-router 4+&lt;/h4&gt;&lt;p&gt;在这里，我们学react-router 
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react-pro</title>
    <link href="https://tianjiec.top/2019/01/14/react-pro/"/>
    <id>https://tianjiec.top/2019/01/14/react-pro/</id>
    <published>2019-01-14T12:45:27.000Z</published>
    <updated>2019-01-14T12:45:42.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react项目搭建流程"><a href="#react项目搭建流程" class="headerlink" title="react项目搭建流程"></a>react项目搭建流程</h2><p>1.初始化项目  create-react-app react-pro<br>  抽离配置文件  yarn eject<br>  安装相关依赖<br>  yarn add node-sass -D<br>  yarn add redux redux-thunk react-redux axios -S</p><ol><li><p>搭建项目结构  并且  创建Store<br>src/assets<br>   /stylesheets/main.scss(_base.scss,_common.scss,_mixin.scss,_reset.scss)<br>   /components/commons<br>​              /pages<br>​              /template<br>​              /template-css<br>​               index.js<br>​               index.scss<br>   /store/commons(state.js,actionCreators.js,reducer.js,const.js)<br>​         /index.js (createStore(reducer,applyMiddlermare(thunk)))<br>​         /reducer.js (combineReducers({commons}))</p><p>   /modules/rem.js<br>​           /axios-util/</p></li><li><p>rem设置</p></li></ol><ol><li><p>配置axios<br><a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">https://www.kancloud.cn/yunye/axios/234845</a></p><p>src/modules/axios-util<br>​          (get.js/post.js/index.js)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//index.js文件</span><br><span class="line">import Post from &quot;./post&quot;</span><br><span class="line">import Get from &quot;./get&quot;</span><br><span class="line">import &#123;Component&#125; from &quot;react&quot;</span><br><span class="line">//方便在react组件中直接通过this.$post/this.$get直接请求数据</span><br><span class="line">Component.prototype.$post = Post;</span><br><span class="line">Component.prototype.$get = Get;</span><br><span class="line">//为了方便其他地方去使用请求，例如非组件的模块  actionCreators?可以发送异步请求</span><br><span class="line">export &#123;</span><br><span class="line">      Post,</span><br><span class="line">      Get</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一级路由的配置<br>cnpm install react-router-dom -S<br>  1)首先现在最外层包裹上Router，Router分为两种：BrowserRouter/HashRouter<br>  2)在需要切换路由的时候，引入Route，path指定路径，component指定要渲染的组件<br> exact属性设置之后，只有完全匹配之后才能使用<br>  3)switch 里面只运行渲染一个路由，可以有效的防止同级路由多次渲染</p>   <switch><br>​         <route path="/" component="{Home}" exact=""><br>​         <route path="/list" component="{List}"><br>​         <route path="/buycar" component="{BuyCar}"><br>​         <route path="/mine" component="{Mine}"><br>   </route></route></route></route></switch><p>   renderRoutes(){<br>   let {routes} = this.props;<br>   return (<br>​         <switch><br>​         {<br>​         routes.map(item=&gt;(<route key="{item.id}" path="{item.path}" component="{item.component}" exact="{item.exact}">))<br>​         }<br>​         </route></switch><br>   )<br>   }</p></li><li><p>AppFooter的设置<br>将通用的AppFooter放入在commons文件夹里面<br>用到AppFooter了，将他放入哪里呢？<br>1）第一种放入App.js文件里面 我们需要对于不需要底部的例如mine不需要，单独处理<br>2）第二种哪里需要直接扔哪里</p></li></ol><p>思考？<br>​      把AppFooter放入App.js文件里面，那么所有的页面都会有footer了,如果mine组件不希望有footer，怎么处理？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">让App组件监听路由的变化，然后做出判断，选择性的去渲染AppFooter</span><br><span class="line"></span><br><span class="line">*Mine组件是路由组件，app组件不是路由组件</span><br><span class="line">*Mine组件的属性上后history/location/match,app组件上没有</span><br><span class="line">-&gt;路由自身的属性上有history/location/match这些属性！</span><br><span class="line"></span><br><span class="line">*当路由切换的时候，App组件render函数会重新执行</span><br><span class="line">*只有属性或者状态改变的时候，render函数才会重新执行</span><br><span class="line">*发现app组件没有状态，属性也没用发生改变（componentWillReceiveProps不会执行），那为什么它的render函数会重新执行呢？</span><br><span class="line">*原因就是父组件Router的属性或者状态发生变化了，render了，导致子组件APP也进行了渲染，所以App的render函数会重新执行！可不可以在shouldComponentUpdate钩子函数里面进行状态的更改呢？不可以的，因为在这里设置状态，会导致死循环！</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*当hash值变化的时候，Mine组件的render函数会重新执行</span><br><span class="line">*只有属性或者状态更改的时候render函数才会重新执行</span><br><span class="line">*Mine组件没有状态，但是发现componentWillReceiveProps钩子函数每当路由变化的时候会重新执行</span><br><span class="line">-&gt;路由变化的时候，Mine组件的属性就会发生变化</span><br><span class="line">-&gt;路由变化的时候路由组件的属性会发生变化，如果我们想在路由组件中监听路由的变化，只需要在componentWillReceiveProps里面写代码即可</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*问题是： 路由组件可以监听路由的变化，但是app组件不是路由组件，如何也能让他监听路由的变化呢？</span><br><span class="line">*只要App组件外面也套一个Route路由组件，就可以监听到路由的变化了！</span><br><span class="line">*解决办法  需要引入withRouter,作用就是将不是路由组件的普通组件变成伪路由组件，不会跳转，但是呢，可以监听到路由的变化！     </span><br><span class="line">-&gt;只要引入withRouter,就可以变成伪路由组件，不是真正的路由组件，但是Route相关的属性或者方法。</span><br></pre></td></tr></table></figure><p>​<br>​       </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;react项目搭建流程&quot;&gt;&lt;a href=&quot;#react项目搭建流程&quot; class=&quot;headerlink&quot; title=&quot;react项目搭建流程&quot;&gt;&lt;/a&gt;react项目搭建流程&lt;/h2&gt;&lt;p&gt;1.初始化项目  create-react-app react-pr
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react相关知识点</title>
    <link href="https://tianjiec.top/2019/01/14/react%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://tianjiec.top/2019/01/14/react相关知识点/</id>
    <published>2019-01-14T12:42:35.000Z</published>
    <updated>2019-01-14T12:43:23.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React相关知识点"><a href="#React相关知识点" class="headerlink" title="React相关知识点"></a>React相关知识点</h2><p>React核心是组件！<br>React精髓是函数式编程！</p><p>1.react和vue对比：<br>   vue状态改变，只改变自己的视图<br>   vue很多的思想都是借鉴的react组件，并且又做了一些优化<br>   核心库都关注与视图层</p><p>2.React项目开源时间是：41395</p><p>3.React 16 将提供一个内置函数 componentDidCatch，如果 render() 函数抛出错误，则会触发该函数<br>componentDidCatch钩子函数是当项目发生错误的时候触发的</p><p>4.Redux中哪个方法收到action？<br>  dispatch方法负责收到、派发action (dispatch(action))<br>  actionCreator负责创建action<br>  reducer负责接收store传递过来的action</p><p>5.react－router4.0 核心对象包含Router/BrowserRouter/hashRouter/Route/Switch/withRouter等</p><p>6.react-router2.0中路由容器是｛this.props.children｝</p><ol><li>react中key值作用：<br>keys是什么帮助 React 跟踪哪些项目已更改、添加或从列表中删除。<br>每个 keys 在兄弟元素之间是独一无二的。<br>keys 使处理列表时更加高效，因为 React 可以使用子元素上的 keys 快速知道元素是新的还是在比较树时才被移动。<br>keys 不仅使这个过程更有效率，而且没有 keys ，React 不知道哪个本地状态对应于移动中的哪个项目。</li></ol><p>8.无状态组件与有状态的组件的区别是什么？<br>  没有状态，没有生命周期，只是简单的接受 props 渲染生成 DOM 结构。<br>  无状态组件非常简单，开销很低，如果可能的话尽量使用无状态组件。<br>  无状态的函数创建的组件是无状态组件，它是一种只负责展示的纯组件，<br>  无状态组件可以使用纯函数来实现。</p><p>  无状态组件定义函数方式如：（就是一个函数，根据接受到的属性来做不同的操作渲染）<br>​    const app = (props)=&gt;{return (<div>aaa</div>)}</p><p>9.在自定义的React组件当中，哪个生命周期函数必写？render函数</p><h2 id="flux知识点汇总：-https-www-cnblogs-com-fliu-articles-5245923-html"><a href="#flux知识点汇总：-https-www-cnblogs-com-fliu-articles-5245923-html" class="headerlink" title="flux知识点汇总：[https://www.cnblogs.com/fliu/articles/5245923.html]"></a>flux知识点汇总：[<a href="https://www.cnblogs.com/fliu/articles/5245923.html" target="_blank" rel="noopener">https://www.cnblogs.com/fliu/articles/5245923.html</a>]</h2><p>1.flux中能够调用setState方法的对象是(顶层容器)<br>2.Flux架构包含哪些部分?<br>​    View： 视图层<br>​    Action（动作）：视图层发出的消息（比如mouseClick）<br>​    Dispatcher（派发器）：用来接收Actions、执行回调函数、是中心枢纽<br>​    Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面</p><ol><li>Flux 的最大特点，就是数据的”单向流动”。<br>用户访问 View<br>View 发出用户的 Action<br>Dispatcher 收到 Action，要求 Store 进行相应的更新<br>Store 更新后，发出一个”change”事件<br>View 收到”change”事件后，更新页面</li></ol><p>可以通过redux与flux架构进行react的状态管理</p><h2 id="虚拟dom理解？-https-www-jianshu-com-p-616999666920"><a href="#虚拟dom理解？-https-www-jianshu-com-p-616999666920" class="headerlink" title="虚拟dom理解？[https://www.jianshu.com/p/616999666920]"></a>虚拟dom理解？[<a href="https://www.jianshu.com/p/616999666920" target="_blank" rel="noopener">https://www.jianshu.com/p/616999666920</a>]</h2><p>所谓virtual，指的是对真实DOM的一种模拟。相对于直接操作真实的DOM结构，我们构建一棵虚拟的树，将各种数据和操作直接应用在这棵虚拟的树上，然后再将对虚拟的树的修改应用到真实的DOM结构上。<br>通过虚拟dom可能会减少真实DOM操作次数，带来性能上的提升，即使我们频繁操作虚拟DOM，我们只需要一定时刻一次性同步修改到真实DOM上即可.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React相关知识点&quot;&gt;&lt;a href=&quot;#React相关知识点&quot; class=&quot;headerlink&quot; title=&quot;React相关知识点&quot;&gt;&lt;/a&gt;React相关知识点&lt;/h2&gt;&lt;p&gt;React核心是组件！&lt;br&gt;React精髓是函数式编程！&lt;/p&gt;
&lt;p&gt;1
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react学习2</title>
    <link href="https://tianjiec.top/2019/01/12/react%E5%AD%A6%E4%B9%A02/"/>
    <id>https://tianjiec.top/2019/01/12/react学习2/</id>
    <published>2019-01-12T09:37:50.000Z</published>
    <updated>2019-01-12T09:38:55.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React框架学习"><a href="#React框架学习" class="headerlink" title="React框架学习"></a>React框架学习</h1><h5 id="React中的事件对象"><a href="#React中的事件对象" class="headerlink" title="React中的事件对象"></a>React中的事件对象</h5><p>react中对于事件进行了处理，解决了一些兼容性问题，react事件对象上面挂载着nativeEvent，这个就是原生的事件对象</p><p>react对事件对象做了优化，如果不取值的话，值都是null</p><h5 id="React中组件通信方式"><a href="#React中组件通信方式" class="headerlink" title="React中组件通信方式"></a>React中组件通信方式</h5><p>父组件与子组件通信</p><ol><li>父组件将自己的状态传递给子组件，子组件当做属性来接收，当父组件更改自己状态的时候，子组件接收到的属性就会发生改变</li><li>父组件利用ref对子组件做标记，通过调用子组件的方法以更改子组件的状态..</li></ol><p>子组件与父组件通信</p><p>父组件将自己的某个方法传递给子组件，在方法里可以做任意操作，比如可以更改状态，子组件通过this.props接收到父组件的方法后调用。</p><p>兄弟组件通信</p><p>在react没有类似vue中的事件总线来解决这个问题，我们只能借助它们共同的父级组件来实现，将非父子关系装换成多维度的父子关系</p><p>复杂的非父子组件通信在react中很难处理，多组件间的数据共享也不好处理，所以我们会使用flux、redux来实现这样的功能，解决这个问题</p><h5 id="React中表单元素默认值"><a href="#React中表单元素默认值" class="headerlink" title="React中表单元素默认值"></a>React中表单元素默认值</h5><p>在react中，如果需要 给表单元素设置默认value或者checked，需要设置成defaultValue/defaultChecked，否则设置默认值以后，用户无法更改</p><h5 id="React-keys"><a href="#React-keys" class="headerlink" title="React-keys"></a>React-keys</h5><p>我们在react中循环列表数据的时候，需要对循环出来的虚拟jsx节点传入上key这个数据，</p><p>Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。</p><h5 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h5><p>就是如果有多个组件共享一个数据，把这个数据放到共同的父级组件中来管理</p><h5 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h5><p>在vue中有一个内容分发叫slot，在react中也有实现，就是可以在使用组件的时候，在组件标签内部放入一些不固定的内容，在该组件的模板中，只有{this.props.children}来表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//App</span><br><span class="line">&lt;Dialog</span><br><span class="line">close=&#123;this.ToggleDialogShow&#125; isShow=&#123;isDialogShow&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;ContentA/&gt;</span><br><span class="line">    &lt;ContentA/&gt;</span><br><span class="line">    &lt;ContentB/&gt;</span><br><span class="line">&lt;/Dialog&gt;</span><br><span class="line"></span><br><span class="line">//dialog</span><br><span class="line">&lt;div style=&#123;&#123;display:isShow?&apos;block&apos;:&apos;none&apos;&#125;&#125; className=&quot;dialog&quot;&gt;</span><br><span class="line">    &lt;Button handler=&#123;this.props.close&#125; text=&quot;关闭&quot;/&gt;   </span><br><span class="line">    &#123;this.props.children&#125;//这里就是slot</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React框架学习&quot;&gt;&lt;a href=&quot;#React框架学习&quot; class=&quot;headerlink&quot; title=&quot;React框架学习&quot;&gt;&lt;/a&gt;React框架学习&lt;/h1&gt;&lt;h5 id=&quot;React中的事件对象&quot;&gt;&lt;a href=&quot;#React中的事件对象&quot; c
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react学习1</title>
    <link href="https://tianjiec.top/2019/01/12/react%E5%AD%A6%E4%B9%A01/"/>
    <id>https://tianjiec.top/2019/01/12/react学习1/</id>
    <published>2019-01-12T09:37:43.000Z</published>
    <updated>2019-01-12T09:38:19.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React框架学习"><a href="#React框架学习" class="headerlink" title="React框架学习"></a>React框架学习</h1><h3 id="React的起源和发展"><a href="#React的起源和发展" class="headerlink" title="React的起源和发展"></a>React的起源和发展</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">起初facebook在建设instagram（图片分享）的时候嘞，因为牵扯到一个东西叫数据流，那为了处理数据流并且还要考虑好性能方面的问题嘞，Facebook开始对市场上的各种前端MVC框架去进行一个研究，然而并没有看上眼的，于是Facebook觉得，还是自己开发一个才是最棒的，那么他们决定抛开很多所谓的“最佳实践”，重新思考前端界面的构建方式，他们就自己开发了一套，果然大牛创造力还是很强大的。</span><br></pre></td></tr></table></figure><h3 id="React的出发点"><a href="#React的出发点" class="headerlink" title="React的出发点"></a>React的出发点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基于HTML的前端界面开发正变得越来越复杂，其本质问题基本都可以归结于如何将来自于服务器端或者用户输入的动态数据高效的反映到复杂的用户界面上。而来自Facebook的React框架正是完全面向此问题的一个解决方案，按官网描述，其出发点为：用于开发数据不断变化的大型应用程序（Building large applications with data that changes over time）。相比传统型的前端开发，React开辟了一个相当另类的途径，实现了前端界面的高性能高效率开发。</span><br></pre></td></tr></table></figure><h3 id="React与传统MVC的关系"><a href="#React与传统MVC的关系" class="headerlink" title="React与传统MVC的关系"></a>React与传统MVC的关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">轻量级的视图层框架！</span><br><span class="line"></span><br><span class="line">React不是一个完整的MVC框架，最多可以认为是MVC中的V（View），甚至React并不非常认可MVC开发模式；</span><br></pre></td></tr></table></figure><h3 id="React高性能的体现：虚拟DOM"><a href="#React高性能的体现：虚拟DOM" class="headerlink" title="React高性能的体现：虚拟DOM"></a>React高性能的体现：虚拟DOM</h3><p>React高性能的原理：</p><p>在Web开发中我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而复杂或频繁的DOM操作通常是性能瓶颈产生的原因（如何进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标）。</p><p>React为此引入了虚拟DOM（Virtual DOM）的机制：在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。而且React能够批处理虚拟DOM的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从A-B,B-A，React会认为A变成B，然后又从B变成A  UI不发生任何变化，而如果通过手动控制，这种逻辑通常是极其复杂的。</p><p>尽管每一次都需要构造完整的虚拟DOM树，但是因为虚拟DOM是内存数据，性能是极高的，部而对实际DOM进行操作的仅仅是Diff分，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体的DOM元素，而只需要关心在任意一个数据状态下，整个界面是如何Render的。数据驱动，声明式</p><h3 id="React的特点和优势"><a href="#React的特点和优势" class="headerlink" title="React的特点和优势"></a>React的特点和优势</h3><ol><li>虚拟DOM</li></ol><p>我们以前操作dom的方式是通过document.getElementById()的方式，这样的过程实际上是先去读取html的dom结构，将结构转换成变量，再进行操作</p><p>而reactjs定义了一套变量形式的dom模型，一切操作和换算直接在变量中，这样减少了操作真实dom，性能真实相当的高，和主流MVC框架有本质的区别，并不和dom打交道</p><ol><li>组件系统</li></ol><p>react最核心的思想是将页面中任何一个区域或者元素都可以看做一个组件 component</p><p>那么什么是组件呢？  .vue  template script style lang=”scss” node-sass sass-loader</p><p>组件指的就是同时包含了html、css、js、image元素的聚合体</p><p>使用react开发的核心就是将页面拆分成若干个组件，并且react一个组件中同时耦合了css、js、image，这种模式整个颠覆了过去的传统的方式</p><ol><li>单向数据流  <father><son name=""></son></father>父子通信  vuex state—&gt;component(this.$store.state) —-&gt; actions（{commit}）(this.$store.dispatch()) —-&gt; mutations(this.$store.commit()) —–&gt; state</li></ol><p>其实reactjs的核心内容就是数据绑定，所谓数据绑定指的是只要将一些服务端的数据和前端页面绑定好，开发者只关注实现业务就行了  </p><ol><li>JSX  语法  </li></ol><p>在vue中，我们使用render函数来构建组件的dom结构性能较高，因为省去了查找和编译模板的过程，但是在render中利用createElement创建结构的时候代码可读性较低，较为复杂，此时可以利用jsx语法来在render中创建dom，解决这个问题，但是前提是需要使用工具来编译jsx</p><h3 id="创建第一个组件-15-16"><a href="#创建第一个组件-15-16" class="headerlink" title="创建第一个组件  15.  16"></a>创建第一个组件  15.  16</h3><p>react开发需要引入多个依赖文件：react.js、react-dom.js，分别又有开发版本和生成版本</p><p>在这里一开始，我们先学习es5的组件写法，React.createClass，需要引入的是15+</p><p>react.js中有React对象，帮助我们创建组件等功能</p><p>react-dom.js中有ReactDOM对象，渲染组件的虚拟dom为真实dom的爆发功能<br>​<br>在编写react代码的时候会大量的使用到jsx代码，但是需要编译：</p><ol><li>浏览器端编译，通过引入browser、babel等对引入的script内的代码做编译</li><li>利用webpack等开发环境进行编译，将编译好的文件引入到应用中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//创建组件</span><br><span class="line">var Hello = React.createClass(&#123;</span><br><span class="line">    render:function () &#123;</span><br><span class="line">        //render函数和Vue组件里的render完全一样，在vue组件中可以不用编写render函数，这个时候可以使用template模板来编写组件的虚拟dom结构，然后vue组件会自动讲模板compile成虚拟dom结构放入到render中执行，但是react需要编写render函数</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            //jsx语法</span><br><span class="line">            &lt;div&gt;asdasd&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//利用ReactDOM对象的render方法将组件渲染到某个节点里</span><br><span class="line">ReactDOM.render(&lt;Hello/&gt;,document.getElementById(&quot;app&quot;))</span><br></pre></td></tr></table></figure><p>组件是通过React.createClass创建的（ES5），在es6中直接通过class关键字来创建</p><p>组件其实就是一个构造器,每次使用组件都相当于在实例化组件</p><p>react的组件必须使用render函数来创建组件的虚拟dom结构</p><p>组件需要使用ReactDOM.render方法将其挂载在某一个节点上</p><p>组件的首字母必须大写</p><h3 id="JSX语法糖"><a href="#JSX语法糖" class="headerlink" title="JSX语法糖"></a>JSX语法糖</h3><p>JSX是一种语法，全称：javascript xml</p><p>JSX语法不是必须使用的，但是因为使用了JSX语法之后会降低我们的开发难度，故而这样的语法又被成为语法糖</p><p>在不使用JSX的时候，需要使用React.createElement来创建组件的dom结构，但是这样的写法虽然不需要编译，但是维护和开发的难度很高，且可读性很差</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var world = React.createElement(&apos;h1&apos;,&#123;className:&apos;abc&apos;,id:&apos;haha&apos;&#125;,[</span><br><span class="line">    React.createElement(&apos;span&apos;,null,&apos;Hello&apos;),</span><br><span class="line">    React.createElement(&apos;mark&apos;,null,&apos;React&apos;)</span><br><span class="line">])</span><br><span class="line">            </span><br><span class="line">//利用ReactDOM对象的render方法将组件渲染到某个节点里</span><br><span class="line">ReactDOM.render(world,document.getElementById(&quot;app1&quot;))</span><br></pre></td></tr></table></figure><p>及时使用了JSX语法了之后，也是需要将其编译成原生的createElement的</p><p>JSX就是在js中使用的xml，但是，这里的xml不是真正的xml，只能借鉴了一些xml的语法，例如：</p><p>最外层必须有根节点、标签必须闭合</p><p>jsx借鉴xml的语法而不是html的语法原因：xml要比html严谨，编译更方便</p><h3 id="组件dom添加样式"><a href="#组件dom添加样式" class="headerlink" title="组件dom添加样式"></a>组件dom添加样式</h3><p>在react里表达式的符号是 “{  }”,作用和vue的表达式作用是一样的</p><p>想给虚拟dom添加行内样式，需要使用表达式传入样式对象的方式来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style = &#123; &#123;color:&apos;red&apos;,fontSize:2+&apos;em&apos;&#125; &#125;&gt;Hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>行内样式需要写入一个样式对象，而这个样式对象的位置可以放在很多地方，例如React.createClass的配置项中、render函数里、组件原型上、外链js文件中</p><p>React推荐我们使用行内样式，因为react觉得每一个组件都是一个独立的整体</p><p>其实我们大多数情况下还是大量的在为元素添加类名、id以使用某些样式，但是需要注意的是，class需要写成className（因为毕竟是在写类js代码，会收到js规则的现在，而class是关键字）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p className=&quot;bg-p&quot; id=&quot;myp&quot; style = &#123; this.style &#125;&gt;Hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="React-Event"><a href="#React-Event" class="headerlink" title="React Event"></a>React Event</h3><p>在react中，我们想要给组件的dom添加事件的话，也是 需要在行内添加的方式，事件名字需要写成小驼峰的方式，值利用表达式传入一个函数即可</p><p>注意，在没有渲染的时候，页面中没有真实dom，所以是获取不到dom的</p><p>给虚拟dom结构中的节点添加样式。在行内添加,写成驼峰形式，值是一个函数名，需要用{}包裹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">handleClick:function () &#123;</span><br><span class="line">    alert(1)</span><br><span class="line">&#125;,</span><br><span class="line">render:function () &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick = &#123;this.handleClick&#125; className=&quot;click-btn&quot;&gt;click&lt;/button&gt;</span><br><span class="line">            &lt;button onDoubleClick = &#123;this.handleClick&#125; className=&quot;click-btn&quot;&gt;click&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h3><p>将一个组件渲染到某一个节点里的时候，会将这个节点里原有内容覆盖</p><p>组件嵌套的方式就是将子组件写入到父组件的模板中去，且react没有Vue中的内容分发机制（slot），所以我们在一个组件的模板中只能看到父子关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var Hello = React.createClass(&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;h1&gt;</span><br><span class="line">                Hello </span><br><span class="line">                &lt;World&gt;&lt;/World&gt;</span><br><span class="line">            &lt;/h1&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">var World = React.createClass(&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;mark&gt;</span><br><span class="line">                World-&lt;Person/&gt; </span><br><span class="line">            &lt;/mark&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//无状态组件</span><br><span class="line">var Person =function()&#123;</span><br><span class="line">    return (&lt;mark&gt;lilei&lt;/mark&gt;)</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;Hello/&gt;,app)</span><br></pre></td></tr></table></figure><blockquote><p>注意，react中jsx里的注释要写成{/<em>  </em>/}的方式</p></blockquote><h3 id="React中的数据承载-Props-State"><a href="#React中的数据承载-Props-State" class="headerlink" title="React中的数据承载-Props/State"></a>React中的数据承载-Props/State</h3><p>数据驱动、声明式渲染：</p><p>任意的视图变化都应该由数据来控制</p><p>//$(“.a”).html(0)</p><p>var num = 0<br>function renderNum () { $(“.a”).html(num) }</p><p>React也是基于数据驱动(声明式)的框架，组件中必然需要承载一些数据，在react中起到这个作用的是属性和状态（props &amp; state）</p><ol><li>属性（props）  在组件外部传入，或者内部设置，组件内部通过this.props获得</li><li>状态（state）  在组件内部设置或者更改，组件内部通过this.state获得</li></ol><h5 id="属性-props"><a href="#属性-props" class="headerlink" title="属性(props)"></a>属性(props)</h5><p>属性一般是外部传入的，组件内部也可以通过一些方式来初始化的设置，属性不能被组件自己更改</p><p>属性是描述性质、特点的，组件自己不能随意更改</p><p>使组件拥有属性的方式：</p><ol><li>在装载（mount）组件的时候给组件传入</li></ol><p>传入数据的时候，除了字符串类型，其他的都应该包上表达式，但是为了规整，所有的数据传递，最好都包上{}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var Gouzi = React.createClass(&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;我的名字：&#123;this.props.name&#125;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;我的性别：&#123;this.props.sex&#125;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;我的年龄：&#123;this.props.age&#125;&lt;/p&gt;  </span><br><span class="line">                &lt;p&gt;我的父亲是：&#123;this.props.father&#125;&lt;/p&gt;                                              </span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let info = &#123;</span><br><span class="line">    sex:&apos;male&apos;,</span><br><span class="line">    father:&apos;狗爸&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Gouzi &#123;...info&#125; name=&#123;&quot;大狗子&quot;&#125; age=&#123;26&#125;/&gt;,app)</span><br></pre></td></tr></table></figure><ol><li>父组件给子组件传入</li></ol><p>父组件在嵌套子组件的时候为子组件传入，传入的方式和上面的方式一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//父组件的render函数</span><br><span class="line">render()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;父组件：&lt;/p&gt;</span><br><span class="line">            &lt;hr/&gt;</span><br><span class="line">            &lt;Son name=&#123;&apos;大狗子&apos;&#125;/&gt;</span><br><span class="line">            &lt;Son name=&#123;&apos;二狗子&apos;&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>子组件自己设置</li></ol><p>子组件可以通过getDefaultProps来设置默认的属性</p><p>getDefaultProps的值是函数，这个函数会返回一个对象，我们在这里对象里为组件设置默认属性</p><p>这种方式设置的属性优先级低，会被外部传入的属性值所覆盖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getDefaultProps:function () &#123;</span><br><span class="line">    console.log(&apos;getDefaultProps&apos;)</span><br><span class="line">    return &#123;</span><br><span class="line">        name:&apos;狗爸&apos;,</span><br><span class="line">        sonname:&apos;二狗子&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">//render</span><br><span class="line">&lt;p&gt;我是&#123;this.props.sonname&#125;的父亲-&#123;this.props.name&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>根据属性或状态，我们可以在render中的表达式里做一些逻辑判断，可以使用||、三元表达式、子执行函数等等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">getName()&#123;</span><br><span class="line">    return this.props.name || &apos;野狗子&apos;</span><br><span class="line">&#125;,</span><br><span class="line">render:function () &#123;</span><br><span class="line">    let &#123;name&#125; = this.props</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;我是子组件-&#123;this.props.name || &apos;野狗子&apos;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;我是子组件-&#123;this.props.name?this.props.name:&apos;野狗子&apos;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;我是子组件-&#123;this.getName()&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;我是子组件-&#123;(function (obj) &#123;</span><br><span class="line">            return obj.props.name || &apos;野狗子&apos;</span><br><span class="line">        &#125;)(this)&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="状态-state"><a href="#状态-state" class="headerlink" title="状态(state)"></a>状态(state)</h5><p>状态就是组件描述某种显示情况的数据，由组件自己设置和更改，也就是说由组件自己维护，使用状态的目的就是为了在不同的状态下使组件的显示不同(自己管理)</p><p>在组件中只能通过getInitialState的钩子函数来给组件挂载初始状态,在组件内部通过this.state获取</p><p>this.props和this.state是纯js对象,在vue中，$data属性是利用Object.defineProperty处理过的，更改$data的数据的时候会触发数据的getter和setter，但是react中没有做这样的处理，如果直接更改的话，react是无法得知的，所以，需要使用特殊的更改状态的方法：</p><p>setState(params)</p><p>在setState中传入一个对象，就会将组件的状态中键值对的部分更改，还可以传入一个函数，这个回调函数必须返回像上面方式一样的一个对象，函数可以接收prevState和props</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//1.</span><br><span class="line">let doing = this.state.doing==&apos;学习&apos;+props.knowledge?&apos;玩游戏&apos;:&apos;学习&apos;+props.knowledge</span><br><span class="line">this.setState(&#123;doing&#125;)</span><br><span class="line"></span><br><span class="line">//2.</span><br><span class="line">this.setState((prevState,props)=&gt;&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        doing:prevState.doing==&apos;学习&apos;+props.knowledge?&apos;玩游戏&apos;:&apos;学习&apos;+props.knowledge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="实现下拉菜单的方式"><a href="#实现下拉菜单的方式" class="headerlink" title="实现下拉菜单的方式"></a>实现下拉菜单的方式</h5><ol><li>通过数据来控制元素的行内样式中display的值，或者去控制类名</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul style=&#123;&#123;display:isMenuShow?&apos;block&apos;:&apos;none&apos;&#125;&#125;&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;</span><br><span class="line">...</span><br><span class="line">&lt;ul className=&#123;isMenuShow?&apos;show&apos;:&apos;hide&apos;&#125;&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;</span><br></pre></td></tr></table></figure><ol><li>根据数据控制是否渲染改节点、组件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    isMenuShow?&lt;ul&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;:&apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过ref对dom、组件进行标记，在组件内部通过this.refs获取到之后，进行操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul ref=&apos;content&apos;&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;</span><br><span class="line">...</span><br><span class="line">this.refs.content.style.display = this.state.isMenuShow?&apos;block&apos;:&apos;none&apos;</span><br></pre></td></tr></table></figure><h5 id="属性和状态的对比"><a href="#属性和状态的对比" class="headerlink" title="属性和状态的对比"></a>属性和状态的对比</h5><p>相似点：都是纯js对象，都会触发render更新，都具有确定性（状态/属性相同，结果相同）</p><p>不同点： </p><ol><li>属性能从父组件获取，状态不能</li><li>属性可以由父组件修改，状态不能</li><li>属性能在内部设置默认值 ，状态也可以</li><li>属性不在组件内部修改   ，状态要改</li></ol><p>状态只和自己相关，由自己维护</p><p>属性不要自己修改，可以从父组件获取，也可以给子组件设置</p><p>组件在运行时自己需要修改的数据其实就是状态而已</p><h4 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h4><p>react中组件也有生命周期，也就是说也有很多钩子函数供我们使用，下面是生命周期的图示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./life.jpg" alt="生命周期" title="">                </div>                <div class="image-caption">生命周期</div>            </figure><p>组件是一个构造器，每一次使用组件都相当于在实例化组件，在这个时候，组件就会经历一次生命周期，从实例化实例开始到这个实例销毁的时候，都是一次完整的生命周期</p><p>组件的生命周期，我们会分为三个阶段，初始化、运行中、销毁</p><h5 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h5><ol><li><p>实例化组件之后，组件的getDefaultProps钩子函数会执行</p><p>这个钩子函数的目的是为组件的实例挂载默认的属性</p><p>这个钩子函数只会执行一次，也就是说，只在第一次实例化的时候执行，创建出所有实例共享的默认属性，后面再实例化的时候，不会执行getDefaultProps，直接使用已有的共享的默认属性</p><p>理论上来说，写成函数返回对象的方式，是为了防止实例共享，但是react专门为了让实例共享，只能让这个函数只执行一次</p><p>组件间共享默认属性会减少内存空间的浪费，而且也不需要担心某一个实例更改属性后其他的实例也会更改的问题，因为组件不能自己更改属性，而且默认属性的优先级低。</p></li><li><p>执行getInitialState为实例挂载初始状态，且每次实例化都会执行，也就是说，每一个组件实例都拥有自己独立的状态呢</p></li><li><p>执行componentWillMount，相当于Vue里的created+beforeMount，这里是在渲染之前最后一次更改数据的机会，在这里更改的话是不会触发render的重新执行</p><p>多做一些初始数据的获取</p></li><li><p>执行render，渲染dom</p></li><li><p>执行componentDidMount ，相当于Vue里的mounted,多用于操作真实dom</p></li></ol><h5 id="运行中阶段"><a href="#运行中阶段" class="headerlink" title="运行中阶段"></a>运行中阶段</h5><p>当组件mount到页面中之后，就进入了运行中阶段，在这里有5个钩子函数，但是这5个函数只有在数据（属性、状态）发送改变的时候才会执行</p><ol><li>componentWillReceiveProps</li></ol><p>当父组件给子组件传入的属性改变的时候，子组件的这个函数才会执行</p><p>当执行的时候，函数接收的参数是子组件接收到的新参数，这个时候，新参数还没有同步到this.props上,多用于判断新属性和原有属性的变化后更改组件的状态</p><ol><li><p>接下来就会执行shouldComponentUpdate,这个函数的作用：</p><p>当属性或状态发生改变后控制组件是否要更新，提高性能,返回true就更新，否则不更新，默认返回true</p><p>接收nextProp、nextState，根据根据新属性状态和原属性状态作出对比、判断后控制是否更新</p></li><li><p>componentWillUpdate,在这里，组件马上就要重新render了，多做一些准备工作，千万千万，不要在这里修改状态，否则会死循环<br>相当于Vue中的beforeUpdate</p></li><li><p>render，重新渲染dom</p></li><li><p>componentDidUpdate，在这里，新的dom结构已经诞生了,相当于Vue里的updated</p></li></ol><h5 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h5><p>当组件被销毁之前的一刹那，会触发componentWillUnmount，临死前的挣扎</p><p>相当于Vue里的beforeDestroy，所以说一般会做一些擦屁股的事情</p><p>为什么Vue中有destroyed，而react却没有componentDidUnmount</p><p>Vue在调用$destroy方法的时候就会执行beforeDestroy，然后组件被销毁，这个时候组件的dom结构还存在于页面结构中，也就说如果想要对残留的dom结构进行处理必须在destroyed处理，但是react执行完componentWillUnmount之后把事件、数据、dom都全部处理掉了，所以根本不需要其他的钩子函数了</p><p>怎么样就算组件被销毁：</p><ol><li>当父组件从渲染这个子组件变成不渲染这个子组件的时候，子组件相当于被销毁</li><li>调用ReactDOM.unmountComponentAtNode(node) 方法来将某节点中的组件销毁</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React框架学习&quot;&gt;&lt;a href=&quot;#React框架学习&quot; class=&quot;headerlink&quot; title=&quot;React框架学习&quot;&gt;&lt;/a&gt;React框架学习&lt;/h1&gt;&lt;h3 id=&quot;React的起源和发展&quot;&gt;&lt;a href=&quot;#React的起源和发展&quot; c
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react学习3</title>
    <link href="https://tianjiec.top/2019/01/12/react%E5%AD%A6%E4%B9%A03/"/>
    <id>https://tianjiec.top/2019/01/12/react学习3/</id>
    <published>2019-01-12T09:36:43.000Z</published>
    <updated>2019-01-12T09:36:59.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React框架学习"><a href="#React框架学习" class="headerlink" title="React框架学习"></a>React框架学习</h1><h2 id="开发依赖devDependencies与运行依赖dependencies"><a href="#开发依赖devDependencies与运行依赖dependencies" class="headerlink" title="开发依赖devDependencies与运行依赖dependencies"></a>开发依赖devDependencies与运行依赖dependencies</h2><p>npm自己的文档说dependencies是运行时依赖，devDependencies是开发时的依赖。即devDependencies 下列出的模块，是我们开发时用的，比如 我们安装 js的压缩包gulp-uglify 时，我们采用的是 “npm install –save-dev gulp-uglify ”命令安装，因为我们在发布后用不到它，而只是在我们开发才用到它。<br>dependencies 下的模块，则是我们发布后还需要依赖的模块，譬如像jQuery库或者Angular框架类似的，我们在开发完后后肯定还要依赖它们，否则就运行不了。</p><h3 id="webpack-facebook"><a href="#webpack-facebook" class="headerlink" title="webpack (facebook)"></a>webpack (facebook)</h3><p>前端工程化： npm、cnpm、yarn、bower | grunt 、 gulp 、webpack</p><p>gulp： 基于流的前端自动化构建工具，基于流的任务式的工具</p><p>webpack： 是一款模块化打包工具，webpack是基于配置的，通过配置一些选项来让webpack执行打包任务。</p><p>npm i webpack -g</p><p>npm i webpack-cli -g (4.0+)</p><p>npm i yarn -g    </p><p>webpack在打包的时候，依靠依赖关系图，在打包的时候需要告知webpack两个概念：入口和出口</p><p>一般情况下，我们需要使用webpack.config.js进行配置</p><h5 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h5><p>entry配置项目打包的入口，值可以为单个的字符串执行某一个文件的地址，这个时候该文件就是入口文件，webpack会根据入口文件里各模块间的关系形成依赖关系图，然后根据依赖关系图进行打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry:&apos;./src/app.js&apos;,</span><br><span class="line">output:&#123;</span><br><span class="line">    path:path.join(__dirname,&apos;build&apos;),</span><br><span class="line">    filename:&apos;app.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有的时候我们需要的是多入口，我们就写成数组的形式，数组里的每一个字符串地址指向的都是一个独立的入口，webpack会将这些入口的依赖打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry:[&apos;./src/app.js&apos;,&apos;./src/vendor.js&apos;],</span><br><span class="line">output:&#123;</span><br><span class="line">    path:path.join(__dirname,&apos;build&apos;),</span><br><span class="line">    filename:&apos;[name].js&apos;//不确定名字的时候，这里会打包成main.js</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚才的两种entry配置都只会打包出一个js文件，但是在某一个应用中我们可能需要将js根据依赖关系打包成多个js文件，并且在多页面应用中，我们也确实不可能只使用一个js文件，那么我们就可以使用如下的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">entry:&#123;</span><br><span class="line">    app:&apos;./src/app.js&apos;,</span><br><span class="line">    vendor:&apos;./src/vendor.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line">output:&#123;</span><br><span class="line">    path:path.join(__dirname,&apos;build&apos;),</span><br><span class="line">    filename:&apos;[name]_[hash].js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，因为filename里写成名字是[name],所以会根据entry的配置的键名来为打包出的js文件命名，hash是每次打包的一个随机的hash值，可以用来做版本控制</p><h5 id="output"><a href="#output" class="headerlink" title="output"></a>output</h5><p>在这里我们配置打包输出的一些选项</p><p>filename可以确定打包出来的文件的名字，在里面我们可以使用[name],[hash]这样的占位符</p><p>path配置打包出去的文件的路径，需要是绝对路径</p><h5 id="env"><a href="#env" class="headerlink" title="env"></a>env</h5><p>在命令行或者终端中执行 webpack –env hello命令，就相当于在打包的时候传入一个参数为hello</p><p>在webpack.config.js中可以暴露出一个函数，这个函数就可以接收到env参数，当然函数就可以根据env参数来有选择的返回某一个或多个配置对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = (env)=&gt;&#123;</span><br><span class="line">    if(env==&apos;production&apos;)&#123;</span><br><span class="line">        return productionConfig</span><br><span class="line">    &#125;</span><br><span class="line">    return developmentConfig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>–watch 可以让webpack去监听文件的改变。<br>可以在package.json里的scripts中配置一些快捷操作，通过npm run来运行</p><h5 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h5><p>在webpack编译用的是loader，但是有一些loader无法完成的任务，交由插件（plugin）来完成，插件的时候需要在配置项中配置plugins选项，值是数组，可以放入多个插件的使用，而一般的插件都是一个构造器，我们只需在plugins数组中放入该插件的实例即可</p><p>html-webpack-plugin</p><p>这个插件可以选择是否依据模板来生成一个打包好的html文件，在里面可以配置、title、template、filename、minify等选项，详情请查阅<a href="https://segmentfault.com/a/1190000007294861" target="_blank" rel="noopener">文档</a></p><p>plugins:[<br>​    new HtmlWebpackPlugin({<br>​        template:”./src/index.html”,<br>​        minify:{<br>​            collapseWhitespace:true<br>​        }<br>​    })<br>]</p><h4 id="LOADERS"><a href="#LOADERS" class="headerlink" title="LOADERS"></a>LOADERS</h4><p>在webpack中专门有一些东西用来编译文件、处理文件，这些东西就叫loader，loader的使用就是在配置项中，设置module，在module中设置rules值为数组，在数组里放入多个匹配规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;test:/\.css$/,use:&apos;css-loader&apos;&#125;</span><br><span class="line">    ],</span><br><span class="line">    //before</span><br><span class="line">    loaders:[</span><br><span class="line">        &#123;test:/\.css$/,loader:&apos;css-loader&apos;&#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test为此次匹配要匹配的文件正则规则，use代表要使用的loader</p><p>使用url-loader可以将css中引入的图片（背景图）、js中生成的img图片处理一下，生成到打包目录里</p><p>视图html-withimg-loader可以将html中img标签引入的img图片打包到打包目录</p><p>file-loader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:/\.(png|jpe?g|svg|gif)$/,</span><br><span class="line">    // use:&apos;url-loader?limit=1000&amp;name=images/[hash:8].[name].[ext]&apos;</span><br><span class="line">    use:[</span><br><span class="line">        &#123;</span><br><span class="line">            loader:&apos;url-loader&apos;,</span><br><span class="line">            options:&#123;</span><br><span class="line">                limit:1000,</span><br><span class="line">                name:&apos;/static/images/assets/[hash:8].[name].[ext]&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test:/\.html$/,</span><br><span class="line">    use:&apos;html-withimg-loader&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理css:</p><p>cnpm i css-loader style-loader –save-dev</p><p>配置：</p><p>{<br>​    test:/.css$/,<br>​    use:[‘style-loader’,’css-loader’]<br>}</p><p>注意。webpack中loader的使用是从后往前的</p><p>css-loader可以将引入到js中的css代码给抽离出来，style-loader可以将抽离出来的css代码放入到style标签中</p><p>处理sass</p><p>{<br>test:/.scss$/,<br>use:[‘style-loader’,’css-loader’,’sass-loader’]<br>},</p><h2 id="postcss-loader-兼容前缀"><a href="#postcss-loader-兼容前缀" class="headerlink" title="postcss-loader 兼容前缀"></a>postcss-loader 兼容前缀</h2><p>//<a href="https://www.cnblogs.com/RoadAspenBK/p/9342850.html" target="_blank" rel="noopener">https://www.cnblogs.com/RoadAspenBK/p/9342850.html</a><br>yarn add postcss-loader  autoprefixer</p><p>//根目录创建postcss.config.js<br>module.exports = {<br>​    plugins:[<br>​        require(“autoprefixer”)<br>​    ]<br>}</p><p>//loader配置<br>use: [‘style-loader’,’css-loader’,{<br>​        loader: ‘postcss-loader’,<br>​        options: {<br>​            config: {<br>​                path: ‘postcss.config.js’  // 这个得在项目根目录创建此文件<br>​            }<br>​        }<br>​        },’sass-loader’]</p><p>//package.json上面添加<br>“browserslist”: [<br>​    “defaults”,<br>​    “not ie &lt; 11”,<br>​    “last 2 versions”,<br>​    “&gt; 1%”,<br>​    “iOS 7”,<br>​    “last 3 iOS versions”<br>  ]</p><p>将引入项目的css文件、scss文件抽成一个文件，引入到页面中</p><p>因为ExtractTextWebpackPlugin对webpack4支持的不是很好，所以我们这样解决：</p><p>cnpm i extract-text-webpack-plugin@next -D<br>yarn add extract-text-webpack-plugin@next -D</p><p>@next下载的就是最新的版本，可能是开发版本   3.x的版本过时了<br>“extract-text-webpack-plugin”: “^4.0.0-beta.0”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const ExtractTextWebpackPlugin = require(&apos;extract-text-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">///plugin</span><br><span class="line">new ExtractTextWebpackPlugin(&quot;style.css&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">///loader</span><br><span class="line">&#123;</span><br><span class="line">test:/\.css$/,</span><br><span class="line">use:ExtractTextWebpackPlugin.extract(&#123;</span><br><span class="line">      fallback: &quot;style-loader&quot;,</span><br><span class="line">      use: &quot;css-loader&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">test:/\.scss/,</span><br><span class="line">use:ExtractTextWebpackPlugin.extract(&#123;</span><br><span class="line">      fallback: &quot;style-loader&quot;,</span><br><span class="line">      use: [&quot;css-loader&quot;,&quot;sass-loader&quot;]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const OptimizeCssAssetsPlugin = require(‘optimize-css-assets-webpack-plugin’);//压缩css插件</p><p>//plugins配置<br>new OptimizeCssAssetsPlugin()</p><p>css兼容优化处理：post-css 、autoprefixer</p><p>处理es6：</p><p>需要的依赖：</p><p>“babel”: “^6.23.0”,<br>“babel-core”: “^6.24.1”,<br>“babel-loader”: “^7.0.0”,<br>“babel-preset-es2015”: “^6.24.1”,<br>“babel-preset-react”: “^6.24.1”,</p><p>rules：<br>{<br>​    test:/.js$/,<br>​    exclude: /node_modules/,<br>​    loader:’babel-loader’,<br>​    query: {<br>​        presets: [‘es2015’,’react’]<br>​     }<br>}</p><h5 id="ES6中的react"><a href="#ES6中的react" class="headerlink" title="ES6中的react"></a>ES6中的react</h5><p>1.创建组件：</p><p>使用class来创建组件</p><p>class App extends React.Component {</p><p>}</p><p>2.默认状态的设置</p><p>在es6中不再使用getInitialState来设置默认状态，而是在constructor里面直接给this.state上挂载状态</p><p>class App extends Component {<br>​    constructor(props){<br>​        super(props)<br>​<br>​        this.state={<br>​            doing:’吃饭’<br>​        }<br>​    }<br>}</p><ol><li>默认属性的设置</li></ol><p>在es6中，通过给类设置defaultProps属性来设置默认属性</p><p>App.defaultProps = {<br>​    name:’App根组件’<br>}</p><ol><li>做属性传参验证</li></ol><p>import PropTypes from ‘prop-types’;</p><p>App.propTypes = {<br>​    name:PropTypes.string<br>}</p><p>5.钩子函数有变化</p><p>getDefaultProps、getInitialState没有了</p><p>多出了constructor,而这个函数本身是类的构造器，在这里相当于getDefaultProps、getInitialState的结合</p><h5 id="create-react-app-脚手架"><a href="#create-react-app-脚手架" class="headerlink" title="create-react-app 脚手架"></a>create-react-app 脚手架</h5><p>npm install creat-react-app -g</p><p>create-react-app my-app //生成一个react开发模板在my-app目录<br>//生成的过程特别缓慢，可以使用yarn工具来下载，也就是说先去下载安装yarn   ：npm install yarn -g</p><p>当我们要进行二次配置的时候，需要找到node_modules文件夹里的react-scripts进行配置，但是当我们执行npm run eject就可以将配置文件抽出，方便开发配置</p><h5 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h5><p>当我们使用某些组件的时候，发现，该组件不需要拥有自己的状态，只需要接收到外界传入的属性之后做出相应的反应即可</p><p>这样的话，我们可以利用纯函数的方式将其制作成无状态组件，提高性能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">const Button = (props)=&gt;&#123;</span><br><span class="line">return &lt;button onClick=&#123;props.handler&#125;&gt;我要花钱&lt;/button&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Button</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React框架学习&quot;&gt;&lt;a href=&quot;#React框架学习&quot; class=&quot;headerlink&quot; title=&quot;React框架学习&quot;&gt;&lt;/a&gt;React框架学习&lt;/h1&gt;&lt;h2 id=&quot;开发依赖devDependencies与运行依赖dependencies&quot;
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react+redux整合</title>
    <link href="https://tianjiec.top/2019/01/12/react-redux%E6%95%B4%E5%90%88/"/>
    <id>https://tianjiec.top/2019/01/12/react-redux整合/</id>
    <published>2019-01-12T09:35:21.000Z</published>
    <updated>2019-01-12T09:35:59.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React里面"><a href="#React里面" class="headerlink" title="React里面"></a>React里面</h2><p>index.js是入口 ，App.js是源组件，其他组件放在它里面。</p><p>然后App.js放在public index.html里面的div.root里面。</p><h2 id="reducer拆分"><a href="#reducer拆分" class="headerlink" title="reducer拆分"></a>reducer拆分</h2><p>store里面</p><p>index.js不变，唯一数据源</p><p>把和todo数据相关的 放入 todolist文件夹。</p><p>在store文件夹写一个 总的reducer</p><p>import todolist from “todulist/reducer”</p><p>const reducer = combineReducers({</p><p>todolist</p><p>})</p><p>然后组件要回去它的数据的话要通过 store.getState().todolist.todos拿到todos的数据</p><p>calculator文件夹里面</p><p>state.js存放数据</p><p>export default{</p><p>}</p><p>reducer.js</p><p>import state from “./state”</p><p>const reducer = (prevState = state, action=&gt;{</p><p>let new_state = {…prevState};</p><p>return new_state;</p><p>}</p><p>onchange绑定方法：  为性能考虑 在input change的时候 在</p><p>constructor里面通过bind将触发方法和 处理方法绑定起来，这样就值绑定一次</p><p>this.触发方法= this.处理方法.bind(this,”具体哪个类型”)</p><p>input 里面defaultvalue在数据变化的时候不会重新渲染</p><p>input只是渲染默认值的话，我们就是使用defaultvalue</p><p>如果input的值不仅仅是渲染初始值，而且你的状态变化的时候，也要去更改value的时候就不能使用defaultValue了 ，必须使用value</p><h1 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h1><p>核心组件</p><p>Prodiver 提供者 属性上的  将自身store属性传给需要使用的容器组件</p><p>容器组件可以监控状态改变，一旦有新的状态，就会给ui组件传递给 </p><p>包在 最外层 即 App组件的外层 规定必须传一个store属性</p><p>store={store}</p><p>获取数据</p><p>通过connect上下文环境 写容器组件</p><p>//当状态发生改变，容器组件就会监听到数据变化，把最新的数据返回给ui组件 UI组件通过props接收最新数据</p><p>显示数据的一个组件 容器组件 ui组件 木偶组件</p><p>这个方法返回什么 ui组件 props上面就是什么</p><p>const mapStateToProps = state =&gt;{//通过这个方法 //props上面挂了属性</p><p>return state</p><p>}</p><p>这样这个组件里面就可以通过 this.props.值 就可以获取值</p><p>export default connect（mapStateToProps）(TodoInfo);//通过上下文生成容器组件</p><p>hoc高阶组件  容器组件</p><p>状态以改变  容器组件就会监听转台改变=》通过属性的方式给ui组件传递新的数据。</p><p>export default connect（mapStateToProps，mapDispatchToProps）(TodoInfo);</p><p>mapDispatchToProps:将派发的一些action 进行挂载，ui组件props上面就会哟什么方法。</p><p>const mapDispatchToProps = dispatch=&gt;{</p><p>return {</p><p>addNewTodo(title){</p><p>let action = actionCreator.addNewTodo(title)</p><p>dispatch(action)//在这里将actionCreator的action方法拿过来用 并且react-redex把dispatch拿了过来，所以可以在这里派发给reducer</p><p>}</p><p>}</p><p>}</p><p>const mapDispatchToProps = dispatch=&gt;{</p><p>}</p><p>import {connect} from “react-redex”</p><p>import {bindActionCreator} from “redux”</p><p>//将state里面的数据绑定到ui组建的props上，将actioncreator方法绑定到props上</p><p>export default connect（state=&gt;state，dispatch=&gt;{</p><p>return bindActionCreators(actionCreators,dispatch)</p><p>}）(TodoInfo);</p><p>异步操作在action里面去做需要 安装redux 中间件 （因为在redux架构里面）</p><p>redux-thunk redux-saga redux-promise</p><p>cnpm install redux-thunk -S</p><p>在store/index.js 里面配置</p><p>import thunk from “redux-thunk”</p><p>import (applayMiddleware) from “redux”</p><p>action 方法里面</p><p>compute(){</p><p>return dispatch =&gt;{</p><p>seTimeout(()=&gt;{</p><p>let action= {</p><p>type: COMPUTE,</p><p>}</p><p>dispatch(action)</p><p>})</p><p>}</p><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React里面&quot;&gt;&lt;a href=&quot;#React里面&quot; class=&quot;headerlink&quot; title=&quot;React里面&quot;&gt;&lt;/a&gt;React里面&lt;/h2&gt;&lt;p&gt;index.js是入口 ，App.js是源组件，其他组件放在它里面。&lt;/p&gt;
&lt;p&gt;然后App.js
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react-redux</title>
    <link href="https://tianjiec.top/2019/01/11/react-redux/"/>
    <id>https://tianjiec.top/2019/01/11/react-redux/</id>
    <published>2019-01-11T07:02:49.000Z</published>
    <updated>2019-01-12T09:33:59.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h1><p>react-redux 辅助工具  react-redux</p><p>cnpm install react-redux -S</p><p>核心组件<br>​    Prodiver  提供者  属性上通过store将数据派给容器组件<br>​    connect() 返回一个函数，函数参数接受UI组件，返回容器组件<br>​    connect()(ui组件/木偶组件)  ===&gt; 容器组件（智能组件）</p><p>核心 API<br>​    //容器组件内部帮你做了 store.subscribe()<br>​    //状态变化 ==&gt; 容器组件监听状态改变了 ==&gt; 通过属性的方式给ui组件传递<br>​    const mapStateToProps = state=&gt;{<br>​        return state.todolist<br>​    }<br>​    connect(mapStateToProps)(ui组件)</p><p>做异步操作在action里面去实现！需要安装 redux中间件<br>redux-thunk  redux-saga redux-promise</p><p>cnpm install redux-thunk -S</p><p>在store/index.js里面配置<br>import {createStore,applyMiddleware} from “redux”<br>import reducer from “./reducer”<br>import thunk from “redux-thunk”<br>const store = createStore(reducer, applyMiddleware(thunk));<br>export default store;</p><p>//actionCeators.js<br>compute(){<br>​    return dispatch=&gt;{<br>​        setTimeout(() =&gt; {<br>​            let action = {<br>​                type: COMPUTE,<br>​            }<br>​            dispatch(action)<br>​        }, 1000);<br>​    }<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;react-redux&quot;&gt;&lt;a href=&quot;#react-redux&quot; class=&quot;headerlink&quot; title=&quot;react-redux&quot;&gt;&lt;/a&gt;react-redux&lt;/h1&gt;&lt;p&gt;react-redux 辅助工具  react-redux&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="redex" scheme="https://tianjiec.top/tags/redex/"/>
    
  </entry>
  
  <entry>
    <title>redux</title>
    <link href="https://tianjiec.top/2019/01/10/redux/"/>
    <id>https://tianjiec.top/2019/01/10/redux/</id>
    <published>2019-01-10T13:05:44.000Z</published>
    <updated>2019-01-11T06:59:48.563Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>redux有四个组成部分：</p><p>store用来存储数据<br>reducer：真正的来管理数据<br>actionCreator：创建action，交由reducer处理<br>view： 用来使用数据，在这里，一般用react组件来充当</p><h5 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h5><p>（1）web应用是一个状态机，视图与状态是一一对应的。</p><p>（2）所有的状态，保存在一个对象里面 单一数据源：store是唯一的</p><h3 id="使用的方法"><a href="#使用的方法" class="headerlink" title="使用的方法"></a>使用的方法</h3><ol><li><p>创建store</p><p>从redux工具中取出createStore去生成一个store</p></li><li><p>创建一个reducer，然后将其传入到createStore中辅助store的创建</p><p>reducer是一个纯函数，接收当前状态和action，返回一个状态，返回什么，store的状态就是什么，需要注意的是，不能直接操作当前状态，而是需要返回一个新的状态</p><p>想要给store创建默认状态其实就是给reducer一个参数创建默认值</p></li><li><p>组件通过调用store.getState方法来使用store中的数据</p></li><li><p>组件产生用户操作，调用actionCreator的方法创建一个action，利用store.dispatch方法传递给reducer</p></li><li><p>reducer对action上的标示性信息做出判断后对新状态进行处理，然后返回新状态，这个时候store的数据就会发生改变</p><p>ps:reducer是个纯函数，也就是 他不能改变原来的state，所以state里面的引用数据要深拷贝。比如 arr=date.slice()</p></li><li><p>我们可以在组件中，利用store.subscribe方法去订阅数据的变化，也就是可以传入一个函数，当数据变化的时候，传入的函数会执行，在这个函数中让组件去获取最新的状态</p></li></ol><h4 id="具体使用："><a href="#具体使用：" class="headerlink" title="具体使用："></a>具体使用：</h4><p>react js组件里面调用组件中的方法=》派发action actionCreator 通过actionCreator.方法名 // 在store/actionCreator中的方法 =》 render匹配 处理数据 在state里面获取旧数据 处理数据 返回新数据</p><h5 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h5><p>组件只有属性没有状态，其实就是一个函数，接收外部传入属性做出相应的渲染</p><h4 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h4><h5 id="在数据-初始获取地方-加入本地存储"><a href="#在数据-初始获取地方-加入本地存储" class="headerlink" title="在数据 初始获取地方 加入本地存储"></a>在数据 初始获取地方 加入本地存储</h5><p>const state = {</p><p>todos:localStorage.todos?JSON.parse(localStorage.todos):[]</p><p>}</p><p>export default state;</p><h5 id="在修改数据地方-存入本地存储"><a href="#在修改数据地方-存入本地存储" class="headerlink" title="在修改数据地方 存入本地存储"></a>在修改数据地方 存入本地存储</h5><p>localStorage.todos = JSON.stringify(new_state.todos)</p><p>reducer-&gt; strore - &gt; react显示</p><h5 id=""><a href="#" class="headerlink" title=" "></a> </h5><h4 id="用常量定义方法名-便于维护"><a href="#用常量定义方法名-便于维护" class="headerlink" title="用常量定义方法名 便于维护"></a>用常量定义方法名 便于维护</h4><p>const.js</p><p>const ADD_NEW_TODO =ADD_NEW_TODO;</p><p>export {ADD_NEW_TODO}</p><p>react显示</p><p>在</p><p>conponentWillMount里面设置state为store获取过来的数据</p><p>store.subscribe(()=&gt;{//通过这个方法订阅一下 视图层 得到数据重新渲染</p><p>​    this.setState( {</p><p>​        todo: store.getState().todos</p><p>​    });</p><p>});</p><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>store里面</p><p>state存放数据    react组件里面可以直接通过 store.getState() 获取数据</p><p>reducer处理数据  通过引入state 获取旧数据 然后 返回新数据</p><p>actionCreators 派发处理数据任务 里面有各类方法 ，通过action.type 派发给reducer 去根据不同action处理数据</p><p>index.js 用来通过reducer初始rudux</p><p>用户修改数据：组件里面 调用actionCreator里面的方法 =》 通过dispatch 将action派发给（store）reducer匹配action 然后处理数据 =》 reducer返回新的数据 =》用户获取新的数据</p><p>用户获取数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState( &#123;</span><br><span class="line"></span><br><span class="line">todo: store.getState().todos</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redux&quot;&gt;&lt;a href=&quot;#redux&quot; class=&quot;headerlink&quot; title=&quot;redux&quot;&gt;&lt;/a&gt;redux&lt;/h3&gt;&lt;p&gt;redux有四个组成部分：&lt;/p&gt;
&lt;p&gt;store用来存储数据&lt;br&gt;reducer：真正的来管理数据&lt;br&gt;ac
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="https://tianjiec.top/2019/01/09/webpack/"/>
    <id>https://tianjiec.top/2019/01/09/webpack/</id>
    <published>2019-01-09T08:55:22.000Z</published>
    <updated>2019-01-12T09:37:20.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React框架学习"><a href="#React框架学习" class="headerlink" title="React框架学习"></a>React框架学习</h1><h3 id="开发依赖devDependenvies与运行依赖dependencies"><a href="#开发依赖devDependenvies与运行依赖dependencies" class="headerlink" title="开发依赖devDependenvies与运行依赖dependencies"></a>开发依赖devDependenvies与运行依赖dependencies</h3><blockquote><p>npm自己的文档说dependencies是运行时依赖，devDependencies是开发时的依赖。即devDependencies 下列出的模块，是我们开发时用的，比如 我们安装 js的压缩包gulp-uglify 时，我们采用的是 “npm install –save-dev gulp-uglify ”命令安装，因为我们在发布后用不到它，而只是在我们开发才用到它。<br>dependencies 下的模块，则是我们发布后还需要依赖的模块，譬如像jQuery库或者Angular框架类似的，我们在开发完后后肯定还要依赖它们，否则就运行不了。</p></blockquote><h3 id="webpack（facebook）"><a href="#webpack（facebook）" class="headerlink" title="webpack（facebook）"></a>webpack（facebook）</h3><p>前端工程化：包管理器：npm、cnpm、yarn、bower | 构建工具：grunt、gulp、webpack</p><p>gulp： 基于流的前端自动化构建工具，基于流的任务式的工具</p><p>webpack： 是一款模块化打包工具，webpack是基于配置的，通过配置一些选项来让webpack执行打包任务。npm i webpack -g</p><p>npm i webpack-cli -g (4.0+)</p><p>npm i yarn -g    </p><p>webpack在打包的时候，依靠依赖关系图，在打包的时候需要告知webpack两个概念：入口和出口</p><p>一般情况下，我们需要使用webpack.config.js进行配置</p><h4 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h4><p>entry配置项目打包的入口，值可以为单个的字符串执行某一个文件的地址，这个时候该文件就是入口文件，webpack会根据入口文件里各个模块之间的关系形成依赖关系图，然后根据依赖关系图打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry:&apos;./src/app.js&apos;,</span><br><span class="line">output:&#123;</span><br><span class="line">    path:path.join(__dirname,&apos;build&apos;);</span><br><span class="line">    filename:&apos;app.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有的时候我么需要的是多入口，我们就需要写成数组的形式，数组里的每一个字符串地址指向的都是一个独立的入口，webpack会将这些入口依赖打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry:[&apos;./src/app.js&apos;,&apos;./src/vendor.js&apos;],</span><br><span class="line">output:&#123;</span><br><span class="line">    path:path.join(__dirname,&apos;build&apos;),</span><br><span class="line">    filename:&apos;[name]&apos;.js//不确定名字的时候，这里会打包成main.js</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，因为filename里写成名字是[name],所以会根据entry的配置的键名来为打包出的js文件命名，has是每次打包的一个随机的hash值，可以用来做版本控制</p><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><p>在这里我们配置打包输出的一些选项</p><p>filename可以确定打包出来的文件的名字，在我们里面可以使用[name],[hash]这样的占位符</p><p>path配置打包出去的文件路径，需要是绝对路径。</p><h4 id="env"><a href="#env" class="headerlink" title="env"></a>env</h4><p>在命令行或者终端中执行 wbpack –env hello命令，就相当于在打包的时候传入一个参数为 hello</p><p>在webpack.config.js中可以暴露出一个函数，这个函数就可以接收到env参数，当然函数就可以根据env参数来有选择的返回某一个或多个配置对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = (env)=&gt;&#123;</span><br><span class="line">    if(env==&apos;production&apos;)&#123;</span><br><span class="line">        return productionConfig</span><br><span class="line">    &#125;</span><br><span class="line">    return developmentConfig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>–watch 可以让webpack去监听文件的改变。<br>可以在package.json里的scripts中配置一些快捷操作，通过npm run来运行</p><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><p>在webpack编译用的是loader,但是有一些loader无法完成的任务，交由插件（plugin）来完成 插件的时候需要在配置项中配置plugins选项，值是数组，可以放入多个插件的使用，而一般的插件都是一个构造器，我们只需要在plugins数组中放入该插件的实例即可。</p><h4 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h4><p>这个插件可以选择是否依据模板来生成一个打包好的html文件，在里面可以配置、title、template、filename、minify等选项，详情请查阅<a href="https://segmentfault.com/a/1190000007294861" target="_blank" rel="noopener">文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">template:&apos;./src/index.html&apos;,</span><br><span class="line">        minify:&#123;</span><br><span class="line">            collapseWhitespace:true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="LOADERS"><a href="#LOADERS" class="headerlink" title="LOADERS"></a>LOADERS</h4><p>在webpack中专门有一些东西用来编译文件、处理文件，这些东西就叫loader，loader的使用就是在配置项中，设置module，在module中设置rules值为数组，在数组里放入多个匹配规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;test:/\.css$/,use:&apos;css-loader&apos;&#125;</span><br><span class="line">    ],</span><br><span class="line">    //before</span><br><span class="line">        loaders:[</span><br><span class="line">            &#123;test:/\.css$/,loader:&apos;css-loader&apos;&#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test为此次匹配要匹配的文件正则规则，use代表要使用的loader</p><p>使用url-loader可以将css中引入的图片（背景图）、js中生成的img图片处理一下，生成到打包目录里</p><p>视图html-withimg-loader可以将html中img标签引入的img图片打包到打包目录</p><p>file-loader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:/\.(png|jpe?g|svg|gif)$/,</span><br><span class="line">    // use:&apos;url-loader?limit=1000&amp;name=images/[hash:8].[name].[ext]&apos;</span><br><span class="line">    use:[</span><br><span class="line">        &#123;</span><br><span class="line">            loader:&apos;url-loader&apos;,</span><br><span class="line">            options:&#123;</span><br><span class="line">                limit:1000,</span><br><span class="line">                name:&apos;/static/images/assets/[hash:8].[name].[ext]&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test:/\.html$/,</span><br><span class="line">    use:&apos;html-withimg-loader&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理css:</p><p>cnpm i css-loader style-loader –save-dev</p><p>配置：</p><p>{<br>​    test:/.css$/,<br>​    use:[‘style-loader’,’css-loader’]<br>}</p><p>注意。webpack中loader的使用是从后往前的</p><p>css-loader可以将引入到js中的css代码给抽离出来，style-loader可以将抽离出来的css代码放入到style标签中</p><p>处理sass</p><p>{<br>test:/.scss$/,<br>use:[‘style-loader’,’css-loader’,’sass-loader’]<br>},</p><h2 id="postcss-loader兼容前缀"><a href="#postcss-loader兼容前缀" class="headerlink" title="postcss-loader兼容前缀"></a>postcss-loader兼容前缀</h2><p>//<a href="https://www.cnblogs.com/RoadAspenBK/p/9342850.html" target="_blank" rel="noopener">https://www.cnblogs.com/RoadAspenBK/p/9342850.html</a></p><p>yarn add postcss-loader autoprefixer</p><p>//根目录创建postcss.config.js<br>module.exports = {<br>​    plugins:[<br>​        require(“autoprefixer”)<br>​    ]<br>}</p><p>//loader配置<br>use: [‘style-loader’,’css-loader’,{<br>​        loader: ‘postcss-loader’,<br>​        options: {<br>​            config: {<br>​                path: ‘postcss.config.js’  // 这个得在项目根目录创建此文件<br>​            }<br>​        }<br>​        },’sass-loader’]</p><p>//package.json上面添加<br>“browserslist”: [<br>​    “defaults”,<br>​    “not ie &lt; 11”,<br>​    “last 2 versions”,<br>​    “&gt; 1%”,<br>​    “iOS 7”,<br>​    “last 3 iOS versions”<br>  ]</p><p>将引入项目的css文件、scss文件抽成一个文件，引入到页面中</p><p>因为ExtracTextWebPackPlugin对webpack4支持不是很好，所以我们这样解决：</p><p>cnpm i extract-text-webpack-plugin@next -D</p><p>yarn add extract-text-webpack-plugin@next -D</p><p>@next下载的就是最新的版本，可能是开发版本   3.x的版本过时了<br>“extract-text-webpack-plugin”: “^4.0.0-beta.0”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React框架学习&quot;&gt;&lt;a href=&quot;#React框架学习&quot; class=&quot;headerlink&quot; title=&quot;React框架学习&quot;&gt;&lt;/a&gt;React框架学习&lt;/h1&gt;&lt;h3 id=&quot;开发依赖devDependenvies与运行依赖dependencies&quot;
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>vuex</title>
    <link href="https://tianjiec.top/2019/01/08/vuex/"/>
    <id>https://tianjiec.top/2019/01/08/vuex/</id>
    <published>2019-01-08T09:18:59.000Z</published>
    <updated>2019-01-08T09:20:59.079Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>是vue提供的一个全局的状态管理工具，主要处理项目中多组件间状态共享</p><p>当你不知道该不该使用vuex的时候，你就不需要使用vuex</p><p>整个vuex的使用都是从创建store开始的</p><p>store中包含了这样的几个部分：</p><p>state（存储状态的）</p><p>getters （用来派生新状态）</p><p>mutations （负责更改state）</p><p>actions （负责做异步操作）</p><p>在这里以一个购物车的小例子来学习，因为没有后端，所以数据交互只能与localStorage交互了</p><p>路由组件： 列表组件、购物车组件</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li><p>创建一个store</p></li><li><p>将创建好的store注入到根实例里,目的就是在任意组件中都可以使用到$store的api，用以使用vuex</p></li><li><p>创建state交由store来管理</p></li><li><p>在组件中使用state中的数据</p><p>组件可以直接从$store.state中得到vuex管理的状态，但是，不要这么用！</p><p>如果在视图中直接使用$store.state.num，num更改后组件的视图会更改，但是我们一般使用的时候都是在data里挂载，或者说直接this.num去使用，这样的话，当num更改的时候，组件无法得到更新</p><p>所以。vuex规定，我们要利用计算属性来使用vuex中的数据</p><p>其实大部分情况下，我们都会使用mapState这个辅助函数（作用：将vuex中state管理的状态通过计算属性放入到组件中）</p></li><li><p>如果需要从现有的状态派生出一个新的状态，使用getters，例如，已经有了一个num，现在需要再来一个doubleNum</p><p>getters里的数据，在组件中，我们也需要使用计算属性来接收，在这里也可以使用mapGetters的辅助函数，注意，mapGetters的使用方法和mapState一模一样</p></li><li><p>mutations是专门更改state的，也就是说，想要改state必须通过mutations才能改<br>mutations里有很多方法，方法被调用的时候，更改state，而且，注意一定要很谨慎的使用mutations，所以，建议大家，给mutations挂载方法的时候，方法名字使用常量</p><p>在组件中通过this.$store.commit(methodname,params)</p><p>使用mapMutations辅助函数可以将mutations中的方法与组件的方法耦合起来，使用方法与mapState、mapGetters一样，只是要放入在methods</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意，要让mutations纯粹！！！！。里面只有数据的更改，没有其他的逻辑代码</span><br></pre></td></tr></table></figure><ol><li><p>当我们想要像后端发送请求，根据结果再来更改state，这个时候，注意，不能把获取数据的异步逻辑写在mutations，也不要写在组件里，不方便维护和复用，所以，需要把他们写在actions，也就是说，vuex中的actions专门负责异步操作</p><p>actions里面有很多方法，这些方法里面可以进行异步操作</p></li></ol><p>// vuex的模块处理</p><p>在vuex中，我们可以配置一些模块，在每一个模块中都去创建自己的state、mutations、actions、getters，这样的话，每一个部分，或者说每一个开发者，去管理自己的一个模块，方便于维护</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分开模块之后，注意，state中的数据在组件中使用的时候需要this.$store.statea.modulenme.num</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vuex&quot;&gt;&lt;a href=&quot;#Vuex&quot; class=&quot;headerlink&quot; title=&quot;Vuex&quot;&gt;&lt;/a&gt;Vuex&lt;/h3&gt;&lt;p&gt;是vue提供的一个全局的状态管理工具，主要处理项目中多组件间状态共享&lt;/p&gt;
&lt;p&gt;当你不知道该不该使用vuex的时候，你就
      
    
    </summary>
    
    
      <category term="vue学习" scheme="https://tianjiec.top/tags/vue%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
