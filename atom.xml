<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chentj&#39;s Blog</title>
  
  <subtitle>Inflexible thinking, bad humor</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tianjiec.top/"/>
  <updated>2018-12-20T03:07:29.013Z</updated>
  <id>https://tianjiec.top/</id>
  
  <author>
    <name>chentj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>express的路由</title>
    <link href="https://tianjiec.top/2018/12/20/express%E7%9A%84%E8%B7%AF%E7%94%B1/"/>
    <id>https://tianjiec.top/2018/12/20/express的路由/</id>
    <published>2018-12-20T02:42:13.000Z</published>
    <updated>2018-12-20T03:07:29.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="express路由与应用模式"><a href="#express路由与应用模式" class="headerlink" title="express路由与应用模式"></a>express路由与应用模式</h1><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><blockquote><p>Express是一个基于Node.js的轻量级web开发框架，具有体积小，使用灵活等特点。查看Express的源码，如果不计供使用的中间件，主体框架只有一千余行代码，非常简练。</p><p>Express模型的核心为Express中定义的路由和路由器。分析Express源码可发现Express的路由提供多种灵活的应用模式。</p><p>我们首先介绍一下Express中的路由、路由器相关概念、结构及其特点，然后针对典型场景描述使用Express路由的四种应用模式。</p></blockquote><h3 id="2-Express中的路由与路由器"><a href="#2-Express中的路由与路由器" class="headerlink" title="2.Express中的路由与路由器"></a>2.Express中的路由与路由器</h3><p>Express具有典型的MVC模型特征。我们将路由定义为一个二元组route=(path, endpoint)：其中path为HTTP请求的路径，endpoint为请求路径应映射到的端点（端点可视为处理该请求的实体）,则Express中的路由器负责将请求映射到对应端点进行处理。</p><p>Express中的路由器分为两种类型:</p><p>app类型的路由器常使用如下代码创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br></pre></td></tr></table></figure><p>router类型的路由器常使用如下代码创建:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br></pre></td></tr></table></figure><blockquote><p>app和router是形为function(request, response, next)形式的函数对象，使用app.verb()，router.verb()形式函数实现路由注册（路由注册本质上是一个观察者模式）。</p><p>app.verb()和router.verb()中的verb常使用use、get、post、put、delete、route等动词，不同动词管辖的HTTP请求方法范围不同，这些动词函数的参数形式常为(pathExp, handleCallback)形式：其中pathExp表示请求路径，可为正则表达式；handleCallback为路径映射处理函数。</p></blockquote><p>app是Express框架所构建程序的请求处理入口，app可作为顶层路由器使用，在应用中也可挂载下级路由器（使用router对象）以实现分级路由。其间的关系可由下图表示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://s1.51cto.com/images/20180716/1531726860898789.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="express对象关系图.jpg" title="">                </div>                <div class="image-caption">express对象关系图.jpg</div>            </figure><p><strong>考察如下代码：</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/reports'</span>, router1);</span><br><span class="line">router1.get(<span class="string">'/querymysql/:id'</span>, queryMysqlData, handleQueryData);</span><br></pre></td></tr></table></figure><blockquote><p>对于http请求URL“/reports/querymysql/1”，Express中的路由器将此请求路由到queryMysqlData函数处理。</p></blockquote><h3 id="3、Express中的路由应用模式"><a href="#3、Express中的路由应用模式" class="headerlink" title="3、Express中的路由应用模式"></a>3、Express中的路由应用模式</h3><h3 id="3-1-REST模式"><a href="#3-1-REST模式" class="headerlink" title="3.1.   REST模式"></a>3.1.   REST模式</h3><p>对于一个使用restful风格的应用, 让我们想一想在不使用Express的时候如何在Node.js中处理rest请求，我们常常会写下如下示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">switch</span> (request.url) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'uri1'</span></span><br><span class="line">                        handleUri1 (request, response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' uri2'</span></span><br><span class="line">                        handleU ri2(request, response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' uri3'</span></span><br><span class="line">                        handleU ri3 (request, response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' uri4'</span></span><br><span class="line">                        handleU ri4 (request, response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        logToConsole(<span class="string">'unknown path:'</span> + path);</span><br><span class="line">                        response.writeHead(<span class="number">404</span>);</span><br><span class="line">                        response.end(<span class="string">"404 Not found"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Express将上面代码中对每个rest资源的操作(switch分支)转换为路由，路由中的路径为rest资源的URI，处理端点为function(request, response, next)形式、对rest资源的操作函数。</p><p>常使用app.route函数实现一个完整的restful接口，如下示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.route(<span class="string">'/uri1'</span>)</span><br><span class="line">  .get(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    handleGetUri1();</span><br><span class="line">  &#125;)</span><br><span class="line">  .post(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    handlePost Uri1 ();</span><br><span class="line">  &#125;)</span><br><span class="line">  .put(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    handlePut Uri <span class="number">1</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">.delete(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    handleDeleteUri <span class="number">1</span>();</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="3-2-AOP模式"><a href="#3-2-AOP模式" class="headerlink" title="3.2.   AOP模式"></a>3.2.   AOP模式</h3><p>在处理不同路径的HTTP请求时，常常需要在请求处理前和处理后做一些通用操作，这种应用需求是一个典型的AOP应用要求。</p><p>Express中允许定义一个具有通配路径的路由，在调用其它路径的路由前会先调用该通配路径路由。此通配路径路由也成为其它路径路由切面的一个注入点，考察如下示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.use(<span class="function"><span class="keyword">function</span> <span class="title">timelog</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"receive report request time is:"</span>,<span class="built_in">Date</span>.now());</span><br><span class="line">    next(); <span class="comment">//注意next函数的使用，必须声明该函数才能调用后继映射函数</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">router.get(<span class="string">'/chart1'</span>, proxy(&#123;</span><br><span class="line">    target: <span class="string">'http://127.0.0.1:8082'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">        <span class="string">'^/reports/chart1'</span>: <span class="string">'/loadChart1'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br><span class="line"> </span><br><span class="line">router.get(<span class="string">'/querymysql/:id'</span>, queryMysqlData, handleQueryData);</span><br></pre></td></tr></table></figure><p>上述代码中，在执行router的’/chart1’路由和’/querymysql/:id’路由之前都会执行timelog函数，在日志中记录当前路由执行时间。</p><h3 id="3-3-责任链模式"><a href="#3-3-责任链模式" class="headerlink" title="3.3.   责任链模式"></a>3.3.   责任链模式</h3><p>在Node.js中，由于多使用异步函数，常会出现异步回调函数中嵌套异步回调函数的情形。当出现多重异步回调时,则代码会变得混乱和难以维护。</p><p>考察一个应用场景：应用需要在数据库中进行多次查询，并对多次查询的结果综合处理。若使用数据库提供的异步查询接口，则需要在前一个查询操作的回调函数中进行下一个查询操作，若写在一个回调函数中，代码显臃肿。</p><p>Express的一个路由可定义多个处理函数，这些处理函数可设计为链式调用，实现了责任链模式，考察如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/test'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    handle1();</span><br><span class="line">    next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    handle2();</span><br><span class="line">    next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">   handle3();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述代码中：handle1, handle2, handle3构成了一个处理责任链“handle1-&gt;handle2-&gt;handle3”，通过next函数指引链式调用。</p><p>Express中路由的责任链应用特性使得多重异步嵌套的代码变得清晰和优雅。</p><p>​    针对本节开始提到的数据库查询应用场景，下面的示例代码展示了责任链模式的应用特点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/querymysql/:id'</span>, queryMysqlData, handleQueryData);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//查询mysql表中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryMysqlData</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"id"</span> <span class="keyword">in</span> req.params) &#123;</span><br><span class="line">        dbpool.query(<span class="string">" select * from articles where id=?"</span> ,[req.params.id], <span class="function"><span class="keyword">function</span> (<span class="params">err, rows, fields</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                res.send(err.stack);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rows &amp;&amp; rows.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'The queried rows is: '</span>, rows.length);</span><br><span class="line">                    res.articles = rows;</span><br><span class="line">                    next();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.send(<span class="string">"no query results!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.send(<span class="string">"invalid query params!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//处理查询mysql后得到的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleQueryData</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"articles"</span> <span class="keyword">in</span> res) &#123;</span><br><span class="line">        res.send(<span class="string">"id:"</span> + req.params.id + <span class="string">";title:"</span> + res.articles[<span class="number">0</span>].title);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.send(<span class="string">"no query data handled!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-熔断器模式"><a href="#3-4-熔断器模式" class="headerlink" title="3.4.   熔断器模式"></a>3.4.   熔断器模式</h3><p>上节提到的责任链模式本质上是一个逐级调用模型。在分布式服务架构（微服务架构）中，深度调用常常需要考虑调用可达性问题，即需要考虑某级调用会否一直不响应。调用可达性问题常使用熔断器模式，即在调用端设置一个熔断器，熔断条件产生时，熔断器发生熔断，返回给调用方调用失败信息。</p><p>考虑这样的应用场景：对于一些有处理时间要求的请求，当在指定时间内没有完成处理，需要向请求方返回处理失败信息。针对此应用场景，可在Express路由中设置超时熔断器，当处理超时，开启熔断器，通知请求方本次处理请求失败。</p><p>上述应用场景可使用如下示例代码应对：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/circuit'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bt=setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        next(<span class="string">'route'</span>); <span class="comment">//触发熔断</span></span><br><span class="line">    &#125;,<span class="number">3000</span>); <span class="comment">//设置熔断时间为3秒</span></span><br><span class="line">   res.breakTimer = bt;</span><br><span class="line">   next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    handle2();</span><br><span class="line">    next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">   handle3();</span><br><span class="line">   clearTimeout(res.breakTimer);<span class="comment">//正常执行完毕，取消熔断定时器</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/circuit '</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!res.finished)&#123; <span class="comment">//如果还没有响应，启动熔断</span></span><br><span class="line">    <span class="comment">//返回给调用者熔断信息</span></span><br><span class="line">    res.send(<span class="string">"breakCondition is true, notify the invoker."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="路径和句柄"><a href="#路径和句柄" class="headerlink" title="路径和句柄"></a>路径和句柄</h2><h3 id="理解了路径和句柄，才算真的会了Express路由的使用"><a href="#理解了路径和句柄，才算真的会了Express路由的使用" class="headerlink" title="理解了路径和句柄，才算真的会了Express路由的使用"></a>理解了路径和句柄，才算真的会了Express路由的使用</h3><p>路由：就是如何处理HTTP请求中的路径部分。</p><p>每个路径都会有对应的函数来处理（这个函数叫句柄），下面一个一个来说。</p><h4 id="一、有关路径"><a href="#一、有关路径" class="headerlink" title="一、有关路径"></a>一、有关路径</h4><p>路径可以是一个String类型也可以是一个正则表达式，例子：</p><p>1、当路径是String：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1053068413,3123129933&fm=173&s=AC9825D24BFEB6CA40BCCD030100E0C2&w=515&h=278&img.JPEG" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>如上图所示配置路由，页面分别访问：</p><p><a href="http://localhost:1234/abcd" target="_blank" rel="noopener">http://localhost:1234/abcd</a></p><p>输出：This is list</p><p><a href="http://localhost:1234/list/news/" target="_blank" rel="noopener">http://localhost:1234/list/news/</a></p><p>输出：This is news</p><p><a href="http://localhost:1234/list/news/123" target="_blank" rel="noopener">http://localhost:1234/list/news/123</a></p><p>输出：This is list news:123</p><p>2、当路径是正则表达式：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=1685331371,3718706668&fm=173&s=AC9835D3C9C8B4415AE5C50F0100E0C2&w=509&h=158&img.JPEG" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>第一个路由匹配的是/mobile/1[十个数字]，页面访问：</p><p><a href="http://localhost:1234/mobile/1XXXXXXXXXX" target="_blank" rel="noopener">http://localhost:1234/mobile/1XXXXXXXXXX</a></p><p>输出：This is a mobile phone ……</p><p>第二个路由匹配的是/abcd或者/acd。</p><h4 id="二、有关句柄"><a href="#二、有关句柄" class="headerlink" title="二、有关句柄"></a>二、有关句柄</h4><p>有关句柄，说两个问题</p><p>1、next和next（’route’）区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request,response,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req, res ,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    next(<span class="string">'route'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res ,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    next()</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req, res ,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    next(<span class="string">'route'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上图所示，有三个地方加了next，实例测试发现：</p><p>当位置1是next()时，结果输出：1234</p><p>当位置1是next(‘router’)时，结果输出：134</p><h5 id="由此可见，二者的区别就是：next从下一个处理函数开始往下执行，next-‘router’-，直接执行下一个相同路由。"><a href="#由此可见，二者的区别就是：next从下一个处理函数开始往下执行，next-‘router’-，直接执行下一个相同路由。" class="headerlink" title="由此可见，二者的区别就是：next从下一个处理函数开始往下执行，next(‘router’)，直接执行下一个相同路由。"></a>由此可见，二者的区别就是：next从下一个处理函数开始往下执行，next(‘router’)，直接执行下一个相同路由。</h5><p>2】param</p><p>param在路由中也相当于是一个中间件作用。例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.param(<span class="string">"listname"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next, listname</span>)</span>&#123;</span><br><span class="line">    req.list = [<span class="string">'item0'</span>, <span class="string">'item1'</span>, <span class="string">'item2'</span>];</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">'/list/:listname'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'list:\n'</span> + req.list.join(<span class="string">''</span>));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面这个路由输出：list:item0item1item2</p><p>app.param会在路由前执行，需要注意的是listname参数一定要对应。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;express路由与应用模式&quot;&gt;&lt;a href=&quot;#express路由与应用模式&quot; class=&quot;headerlink&quot; title=&quot;express路由与应用模式&quot;&gt;&lt;/a&gt;express路由与应用模式&lt;/h1&gt;&lt;h3 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mongoose</title>
    <link href="https://tianjiec.top/2018/12/20/mongoose/"/>
    <id>https://tianjiec.top/2018/12/20/mongoose/</id>
    <published>2018-12-20T02:18:28.000Z</published>
    <updated>2018-12-20T02:23:42.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>　　Mongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具</p><p>　　那么要使用它，首先你得装上node.js和mongodb,关于mongodb的安装和操作介绍可以参考：<a href="http://www.cnblogs.com/zhongweiv/p/node_mongodb.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhongweiv/p/node_mongodb.html</a></p><p>　　Github地址：<a href="https://github.com/Automattic/mongoose" target="_blank" rel="noopener">https://github.com/Automattic/mongoose</a></p><p>　　API Docs：<a href="http://mongoosejs.com/docs/guide.html" target="_blank" rel="noopener">http://mongoosejs.com/docs/guide.html</a></p><p>　　前面有介绍过用node-mongodb-native来操作mongodb，实际开发中估计更多会选用类似mongoose的模块来操作来提升开发效率</p><p>　　下面我们一步步来了解mongoose的基本操作^_^!</p><h1 id="mongoose安装"><a href="#mongoose安装" class="headerlink" title="mongoose安装"></a>mongoose安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mongoose</span><br></pre></td></tr></table></figure><p>　　安装成功后如下图：</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images.cnblogs.com/cnblogs_com/zhongweiv/804376/o_1.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure></blockquote><p>　　安装成功后，就可以通过 require(‘mongoose’) 来使用！</p><h1 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h1><p>　　创建一个db.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line">DB_URL = <span class="string">'mongodb://localhost:27017/mongoosedemo'</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mongoose.connect(DB_URL);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;　　Mongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具&lt;/p&gt;
&lt;p&gt;　　那么要使用它，首先你得装上no
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>框架初探-blog项目</title>
    <link href="https://tianjiec.top/2018/12/19/%E6%A1%86%E6%9E%B6%E5%88%9D%E6%8E%A2-blog%E9%A1%B9%E7%9B%AE/"/>
    <id>https://tianjiec.top/2018/12/19/框架初探-blog项目/</id>
    <published>2018-12-19T11:51:16.000Z</published>
    <updated>2018-12-19T11:51:16.179Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6 Promise用法</title>
    <link href="https://tianjiec.top/2018/12/19/ES6-Promise%E7%94%A8%E6%B3%95/"/>
    <id>https://tianjiec.top/2018/12/19/ES6-Promise用法/</id>
    <published>2018-12-19T11:33:07.000Z</published>
    <updated>2018-12-19T11:46:28.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-Promise-用法讲解"><a href="#ES6-Promise-用法讲解" class="headerlink" title="ES6 Promise 用法讲解"></a><a href="https://www.cnblogs.com/whybxy/p/7645578.html" target="_blank" rel="noopener">ES6 Promise 用法讲解</a></h1><blockquote><p>Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。</p></blockquote><p>那就new一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//异步操作</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"执行完成"</span>);</span><br><span class="line">        resolve(<span class="string">"data"</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。</p><p>在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并且调用resolve方法。</p><p>运行代码，会在2秒后输出“执行完成”。注意！我只是new了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'执行完成'</span>);</span><br><span class="line">            resolve(<span class="string">'随便什么数据'</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line">runAsync()</span><br></pre></td></tr></table></figure><p>这时候你应该有两个疑问：1.包装这么一个函数有毛线用？2.resolve(‘随便什么数据’);这是干毛的？</p><p>我们继续来讲。在我们包装好的函数最后，会return出Promise对象，也就是说，执行这个函数我们得到了一个Promise对象。还记得Promise对象上有then、catch方法吧？这就是强大之处了，看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">runAsync().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="comment">//后面可以用传过来的数据做些其他操作</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“随便什么数据”。</p><p>这时候你应该有所领悟了，原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。</p><p>你可能会不屑一顾，那么牛逼轰轰的Promise就这点能耐？我把回调函数封装一下，给runAsync传进去不也一样吗，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'执行完成'</span>);</span><br><span class="line">        callback(<span class="string">'随便什么数据'</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runAsync(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>效果也是一样的，还费劲用Promise干嘛。那么问题来了，有多层回调该怎么办？如果callback也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个callback2，然后给callback传进去吧。而Promise的优势在于，可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。</p><p> <strong>链式操作的用法</strong></p><p>所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">runAsync1()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> runAsync2();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> runAsync3();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样能够按顺序，每隔两秒输出每个异步回调中的内容，在runAsync2中传给resolve的数据，能在接下来的then方法中拿到。运行结果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004311507-221152206.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h2 id="reject的用法"><a href="#reject的用法" class="headerlink" title="reject的用法"></a><strong>reject的用法</strong></h2><p>到这里，你应该对“Promise是什么玩意”有了最基本的了解。那么我们接着来看看ES6的Promise还有哪些功能。我们光用了resolve，还没用reject呢，它是做什么的呢？事实上，我们前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function getNumber()&#123;</span><br><span class="line">    var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">        //做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            var num = Math.ceil(Math.random()*10); //生成1-10的随机数</span><br><span class="line">            if(num&lt;=5)&#123;</span><br><span class="line">                resolve(num);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                reject(&apos;数字太大了&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getNumber()</span><br><span class="line">.then(</span><br><span class="line">    function(data)&#123;</span><br><span class="line">        console.log(&apos;resolved&apos;);</span><br><span class="line">        console.log(data);</span><br><span class="line">    &#125;, </span><br><span class="line">    function(reason, data)&#123;</span><br><span class="line">        console.log(&apos;rejected&apos;);</span><br><span class="line">        console.log(reason);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。</p><p>运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004616257-1024778840.png" alt="img](https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004607960-1156803894.png)或者![img" title="">                </div>                <div class="image-caption">img](https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004607960-1156803894.png)或者![img</div>            </figure><h2 id="catch的用法"><a href="#catch的用法" class="headerlink" title="catch的用法"></a><strong>catch的用法</strong></h2><p>我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调，用法是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getNumber()</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(&apos;resolved&apos;);</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(&apos;rejected&apos;);</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getNumber()</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(&apos;resolved&apos;);</span><br><span class="line">    console.log(data);</span><br><span class="line">    console.log(somedata); //此处的somedata未定义</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(&apos;rejected&apos;);</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004747147-1508291069.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能。</p><h2 id="all的用法"><a href="#all的用法" class="headerlink" title="all的用法"></a><strong>all的用法</strong></h2><p>Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。我们仍旧使用上面定义好的runAsync1、runAsync2、runAsync3这三个函数，看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br><span class="line">.all([runAsync1(), runAsync2(), runAsync3()])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>用Promise.all来执行，all接收一个数组参数，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。所以上面代码的输出结果就是：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004843491-346782307.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</p><h2 id="race的用法"><a href="#race的用法" class="headerlink" title="race的用法"></a><strong>race的用法</strong></h2><p>all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思。race的用法与all一样，我们把上面runAsync1的延时改为1秒来看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br><span class="line">.race([runAsync1(), runAsync2(), runAsync3()])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这三个异步操作同样是并行执行的。结果你应该可以猜到，1秒后runAsync1已经执行完了，此时then里面的就执行了。结果是这样的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004946022-706413123.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>你猜对了吗？不完全，是吧。在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧再执行。于是再过1秒后，输出了他们结束的标志。</p><p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//请求某个图片资源</span><br><span class="line">function requestImg()&#123;</span><br><span class="line">    var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">        var img = new Image();</span><br><span class="line">        img.onload = function()&#123;</span><br><span class="line">            resolve(img);</span><br><span class="line">        &#125;</span><br><span class="line">        img.src = &apos;xxxxxx&apos;;</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//延时函数，用于给请求计时</span><br><span class="line">function timeout()&#123;</span><br><span class="line">    var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            reject(&apos;图片请求超时&apos;);</span><br><span class="line">        &#125;, 5000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise</span><br><span class="line">.race([requestImg(), timeout()])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>requestImg函数会异步请求一张图片，我把地址写为”xxxxxx”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。运行结果如下：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6-Promise-用法讲解&quot;&gt;&lt;a href=&quot;#ES6-Promise-用法讲解&quot; class=&quot;headerlink&quot; title=&quot;ES6 Promise 用法讲解&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/whybx
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面包屑导航</title>
    <link href="https://tianjiec.top/2018/12/19/%E9%9D%A2%E5%8C%85%E5%B1%91%E5%AF%BC%E8%88%AA/"/>
    <id>https://tianjiec.top/2018/12/19/面包屑导航/</id>
    <published>2018-12-19T11:27:56.000Z</published>
    <updated>2018-12-19T11:32:35.426Z</updated>
    
    <content type="html"><![CDATA[<p>面包屑<a href="https://baike.baidu.com/item/%E5%AF%BC%E8%88%AA" target="_blank" rel="noopener">导航</a>(BreadcrumbNavigation)这个概念来自童话故事”<a href="https://baike.baidu.com/item/%E6%B1%89%E8%B5%9B%E5%B0%94" target="_blank" rel="noopener">汉赛尔</a>和<a href="https://baike.baidu.com/item/%E6%A0%BC%E8%8E%B1%E7%89%B9" target="_blank" rel="noopener">格莱特</a>“，当汉赛尔和格莱特穿过森林时，不小心迷路了，但是他们发现在沿途走过的地方都撒下了面包屑，让这些面包屑来帮助他们找到回家的路。所以，面包屑导航的作用是告诉<a href="https://baike.baidu.com/item/%E8%AE%BF%E9%97%AE%E8%80%85/2774711" target="_blank" rel="noopener">访问者</a>他们目前在网站中的位置以及如何返回。</p><p>主页 &gt;栏目页&gt;文章页面</p><p>小型站点便于优化，可以把主页改成你的关键词，目的是关键词集权于首页。</p><p>关键词&gt;<a href="https://baike.baidu.com/item/%E6%A0%8F%E7%9B%AE%E9%A1%B5" target="_blank" rel="noopener">栏目页</a>&gt;文章页非常清晰，且不存在交叉；否则，面包屑导航的路径</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>1、让用户了解当前所处位置，以及当前页面在整个网站中的位置。</p><p>2、体现了网站的架构层级，能够帮助用户快速学习和了解网站内容和组织方式，从而形成很好的位置感。</p><p>3、提供返回各个层级的快速入口，方便用户操作。</p><p>4、<a href="https://baike.baidu.com/item/Google" target="_blank" rel="noopener">Google</a>已经将面包屑导航整合到搜索结果里面，因此优化面包屑导航每个层级的名称，多使用关键字，都可以实现SEO优化。面包屑路径，对于提高用户体验来说，是很有帮助的。</p><p>5、方便用户，面包屑主要用于为用户提供导航一个网站的次要方法，通过为一个大型多级网站的所有页面提供面包屑路径，用户可以更容易的定位到上一次目录，引导用户通行；</p><p>6、减少返回到上一级页面的点击或操作，不用使用浏览器的“返回”按钮或网站的主要导航来返回到上一级页面；</p><p>7、不用常常占用屏幕空间，因为它们通常是水平排列以及简单的样式，面包屑路径不会占用页面太多的空间。这样的好处是，从内容过载方面来说，他们几乎没有任何负面影响；</p><p>8、降低<a href="https://baike.baidu.com/item/%E8%B7%B3%E5%87%BA%E7%8E%87" target="_blank" rel="noopener">跳出率</a>，面包屑路径会是一个诱惑首次访问者在进入一个页面后去浏览这个网站的非常好的方法。比如说，一个用户通过谷歌搜索到一个页面，然后看到一个面包屑路径，这将会诱使用户点击上一级页面去浏览感兴趣的相关主题。这样，从而，可以降低网站的总体跳出率。</p><p>9、有利于百度蜘蛛对网站的抓取，蜘蛛直接沿着那个链走就可以了，很方便。</p><p>10、面包屑有利于网站<a href="https://baike.baidu.com/item/%E5%86%85%E9%93%BE" target="_blank" rel="noopener">内链</a>的建设，用面包屑大大增加了网站的内部连接，提高用户体验。</p><h3 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h3><p>虽然眼下很多网站都流行使用面包屑导航，但是并不是所有的网站都适用。符合下面两个条件的网站才适合使用面包屑导航。1、层级较深的网站，面包屑导航适合层级较深的网站，如果只有一级分类的话，通过主导航就可以起到快速定位的作用。比如“<a href="https://baike.baidu.com/item/%E8%B1%86%E7%93%A3%E7%BD%91" target="_blank" rel="noopener">豆瓣网</a>”类型扁平构架的网站就没有使用面包屑导航。2、独立不交叉的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%AB%99%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">网站结构</a>，由于面包屑网站导航路径是线性结构的，因此网站内容必须划分的非常清晰，且不存在交叉；否则，面包屑导航的路径就不是唯一的，同一分类可能出现在不同的路径中，让用户感到困惑。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>编辑</p><p>一、基于位置的面包屑导航</p><p>这种类型是最常见的。这种类型的面包屑导航可以很好的指出当前页面与整个站点的层次结构。这种面包屑导航可以显示当前页面的前一个页面或者目录的<a href="https://baike.baidu.com/item/%E9%93%BE%E6%8E%A5" target="_blank" rel="noopener">链接</a>。可以使访客了解自己的位置，以及可以更快的找到自己想要到达的页面。可以很好的提高用户的友好体验。</p><p>二、基于属性的面包屑导航</p><p>这种面包屑导航最常出现在电子商务站点。这种面包屑导航可以很好的指出当前页面内产品的其他属性或者类别。对于一个产品来说，所具有的属性往往不只有一种，而通过这种面包屑导航可以给消费者一个更加直观的了解。</p><p>三、基于路径的面包屑导航</p><p>这种面包屑导航是最不常见到的。这种面包屑导航和上文所说的童话故事类型很像。他们可以显示访客在到达页面前所访问过的<a href="https://baike.baidu.com/item/%E7%BD%91%E9%A1%B5" target="_blank" rel="noopener">网页</a>的链接。这种面包屑导航不是很受欢迎，因为他们的功能基本上是和前进和后退的按钮是一样的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面包屑&lt;a href=&quot;https://baike.baidu.com/item/%E5%AF%BC%E8%88%AA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;导航&lt;/a&gt;(BreadcrumbNavigation)这个概念来自童话故事”&lt;a hre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="https://tianjiec.top/2018/12/18/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://tianjiec.top/2018/12/18/面试题/</id>
    <published>2018-12-18T01:21:11.000Z</published>
    <updated>2018-12-20T01:54:04.786Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？"><a href="#1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？" class="headerlink" title="1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？"></a>1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？</h4><p>IE：trident内核</p><p>Firefox：gecko内核</p><p>Safari：webkit内核</p><p>Opera：以前是presto内核，现在改用Google的Chrome的blink内核</p><p>Chrome：blink（基于webkit，Google与Opera共同开发）</p><h4 id="2、每个HTML文件里开头都有一个很重要的东西，Doctype，知道这是干什么的吗？"><a href="#2、每个HTML文件里开头都有一个很重要的东西，Doctype，知道这是干什么的吗？" class="headerlink" title="2、每个HTML文件里开头都有一个很重要的东西，Doctype，知道这是干什么的吗？"></a>2、每个HTML文件里开头都有一个很重要的东西，Doctype，知道这是干什么的吗？</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE&gt;</span> 声明于文档中的最前面的位置，处于<span class="tag">&lt;<span class="name">html</span>&gt;</span> 标签之前。此标签可告知浏览器文档使用哪种HTML 或 XHTML 规范。（重点：告诉浏览器按照何种规范解析页面）</span><br></pre></td></tr></table></figure><h4 id="3、Quirks-模式-是什么？-他和Standards模式有什么区别"><a href="#3、Quirks-模式-是什么？-他和Standards模式有什么区别" class="headerlink" title="3、Quirks 模式 是什么？ 他和Standards模式有什么区别"></a>3、Quirks 模式 是什么？ 他和Standards模式有什么区别</h4><p>从IE6开始，引入了Standards模式， 标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。</p><p>在IE6之前 CSS 还不够成熟， 所以 IE5 等之前的浏览器 对 CSS 的支持很差， IE6将对CSS提供更好的支持，然而这时的问题来了，因为有很多页面是基于旧的布局方式写的，而如果IE6支持CSS则将令这些页面显示不正常，如果在既保证不破坏现有页面，有提供新的渲染机制呢？</p><p>在写程序的时候我们也会经常遇到这样的问题，如何保证原来的接口不变，有提供更强大的功能，尤其是新功能不兼容旧功能的时候。 遇到这样的问题是一个常见的做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数不为真时，就是使用旧功能，这样就能不破坏原有程序，又提供新功能。IE刘也是类似这样做的，它将DTD当成了这个参数，就意味着这个页面都将采用CSS支持更好的布局，而如果没有，则将采用兼容之前的布局方式。 这就是Quirks模式（怪癖模式，诡异模式， 怪异模式）。</p><p>区别：</p><p>总体会有布局、 样式解析和脚本执行这三方面的区别。</p><p>盒模型：</p><p>在W3C标准中，如果设置了一个元素的宽和高，指的是元素内容的宽度和高度，而在Quirks模式下。IE的宽度和高度还包含了padding和border。</p><p>设置行内元素的高度：</p><p>在Standards 模式下，给<span>等行内元素设置width和height都不会生效，而在quirks模式下，则会生效。</span></p><p>设置百分比的高度：在standards模式下， 一个元素的高度石油其包含的元素内容来决定的，如果父元素没有设置百分比高度，子元素设置一个百分比高度是无效的。</p><p>margin：0 auto设置水平居中：使用margin:0 auto 在standards模式下 可以使元素水平居中，但在quirks 模式下会失效</p><p>（还有很多，答出什么不重要，关键是看他答出的这些是不是自己经验遇到的，还是说都是看文章看的，甚至完全不知道。）</p><h4 id="4、div-css布局较table布局有什么优点？"><a href="#4、div-css布局较table布局有什么优点？" class="headerlink" title="4、div+css布局较table布局有什么优点？"></a>4、div+css布局较table布局有什么优点？</h4><p>改版的时候更方便  是要改css文件。</p><p>页面加载的速度更快、结构化清晰、页面显示简洁。</p><p>表现与结构相分离；</p><p>易于优化（seo）搜索引擎更友好，排名更靠前。</p><h4 id="5、img的alt-与-title-有何异同？-strong-与-em-的异同？"><a href="#5、img的alt-与-title-有何异同？-strong-与-em-的异同？" class="headerlink" title="5、img的alt 与 title 有何异同？ strong 与 em 的异同？"></a>5、img的alt 与 title 有何异同？ strong 与 em 的异同？</h4><p>a: alt（alt text）： 为了能显示图像、窗体或applets的用户代理（UA），alt属性用来指定替换的文字。</p><p>替换文字的语言用lang属性来决定。（在IE浏览器下会在没有title时把 alt 当成 tool tip 显示）</p><p>title（tool tip）：该属性为设置该属性的元素提供建议性的信息。</p><p>strong：粗体强调标签，强调，表示内容的重要性；</p><p>em：斜体强调标签，更强烈强调，表示内容强调点；</p><h4 id="6、你能描述一下渐进增强和优雅降级之间的不同吗？"><a href="#6、你能描述一下渐进增强和优雅降级之间的不同吗？" class="headerlink" title="6、你能描述一下渐进增强和优雅降级之间的不同吗？"></a>6、你能描述一下渐进增强和优雅降级之间的不同吗？</h4><p><strong>渐进增强</strong>： progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后在针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p><p><strong>优雅降级</strong>：graceful degradation ： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</p><p><strong>区别：</strong>优雅降级是从复杂的现状开始的，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</p><p><strong>优雅降级</strong>观点</p><p>优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为过时 或有功能缺失的浏览器下的测试安排在开发周期的最后阶段，并把测试对象限定为主流浏览器 （如IE、Mozilla等）的前一个版本。</p><p>在这种设计规范下，旧版本的浏览器被认为仅能提供“简陋却无妨（poor ，but passable）”的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于他们并非我们所关注的焦点，因此除了修复较大的错误之外，其他的差异将被直接忽略。</p><p><strong>渐进增强</strong>观点</p><p>渐进增强观点则认为应关注内容本身。</p><p>内容使我们创建网站的诱因。有的网站展示它，有的网站收集他，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p><p>那么问题来了。现在产品经理看到IE6,7,8网页效果相对高版本现代浏览器少了很多圆角，阴影（CSS3），要求兼容（使用图片背景，放弃CSS3），你会如何说服他？</p><h4 id="7、为什么利用多个域名来存储网站资源会更有效？"><a href="#7、为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="7、为什么利用多个域名来存储网站资源会更有效？"></a>7、为什么利用多个域名来存储网站资源会更有效？</h4><p>CDN缓存更方便</p><p>突破浏览器并发限制</p><p>节约cookie带宽</p><p>节约主域名的连接数，优化页面响应速度</p><p>防止不必要的安全问题</p><h4 id="8、请谈一下你对网页标准和标准定义机构重要性的理解。"><a href="#8、请谈一下你对网页标准和标准定义机构重要性的理解。" class="headerlink" title="8、请谈一下你对网页标准和标准定义机构重要性的理解。"></a>8、请谈一下你对网页标准和标准定义机构重要性的理解。</h4><p>网页标准和标准定制机构都是为了让web发展的更健康，开发者遵循统一的标准，降低开发难度，开发成本，SEO也会更好做，也不会因为滥用代码而导致各种BUG、安全问题，最终提高网站的易用性。</p><h4 id="9、请你描述一下cookies，sessionStorage和localStorage的-区别"><a href="#9、请你描述一下cookies，sessionStorage和localStorage的-区别" class="headerlink" title="9、请你描述一下cookies，sessionStorage和localStorage的    区别"></a>9、请你描述一下cookies，sessionStorage和localStorage的    区别</h4><p>sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动去删除数据，否则数据是永远不会过期的。</p><p>web storage 和 cookie 的区别</p><p>web storage 的概念和 cookie 相似，区别是它是为了更大容量存储设计的。cookie的大小是受限制的，而且没刺激你请求一个新的页面的时候cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可跨域调用。</p><p>除此之外，webstorage拥有setitem，getitem，removeitem，clear等方法， 不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在， 而Web Storage仅仅是为了本地存储数据而生的。</p><h4 id="10、简述下src和href的区别"><a href="#10、简述下src和href的区别" class="headerlink" title="10、简述下src和href的区别"></a>10、简述下src和href的区别</h4><p>src用于替换当前元素，href用于在当前文档引用资源之间确认联系。</p><p>src是 source 的缩写， 指向外部资源的位置， 指向的内容将会嵌入到文档中但钱标签所在的位置，在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src = &quot;js.js&quot;&gt; &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当浏览器解析到该元素时，会暂停其它资源的下载和处理，直到将该元素资源加载、编译、执行完毕，图片和框架等元素也是如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。</p><p>href是Hypertext的缩写 reference的缩写， 指向网络资源所在的位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href= &quot;common.css&quot; rel=&quot;stylesheet&quot; /&gt;</span><br></pre></td></tr></table></figure><p>name浏览器会识别该文档为css文件，就会并行下载资源并且不会停止当前文档的处理。这也是为什么建议用link方式加载css，而不是使用@import方式。</p><h4 id="11、知道的网页制作用到的图片格式都有哪些"><a href="#11、知道的网页制作用到的图片格式都有哪些" class="headerlink" title="11、知道的网页制作用到的图片格式都有哪些"></a>11、知道的网页制作用到的图片格式都有哪些</h4><p>png-8，png-24，jpeg，gif，svg。</p><p>Webp</p><p>Webp：Webp格式，谷歌（google）开发的一种</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？&quot;&gt;&lt;a href=&quot;#1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？&quot; class=&quot;headerlink&quot; title=&quot;1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>夜、萤火虫和你</title>
    <link href="https://tianjiec.top/2018/12/14/%E5%A4%9C%E3%80%81%E8%90%A4%E7%81%AB%E8%99%AB%E5%92%8C%E4%BD%A0/"/>
    <id>https://tianjiec.top/2018/12/14/夜、萤火虫和你/</id>
    <published>2018-12-14T12:51:36.000Z</published>
    <updated>2018-12-14T13:06:22.092Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"音乐/夜、萤火虫和你.mp3"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>  <span class="attr">autoplay</span> <span class="attr">preload</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>18/11/7</title>
    <link href="https://tianjiec.top/2018/11/07/18-11-7/"/>
    <id>https://tianjiec.top/2018/11/07/18-11-7/</id>
    <published>2018-11-07T03:48:52.000Z</published>
    <updated>2018-11-07T04:52:38.330Z</updated>
    
    <content type="html"><![CDATA[<p>每当我想好好学习<br>总有人和我说回去睡吧别学了<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://qzonestyle.gtimg.cn/qzone/em/e295.gif" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><br>今天又是爱我熙哥的一天</p><p><img src="http://p1lzepiq0.bkt.clouddn.com/%E7%BD%97%E4%BA%91%E7%86%99.jpg" width="280px" height="400px"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每当我想好好学习&lt;br&gt;总有人和我说回去睡吧别学了&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay
      
    
    </summary>
    
    
  </entry>
  
</feed>
