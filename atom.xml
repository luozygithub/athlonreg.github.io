<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chentj&#39;s Blog</title>
  
  <subtitle>Inflexible thinking, bad humor</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tianjiec.top/"/>
  <updated>2019-04-21T12:32:45.661Z</updated>
  <id>https://tianjiec.top/</id>
  
  <author>
    <name>chentj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript的数据类型及其检测</title>
    <link href="https://tianjiec.top/2019/04/21/JavaScript%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E6%A3%80%E6%B5%8B/"/>
    <id>https://tianjiec.top/2019/04/21/JavaScript的数据类型及其检测/</id>
    <published>2019-04-21T12:06:19.000Z</published>
    <updated>2019-04-21T12:32:45.661Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>1、Symbol(ES6新增，表示独一无二的值)</p><p>2、Undefined</p><p>3、Null</p><p>4、NaN</p><p>5、布尔值（Boolean）</p><p>6、字符串（String）</p><p>7、数值（Number）</p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>对象(Object)=》对象，数组，函数等</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><h5 id="两种类型区别"><a href="#两种类型区别" class="headerlink" title="两种类型区别"></a>两种类型区别</h5><p>1、存储位置不同</p><p>引用类型存储在栈，堆（heap）中</p><p>基本数据类型直接存储在栈（stack）中</p><p>2、访问方式不同</p><p>基本数据类型直接访问其值</p><p>应用数据类型按引用访问</p><h5 id="基本数据类型的特点"><a href="#基本数据类型的特点" class="headerlink" title="基本数据类型的特点"></a>基本数据类型的特点</h5><p>值不可变（改变是覆盖）</p><p>比较是值的比较</p><p>存放在栈区，简单数据段。占据空间小，大小固定，属于被频繁访问的数据，所以放在栈中存储。</p><p>==比较会转换数据类型 ===不会</p><h5 id="引用类型特点"><a href="#引用类型特点" class="headerlink" title="引用类型特点"></a>引用类型特点</h5><p>值是可变的，拥有属性和方法</p><p>比较是引用的比较</p><p>同时存在在栈内存和堆内存中的对象，栈中存储指针，堆中存储对象，堆中存放数据占据空间大的、大小不固定</p><h4 id="检验数据类型"><a href="#检验数据类型" class="headerlink" title="检验数据类型"></a>检验数据类型</h4><h5 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h5><p>不能检验数组和对象</p><h5 id="instanceof（运算符）"><a href="#instanceof（运算符）" class="headerlink" title="instanceof（运算符）"></a>instanceof（运算符）</h5><p>A instanceof B 判断A是否是B的实例</p><p>es6新增Array.isArray()数组类型判断</p><p>不能检测字面量方式创建基本数据类型</p><p>不能检验null和undefined</p><p>在类的原型继承中，检测未必准确</p><h5 id="严格运算符"><a href="#严格运算符" class="headerlink" title="严格运算符"></a>严格运算符</h5><p>===</p><p>检测null和undefined</p><h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h5><p>不能检测null和undefined</p><p>把类的原型进行重写，检测就不准确</p><h5 id="Object-protype-toString-call"><a href="#Object-protype-toString-call" class="headerlink" title="Object.protype.toString.call()"></a>Object.protype.toString.call()</h5><p>最准确的检测方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/h4&gt;&lt;p&gt;1、Symbol(ES6新增，表示独一无二的值)&lt;/p&gt;
&lt;p&gt;2、Undefin
      
    
    </summary>
    
    
      <category term="js" scheme="https://tianjiec.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS异步编程六中方案</title>
    <link href="https://tianjiec.top/2019/04/14/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%85%AD%E4%B8%AD%E6%96%B9%E6%A1%88/"/>
    <id>https://tianjiec.top/2019/04/14/JS异步编程六中方案/</id>
    <published>2019-04-14T14:52:55.000Z</published>
    <updated>2019-04-14T15:29:00.609Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> JavaScript语言执行环境为单线程</p></blockquote><p>需排队完成任务，若有任务耗时长，会导致阻塞接下来任务，导致整个页面卡死在这个地方，其他任务无法执行。</p><p>为解决这个问题，JavaScript语言将任务的执行模式分为两种：同步和异步。</p><h4 id="异步编程解决方案："><a href="#异步编程解决方案：" class="headerlink" title="异步编程解决方案："></a>异步编程解决方案：</h4><h5 id="一、回调函数"><a href="#一、回调函数" class="headerlink" title="一、回调函数"></a>一、回调函数</h5><p>回调函数是异步操作最基本的方法。例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ajax(url,()=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure><p>但是回调函数有个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，你就可能写出如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(url,()=&gt;&#123;</span><br><span class="line">    //处理逻辑</span><br><span class="line">    ajax(url1,()=&gt;&#123;</span><br><span class="line">        //处理逻辑</span><br><span class="line">        ajax（url2,()=&gt;&#123;</span><br><span class="line">            //处理逻辑</span><br><span class="line">        &#125;）</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>回调函数优点是简单、容易理解和实现，缺点就是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。此外它不能使try catch捕获错误，不能直接return。</p><h5 id="二、事件监听"><a href="#二、事件监听" class="headerlink" title="二、事件监听"></a>二、事件监听</h5><p>这种方式下，异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.on(<span class="string">'done'</span>,f2);<span class="comment">//f2必须等到f1执行完成才会执行。首先，为f1绑定一个事件（这里采用的jQuery的写法）</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; JavaScript语言执行环境为单线程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需排队完成任务，若有任务耗时长，会导致阻塞接下来任务，导致整个页面卡死在这个地方，其他任务无法执行。&lt;/p&gt;
&lt;p&gt;为解决这个问题，JavaScript语言将任务
      
    
    </summary>
    
    
      <category term="js" scheme="https://tianjiec.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Express相关知识</title>
    <link href="https://tianjiec.top/2019/04/14/Express%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>https://tianjiec.top/2019/04/14/Express相关知识/</id>
    <published>2019-04-14T11:43:05.000Z</published>
    <updated>2019-04-14T11:43:57.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><blockquote><p>路由、中间件和模板引擎</p></blockquote><p>Express是一个基于Node的一个框架，用来快速创建Web服务的一个工具，为什么要使用Express呢，因为创建Web服务如果从Node开始有很多繁琐的工作要做，而Express为你解放了很多工作，从而让你更加关注于逻辑业务开发。</p><p>举例：开发一个很简单的网站：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>,&#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>:<span class="string">'text/plain'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> url_str = url.parse(req.url,<span class="literal">true</span>);</span><br><span class="line">    res.end(<span class="string">'Hello World\n'</span> + url_str.query);</span><br><span class="line">&#125;).listen(<span class="number">8080</span>,<span class="string">'127.0.0.1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1'</span>:<span class="number">8080</span>/);</span><br></pre></td></tr></table></figure><p>这是一个简单的 hello world，运行以后访问<a href="http://127.0.0.1会打印相关字符串，这是最普通的页面，但实际上真正的网站要比这个复杂很多，主要有：" target="_blank" rel="noopener">http://127.0.0.1会打印相关字符串，这是最普通的页面，但实际上真正的网站要比这个复杂很多，主要有：</a></p><p>(1) 多页面的路由功能</p><p>(2) 对请求的处理逻辑</p><p>那么使用node</p><p>原生写法就要进行以下处理</p><p>1、原生写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载所需模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="comment">//创建Server</span></span><br><span class="line"><span class="keyword">var</span> app = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(request.url == <span class="string">'/'</span>)&#123;</span><br><span class="line">        response.writeHead(<span class="number">200</span>,&#123;<span class="string">'Content-Type'</span>:<span class="string">'text/plain'</span>&#125;);</span><br><span class="line">        response.end(<span class="string">'Home Page!\n'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(request.url == <span class="string">'/about'</span>)&#123;</span><br><span class="line">        response.writeHead(<span class="number">200</span>,&#123;<span class="string">'Content-Type'</span>:<span class="string">'text/plain'</span>&#125;);</span><br><span class="line">        response.end(<span class="string">'About Page!\n'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        response.writeHead(<span class="number">404</span>,&#123;<span class="string">'Content-Type'</span>:<span class="string">'text/plain'</span>&#125;);</span><br><span class="line">        response.end(<span class="string">"404 Not Found!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//启动Server</span></span><br><span class="line">app.listen(<span class="number">1984</span>,<span class="string">'localhost'</span>);</span><br></pre></td></tr></table></figure><p>代码在createServer函数里传递一个回调函数来处理http请求并返回结果，在这个函数里有两个工作要做：.</p><p>（1）路由分析，对于不同的路径需要进行分别处理</p><p>（2）逻辑处理和返回，对某个路径进行特别逻辑处理</p><p>这里会有什么问题呢，如果一个大型网站拥有海量的网站（也就是路径），每个网页的处理逻辑也是交错复杂，那这里的写法会非常混乱，没法维护，未解决这个问题，TJ提出了Connect的概念，把Java里面的中间件概念第一次引入到了JS的世界Web请求将一个一个经过中间件，并通过其中一个中间件返回，大大提高了代码的可维护性和开发效率。</p><p>2、使用中间件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入connect模块</span></span><br><span class="line"><span class="keyword">var</span> connect = <span class="built_in">require</span>(<span class="string">'connect'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> app = connect();</span><br><span class="line"><span class="comment">//建立app</span></span><br><span class="line"><span class="keyword">var</span> app = connect();</span><br><span class="line"><span class="comment">//添加中间件</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>)</span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">    response.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>)</span><br></pre></td></tr></table></figure><p>但是TJ认为应该更好一点，于是Express诞生了，通过Express开发以上的例子：</p><p>3、使用Express：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/about'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">"Ablout"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> host = server.address().address;</span><br><span class="line">    <span class="keyword">var</span> port = server.address().port;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Exampleapplistening"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>从这个例子可以看出，使用Express大大减少了代码函数，而且逻辑更为简洁，所以使用Express可以提高开发效率并降低工程维护成本。</p><p>首先Express有几个比较重要的概念：路由、中间件、模板引擎</p><p>开发人员可以为Web页面注册路由，将不同的路径请求区分到不同的模块中去，从而避免了上面例子1所说的海量路径问题，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">'*'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>)</span>&#123;</span><br><span class="line">    response.end(<span class="string">"Welcome to the home page!"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">'/about'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.end(<span class="string">"Welconme to the about page!"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">'*'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.end(<span class="string">"404!"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure><p>开发人员可以为特定的路由开发中间件模块，中间件模块可以复用，从而解决了复杂逻辑的交错引用问题，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="comment">//没有挂载路径的中间件，应用的每个请求都会执行该中间件</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Time:'</span>,<span class="built_in">Date</span>.now());</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//挂载至 /user/:id 的中间件，任何执行/user/:id 的请求都会执行它</span></span><br><span class="line">app.use(<span class="string">'user/:id'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'User'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> host = server.address().address;</span><br><span class="line">    <span class="keyword">var</span> port = server.address().port;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'Example app listening at http://%s:%s'</span>, host, port);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/zhusheng2008/p/5264096.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhusheng2008/p/5264096.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Express&quot;&gt;&lt;a href=&quot;#Express&quot; class=&quot;headerlink&quot; title=&quot;Express&quot;&gt;&lt;/a&gt;Express&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;路由、中间件和模板引擎&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Expr
      
    
    </summary>
    
    
      <category term="node 框架 express" scheme="https://tianjiec.top/tags/node-%E6%A1%86%E6%9E%B6-express/"/>
    
  </entry>
  
  <entry>
    <title>swig使用</title>
    <link href="https://tianjiec.top/2019/04/14/swig%E4%BD%BF%E7%94%A8/"/>
    <id>https://tianjiec.top/2019/04/14/swig使用/</id>
    <published>2019-04-14T11:42:46.000Z</published>
    <updated>2019-04-14T11:43:32.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swig-使用指南"><a href="#Swig-使用指南" class="headerlink" title="Swig 使用指南"></a>Swig 使用指南</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://images.iqianduan.net/how_to_use_swig_pic.jpg" alt="Swig 使用指南" title="">                </div>                <div class="image-caption">Swig 使用指南</div>            </figure><h3 id="一、如何使用"><a href="#一、如何使用" class="headerlink" title="一、如何使用"></a>一、如何使用</h3><h4 id="1、API"><a href="#1、API" class="headerlink" title="1、API"></a>1、API</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">swig.init(&#123;</span><br><span class="line">    allowErrors: <span class="literal">false</span>,</span><br><span class="line">    autoescape: <span class="literal">true</span>,</span><br><span class="line">    cache: <span class="literal">true</span>,</span><br><span class="line">    encoding: <span class="string">'utf8'</span>,</span><br><span class="line">    filters: &#123;&#125;,</span><br><span class="line">    root: <span class="string">'/'</span>,</span><br><span class="line">    tags: &#123;&#125;,</span><br><span class="line">    extensions: &#123;&#125;,</span><br><span class="line">    tzOffset: <span class="number">0</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>options:</p><ul><li><p><strong>allowErrors</strong>: 默认值为 false。将所有模板解析和编译错误直接输出到模板。如果为 true，则将引发错误，抛出到 Node.js 进程中，可能会使您的应用程序崩溃。</p></li><li><p>autoescape</p><p>:  默认true，强烈建议保持。字符转换表请参阅转义过滤器。</p><ul><li>true: HTML安全转义</li><li>false: 不转义，除非使用转义过滤器或者转义标签</li><li>‘js’: js安全转义</li></ul></li><li><p><strong>cache</strong>: 更改为 false 将重新编译每个请求的模板的文件。正式环境建议保持true。</p></li><li><p><strong>encoding</strong>: 模板文件编码</p></li><li><p><strong>root</strong>: 需要搜索模板的目录。如果模板传递给 swig.compileFile 绝对路径(以/开头)，Swig不会在模板root中搜索。如果传递一个数组，使用第一个匹配成功的数组项。</p></li><li><p><strong>tzOffset</strong>: 设置默认时区偏移量。此设置会使转换日期过滤器会自动的修正相应时区偏移量。</p></li><li><p><strong>filters</strong>:自定义过滤器或者重写默认过滤器，参见自定义过滤器指南。</p></li><li><p><strong>tags</strong>: 自定义标签或者重写默认标签，参见自定义标签指南。</p></li><li><p><strong>extensions</strong>: 添加第三方库，可以在编译模板时使用，参见参见自定义标签指南。</p></li></ul><h4 id="2、nodejs"><a href="#2、nodejs" class="headerlink" title="2、nodejs"></a>2、nodejs</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tpl = swig.compileFile(<span class="string">"path/to/template/file.html"</span>);</span><br><span class="line"><span class="keyword">var</span> renderedHtml = tpl.render(&#123; <span class="attr">vars</span>: <span class="string">'to be inserted in template'</span> &#125;);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tpl = swig.compile(<span class="string">"Template string here"</span>);</span><br><span class="line"><span class="keyword">var</span> renderedHtml = tpl(&#123; <span class="attr">vars</span>: <span class="string">'to be inserted in template'</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="3、结合Express"><a href="#3、结合Express" class="headerlink" title="3、结合Express"></a>3、结合Express</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br><span class="line">npm install consolidate</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.engine(<span class="string">'.html'</span>, cons.swig);</span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'html'</span>);</span><br></pre></td></tr></table></figure><h4 id="4、浏览器"><a href="#4、浏览器" class="headerlink" title="4、浏览器"></a>4、浏览器</h4><p>Swig浏览器版本的api基本与nodejs版相同，不同点如下：</p><ul><li><p>不能使用swig.compileFile，浏览器没有文件系统</p></li><li><p>你必须提前使用swig.compile编译好模板</p></li><li><p>按顺序使用extends, import, and include，同时在swig.compile里使用参数templateKey来查找模板</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> template = swig.compile(<span class="string">'&lt;p&gt;&#123;% block content %&#125;&#123;% endblock %&#125;&lt;/p&gt;'</span>, &#123; <span class="attr">filename</span>: <span class="string">'main'</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> mypage = swig.compile(<span class="string">'&#123;% extends "main" %&#125;&#123;% block content %&#125;Oh hey there!&#123;% endblock %&#125;'</span>, &#123; <span class="attr">filename</span>: <span class="string">'mypage'</span> &#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="二、基础"><a href="#二、基础" class="headerlink" title="二、基础"></a>二、基础</h3><h4 id="1、变量"><a href="#1、变量" class="headerlink" title="1、变量"></a>1、变量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; foo.bar &#125;&#125;</span><br><span class="line">&#123;&#123; foo[<span class="string">'bar'</span>] &#125;&#125;</span><br></pre></td></tr></table></figure><p>如果变量未定义，输出空字符。</p><p>变量可以通过过滤器来修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; name|title &#125;&#125; was born on &#123;&#123; birthday|date(<span class="string">'F jS, Y'</span>) &#125;&#125;</span><br><span class="line"><span class="comment">// Jane was born on July 6th, 1985</span></span><br></pre></td></tr></table></figure><h4 id="2、逻辑标签"><a href="#2、逻辑标签" class="headerlink" title="2、逻辑标签"></a>2、逻辑标签</h4><p>参见标签部分。</p><h4 id="3、注释"><a href="#3、注释" class="headerlink" title="3、注释"></a>3、注释</h4><h4 id="4、空白"><a href="#4、空白" class="headerlink" title="4、空白"></a>4、空白</h4><p>模板里的空白在最终输出时默认保留，如果需要去掉空白，可以在逻辑标签前后加上空白控制服-：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> item <span class="keyword">in</span> seq -%&#125;</span><br><span class="line">    &#123;&#123; item &#125;&#125;</span><br><span class="line">&#123;%- endfor %&#125;</span><br></pre></td></tr></table></figure><h3 id="三、模板继承"><a href="#三、模板继承" class="headerlink" title="三、模板继承"></a>三、模板继承</h3><p>Swig 使用 extends 和 block 来实现模板继承 <strong>layout.html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;% block title %&#125;My Site&#123;% endblock %&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    &#123;% block head %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"main.css"</span>&gt;</span></span><br><span class="line">    &#123;% endblock %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>index.html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends 'layout.html' %&#125;</span><br><span class="line">&#123;% block title %&#125;My Page&#123;% endblock %&#125;</span><br><span class="line">&#123;% block head %&#125;</span><br><span class="line">&#123;% parent %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"custom.css"</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is just an awesome page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><h3 id="四、变量过滤器"><a href="#四、变量过滤器" class="headerlink" title="四、变量过滤器"></a>四、变量过滤器</h3><p>用于修改变量。变量名称后用 | 字符分隔添加过滤器。您可以添加多个过滤器。</p><h4 id="1、例子"><a href="#1、例子" class="headerlink" title="1、例子"></a>1、例子</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; name|title &#125;&#125; was born on &#123;&#123; birthday|date('F jS, Y') &#125;&#125;</span><br><span class="line">and has &#123;&#123; bikes|length|default("zero") &#125;&#125; bikes.</span><br></pre></td></tr></table></figure><p>也可以使用 filter 标签来为块内容添加过滤器</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% filter upper %&#125;oh hi, paul&#123;% endfilter %&#125;</span><br></pre></td></tr></table></figure><h4 id="2、内置过滤器"><a href="#2、内置过滤器" class="headerlink" title="2、内置过滤器"></a>2、内置过滤器</h4><ul><li><p><strong>add(value)</strong>：使变量与value相加，可以转换为数值字符串会自动转换为数值。</p></li><li><p><strong>addslashes</strong>：用 \ 转义字符串</p></li><li><p><strong>capitalize</strong>：大写首字母</p></li><li><p><strong>date(format[, tzOffset])</strong>：转换日期为指定格式</p></li><li><p><strong>format</strong>：格式</p></li><li><p><strong>tzOffset</strong>：时区</p></li><li><p><strong>default(value)</strong>：默认值（如果变量为undefined，null，false）</p></li><li><p>escape([type])</p><p>：转义字符</p><ul><li>默认： &amp;, &lt;, &gt;, “, ‘</li><li>js: &amp;, &lt;, &gt;, “, ‘, =, -, ;</li></ul></li><li><p><strong>first</strong>：返回数组第一个值</p></li><li><p><strong>join(glue)</strong>：同[].join</p></li><li><p><strong>json_encode([indent])</strong>：类似JSON.stringify, indent为缩进空格数</p></li><li><p><strong>last</strong>：返回数组最后一个值</p></li><li><p><strong>length</strong>：返回变量的length，如果是object，返回key的数量</p></li><li><p><strong>lower</strong>：同’’.toLowerCase()</p></li><li><p><strong>raw</strong>：指定输入不会被转义</p></li><li><p><strong>replace(search, replace[, flags])</strong>：同’’.replace</p></li><li><p><strong>reverse</strong>：翻转数组</p></li><li><p><strong>striptags</strong>：去除html/xml标签</p></li><li><p><strong>title</strong>：大写首字母</p></li><li><p><strong>uniq</strong>：数组去重</p></li><li><p><strong>upper</strong>：同’’.toUpperCase</p></li><li><p><strong>url_encode</strong>：同encodeURIComponent</p></li><li><p><strong>url_decode</strong>：同decodeURIComponemt</p></li></ul><h4 id="3、自定义过滤器"><a href="#3、自定义过滤器" class="headerlink" title="3、自定义过滤器"></a>3、自定义过滤器</h4><p>创建一个 myfilter.js 然后引入到 Swig 的初始化函数中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swig.init(&#123; <span class="attr">filters</span>: <span class="built_in">require</span>(<span class="string">'myfilters'</span>) &#125;);</span><br></pre></td></tr></table></figure><p>在 myfilter.js 里，每一个 filter 方法都是一个简单的 js 方法，下例是一个翻转字符串的 filter：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.myfilter = <span class="function"><span class="keyword">function</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> input.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你的 filter 一旦被引入，你就可以向下面一样使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; name|myfilter &#125;&#125;</span><br><span class="line">     &#123;% filter myfilter %&#125;</span><br><span class="line">    I shall be filtered</span><br><span class="line">&#123;% endfilter %&#125;</span><br></pre></td></tr></table></figure><p>你也可以像下面一样给 filter 传参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exports.prefix = <span class="function"><span class="keyword">function</span>(<span class="params">input, prefix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prefix.toString() + input.toString();</span><br><span class="line">&#125;;</span><br><span class="line">&#123;&#123; name|prefix(<span class="string">'my prefix'</span>) &#125;&#125;</span><br><span class="line">&#123;% filter prefix <span class="string">'my prefix'</span> %I will be prefixed <span class="keyword">with</span> <span class="string">"my prefix"</span>.&#123;% endfilter %&#125;</span><br><span class="line">&#123;% filter prefix foo %&#125;I will be prefixed <span class="keyword">with</span> the value stored to <span class="string">`foo`</span>.&#123;% endfilter %&#125;</span><br></pre></td></tr></table></figure><h3 id="五、标签"><a href="#五、标签" class="headerlink" title="五、标签"></a>五、标签</h3><h4 id="1、内置标签"><a href="#1、内置标签" class="headerlink" title="1、内置标签"></a>1、内置标签</h4><p><strong>extends</strong>：使当前模板继承父模板，必须在文件最前</p><ul><li>参数file：父模板相对模板 root 的相对路径 <strong>block</strong>：定义一个块，使之可以被继承的模板重写，或者重写父模板的同名块</li><li>参数name：块的名字，必须以字母数字下划线开头 <strong>parent</strong>：将父模板中同名块注入当前块中 <strong>include</strong>：包含一个模板到当前位置，这个模板将使用当前上下文</li><li>参数file: 包含模板相对模板 root 的相对路径</li><li>参数ignore missing：包含模板不存在也不会报错</li><li>参数with x：设置 x 至根上下文对象以传递给模板生成。必须是一个键值对</li><li>参数only：限制模板上下文中用 with x 定义的参数</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include template_path %&#125;</span><br><span class="line">&#123;% include "path/to/template.js" %&#125;</span><br></pre></td></tr></table></figure><p>你可以标记 ignore missing，这样如果模板不存在，也不会抛出错误</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include "foobar.html" ignore missing %&#125;</span><br></pre></td></tr></table></figure><p>本地声明的上下文变量，默认情况不会传递给包含的模板。例如以下情况，inc.html 无法得到 foo 和 bar</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% set foo = "bar" %&#125;</span><br><span class="line">&#123;% include "inc.html" %&#125;</span><br><span class="line">&#123;% for bar in thing %&#125;</span><br><span class="line">    &#123;% include "inc.html" %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>如果想把本地声明的变量引入到包含的模板种，可以使用 with 参数来把后面的对象创建到包含模板的上下文中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% set foo = &#123; bar: "baz" &#125; %&#125;</span><br><span class="line">&#123;% include "inc.html" with foo %&#125;</span><br><span class="line">&#123;% for bar in thing %&#125;</span><br><span class="line">    &#123;% include "inc.html" with bar %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>如果当前上下文中 foo 和 bar 可用，下面的情况中，只有 foo 会被 inc.html 定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include "inc.html" with foo only %&#125;</span><br></pre></td></tr></table></figure><p>only 必须作为最后一个参数，放在其他位置会被忽略</p><p><strong>raw</strong>：停止解析标记中任何内容，所有内容都将输出</p><ul><li>参数file: 父模板相对模板 root 的相对路径 <strong>for</strong>：遍历对象和数组</li><li>参数x：当前循环迭代名</li><li>参数in：语法标记</li><li>参数y：可迭代对象。可以使用过滤器修改</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for x in y %&#125;</span><br><span class="line">    &#123;% if loop.first %&#125;<span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;% endif %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; loop.index &#125;&#125; - &#123;&#123; loop.key &#125;&#125;: &#123;&#123; x &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% if loop.last %&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span>&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>特殊循环变量</p><ul><li>loop.index：当前循环的索引（1开始）</li><li>loop.index0：当前循环的索引（0开始）</li><li>loop.revindex：当前循环从结尾开始的索引（1开始）</li><li>loop.revindex0：当前循环从结尾开始的索引（0开始）</li><li>loop.key：如果迭代是对象，是当前循环的键，否则同 loop.index</li><li>loop.first：如果是第一个值返回 true</li><li>loop.last：如果是最后一个值返回 true</li><li>loop.cycle：一个帮助函数，以指定的参数作为周期 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```html</span><br><span class="line">&#123;% for item in items %&#125;</span><br><span class="line">    &lt;li class=&quot;&#123;&#123; loop.cycle(&apos;odd&apos;, &apos;even&apos;) &#125;&#125;&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>在 for 标签里使用 else</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for person in people %&#125;</span><br><span class="line">    &#123;&#123; person &#125;&#125;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    There are no people yet!</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p><strong>if</strong>：条件语句</p><ul><li>参数：接受任何有效的 JavaScript 条件语句，以及一些其他人类可读语法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> x %&#125;&#123;% endif %&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> !x %&#125;&#123;% endif %&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> not x %&#125;&#123;% endif %&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> x and y %&#125;&#123;% endif %&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> x &amp;&amp; y %&#125;&#123;% endif %&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> x or y %&#125;&#123;% endif %&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> x || y %&#125;&#123;% endif %&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> x || (y &amp;&amp; z) %&#125;&#123;% endif %&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> x [operator] y %&#125;</span><br><span class="line">    Operators: ==, !=, &lt;, &lt;=, &gt;, &gt;=, ===, !==</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> x == <span class="string">'five'</span> %&#125;</span><br><span class="line">    The operands can be also be string or number literals</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> x|length === <span class="number">3</span> %&#125;</span><br><span class="line">    You can use filters on any operand <span class="keyword">in</span> the statement.</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> x <span class="keyword">in</span> y %&#125;</span><br><span class="line">    If x is a value that is present <span class="keyword">in</span> y, <span class="keyword">this</span> will <span class="keyword">return</span> <span class="literal">true</span>.</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>else 和 else if</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if foo %&#125;</span><br><span class="line">    Some content.</span><br><span class="line">&#123;% else if "foo" in bar %&#125;</span><br><span class="line">    Content if the array `bar` has "foo" in it.</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    Fallback content.</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p><strong>autoescape</strong>：改变当前变量的自动转义行为</p><ul><li>参数on：当前内容是否转义</li><li>参数type：转义类型，js 或者 html，默认 html</li></ul><p>假设</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_html_output = '<span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello "you" &amp; \'them\'<span class="tag">&lt;/<span class="name">p</span>&gt;</span>';</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% autoescape false %&#125;</span><br><span class="line">    &#123;&#123; some_html_output &#125;&#125;</span><br><span class="line">&#123;% endautoescape %&#125;</span><br><span class="line">&#123;% autoescape true %&#125;</span><br><span class="line">    &#123;&#123; some_html_output &#125;&#125;</span><br><span class="line">&#123;% endautoescape %&#125;</span><br><span class="line">&#123;% autoescape true "js" %&#125;</span><br><span class="line">    &#123;&#123; some_html_output &#125;&#125;</span><br><span class="line">&#123;% endautoescape %&#125;</span><br></pre></td></tr></table></figure><p>将会输出</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello "you" &amp; 'them'<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> &amp;lt;p&amp;gt;Hello &amp;quot;you&amp;quot; &amp;amp; &amp;#39;them&amp;#39; &amp;lt;/p&amp;gt;</span><br><span class="line"> \u003Cp\u003EHello \u0022you\u0022 &amp; \u0027them\u0027\u003C\u005Cp\u003E</span><br></pre></td></tr></table></figure><p><strong>set</strong>：设置一个变量，在当前上下文中复用</p><ul><li>参数name：变量名</li><li>参数=：语法标记</li><li>参数value：变量值</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% set foo = [0, 1, 2, 3, 4, 5] %&#125; &#123;% for num in foo %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p><strong>macro</strong>：创建自定义可服用的代码段</p><ul><li>参数…: 用户定义</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% macro input type name id label value error %&#125;</span><br><span class="line"> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"&#123;&#123; name &#125;&#125;"</span>&gt;</span>&#123;&#123; label &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"&#123;&#123; type &#125;&#125;"</span> <span class="attr">name</span>=<span class="string">"&#123;&#123; name &#125;&#125;"</span> <span class="attr">id</span>=<span class="string">"&#123;&#123; id &#125;&#125;"</span> <span class="attr">value</span>=<span class="string">"&#123;&#123; value &#125;&#125;"</span>&#123;% <span class="attr">if</span> <span class="attr">error</span> %&#125; <span class="attr">class</span>=<span class="string">"error"</span>&#123;% <span class="attr">endif</span> %&#125;&gt;</span></span><br><span class="line">&#123;% endmacro %&#125;</span><br></pre></td></tr></table></figure><p>然后像下面使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123; input("text", "fname", "fname", "First Name", fname.value, fname.errors) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123; input("text", "lname", "lname", "Last Name", lname.value, lname.errors) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"fname"</span>&gt;</span>First Name<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"fname"</span> <span class="attr">id</span>=<span class="string">"fname"</span> <span class="attr">value</span>=<span class="string">"Paul"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"lname"</span>&gt;</span>Last Name<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"lname"</span> <span class="attr">id</span>=<span class="string">"lname"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>import</strong>：允许引入另一个模板的宏进入当前上下文</p><ul><li>参数file：引入模板相对模板 root 的相对路径</li><li>参数as：语法标记 var: 分配给宏的可访问上下文对象</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% import 'formmacros.html' as form %&#125;</span><br><span class="line">&#123;# this will run the input macro #&#125;</span><br><span class="line">    &#123;&#123; form.input("text", "name") &#125;&#125;</span><br><span class="line">    &#123;# this, however, will NOT output anything because the macro is scoped to the "form"     object: #&#125;</span><br><span class="line">&#123;&#123; input("text", "name") &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>filter</strong>：对整个块应用过滤器</p><ul><li>参数filter_name: 过滤器名字</li><li>参数… : 若干传给过滤器的参数 父模板相对模板 root 的相对路径</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% filter uppercase %&#125;</span><br><span class="line">    oh hi, &#123;&#123; name &#125;&#125;</span><br><span class="line">&#123;% endfilter %&#125;</span><br><span class="line">&#123;% filter replace "." "!" "g" %&#125;</span><br><span class="line">    Hi. My name is Paul.</span><br><span class="line">&#123;% endfilter %&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OH HI, PAUL Hi! My name is Paul!</span><br></pre></td></tr></table></figure><p><strong>spaceless</strong>：尝试移除html标签间的空格</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% spaceless %&#125;</span><br><span class="line">    &#123;% for num in foo %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; loop.index &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&#123;% endspaceless %&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>转自：<a href="http://www.iqianduan.net/blog/how_to_use_swig" target="_blank" rel="noopener">http://www.iqianduan.net/blog/how_to_use_swig</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Swig-使用指南&quot;&gt;&lt;a href=&quot;#Swig-使用指南&quot; class=&quot;headerlink&quot; title=&quot;Swig 使用指南&quot;&gt;&lt;/a&gt;Swig 使用指南&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
               
      
    
    </summary>
    
    
      <category term="js 模板" scheme="https://tianjiec.top/tags/js-%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>代码规范，编程规范</title>
    <link href="https://tianjiec.top/2019/03/09/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%EF%BC%8C%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    <id>https://tianjiec.top/2019/03/09/代码规范，编程规范/</id>
    <published>2019-03-09T14:14:03.000Z</published>
    <updated>2019-03-09T14:44:03.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Google提出"><a href="#Google提出" class="headerlink" title="Google提出"></a>Google提出</h3><h5 id="1、使用空格代替tab"><a href="#1、使用空格代替tab" class="headerlink" title="1、使用空格代替tab"></a>1、使用空格代替tab</h5><p>除了每一行的终止符序列，ASCII水平空格符（0x20）是唯一一个可以出现在源文件中任意位置的空格字符。这也意味着，tab字符不应该被使用，以及被用来控制缩进。</p><p>规范随后指出应该使用2个，而不是4个空格带实现缩进。</p><h5 id="2、不能省略分号"><a href="#2、不能省略分号" class="headerlink" title="2、不能省略分号"></a>2、不能省略分号</h5><p>每个语句必须以分号结尾。不允许依赖于JS自动添加分号的功能。</p><p>尽管我不明白为什么会有人反对这个规则，但目前分号的使用问题显然已经像“空格 vs tab”这个问题一样产生了巨大的争议。而Google对此表示分号是必须的，是不可省略的。</p><h5 id="3、不推荐代码水平对齐"><a href="#3、不推荐代码水平对齐" class="headerlink" title="3、不推荐代码水平对齐"></a>3、不推荐代码水平对齐</h5><h5 id="4、杜绝var"><a href="#4、杜绝var" class="headerlink" title="4、杜绝var"></a>4、杜绝var</h5><p>使用const或者let来声明所有局部变量。如果变量不需要被重新赋值，默认应该是用const。</p><h5 id="5、优先使用箭头函数"><a href="#5、优先使用箭头函数" class="headerlink" title="5、优先使用箭头函数"></a>5、优先使用箭头函数</h5><p>箭头函数提供了一种简洁的语法，并且避免了一些关于this指向的问题。相比较与function关键字，开发者应该优先使用箭头函数来声明函数，尤其是声明嵌套函数。</p><h5 id="6、使用模板字符串取代连接字符串"><a href="#6、使用模板字符串取代连接字符串" class="headerlink" title="6、使用模板字符串取代连接字符串"></a>6、使用模板字符串取代连接字符串</h5><p><code>123{$a}321</code> 取代’123’+a+’321’</p><h5 id="7、命名规范"><a href="#7、命名规范" class="headerlink" title="7、命名规范"></a>7、命名规范</h5><p><strong>常量</strong>：全大写</p><p><strong>项目名</strong>：小写+_</p><p><strong>目录命名</strong>：小写+_</p><p><strong>JS**</strong>文件命名<em>**</em>：变量：必须使用小驼峰命名语法 maxCount 浅显易懂</p><p><strong>函数</strong>：小驼峰命名语法；前缀应该是动词 can has is get set load 等</p><p><strong>类&amp;构造函数</strong>: 大驼峰式命名，首字母大写 Person</p><p><strong>类成员</strong>：公共属性和方法：跟变量函数命名方式一样</p><p>​        私有属性和方法：前缀为_(下划线)，谋面跟公有属性一样命名方式</p><h5 id="8、每次值声明一个变量"><a href="#8、每次值声明一个变量" class="headerlink" title="8、每次值声明一个变量"></a>8、每次值声明一个变量</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h5 id="9、使用单引号"><a href="#9、使用单引号" class="headerlink" title="9、使用单引号"></a>9、使用单引号</h5><p>只允许使用单引号包裹普通字符串，禁止使用双引号。如果字符串中包含单引号字符，应该使用模板字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> directive = <span class="string">"No identification of self or mission."</span></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> saying = <span class="string">'Say it ain\u0027t so.'</span>;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> directive = <span class="string">'No identification of self or mission.'</span>;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> saying = <span class="string">`Say it ain't so`</span>;</span><br></pre></td></tr></table></figure><p>#### </p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h5 id="1、定义数组：用"><a href="#1、定义数组：用" class="headerlink" title="1、定义数组：用[]"></a>1、定义数组：用[]</h5><p>使用数组字面量[] 创建新数组，除非想要穿件指定大小的数组</p><p>遍历数组不能用forin：数组里面存在数字之外的属性 会得到不正确的结果</p><h5 id="2、函数长度应该控制在50行以内"><a href="#2、函数长度应该控制在50行以内" class="headerlink" title="2、函数长度应该控制在50行以内"></a>2、函数长度应该控制在50行以内</h5><h5 id="3、参数设计应该控制在6个以内"><a href="#3、参数设计应该控制在6个以内" class="headerlink" title="3、参数设计应该控制在6个以内"></a>3、参数设计应该控制在6个以内</h5><h5 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h5><p>​    在适当的时候将闭包内对象置位null</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Google提出&quot;&gt;&lt;a href=&quot;#Google提出&quot; class=&quot;headerlink&quot; title=&quot;Google提出&quot;&gt;&lt;/a&gt;Google提出&lt;/h3&gt;&lt;h5 id=&quot;1、使用空格代替tab&quot;&gt;&lt;a href=&quot;#1、使用空格代替tab&quot; class
      
    
    </summary>
    
    
      <category term="js" scheme="https://tianjiec.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Vue双向数据绑定整理</title>
    <link href="https://tianjiec.top/2019/03/08/Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%95%B4%E7%90%86/"/>
    <id>https://tianjiec.top/2019/03/08/Vue双向数据绑定整理/</id>
    <published>2019-03-08T15:33:41.000Z</published>
    <updated>2019-03-08T15:33:52.846Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue双向数据绑定原理"><a href="#Vue双向数据绑定原理" class="headerlink" title="Vue双向数据绑定原理"></a>Vue双向数据绑定原理</h3><p>数据绑定做法：</p><table><thead><tr><th>发布者-订阅者模式（backbone.js）</th></tr></thead><tbody><tr><td>脏值检查（angular.js）</td></tr><tr><td>数据劫持（vue.js）</td></tr></tbody></table><h4 id="发布者-订阅者模式"><a href="#发布者-订阅者模式" class="headerlink" title="发布者-订阅者模式"></a>发布者-订阅者模式</h4><blockquote><p>一般通过sub、pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是vm.set(‘prperty’,value)</p><p>这种方法比较low，我们希望直接vm.property = value 这种方式更新数据，同时自动更新视图，于是就有了下面两种方法</p></blockquote><h4 id="脏值检查"><a href="#脏值检查" class="headerlink" title="脏值检查"></a>脏值检查</h4><blockquote><p>angular.js 是通过脏值检测方式对比数据是否有变更，来决定是否更新视图，最简单的方式是通过setInterval()定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时才会进入脏值检测，大致如下：</p><p>​    DOM事件，譬如用户输入文本，点击按钮等。（ng-click）</p><p>​    XHR响应事件（$http）</p><p>​    浏览器Location变更事件($interval)</p><p>​    Timer事件($timeout,$apply)</p><p>​    执行$digest() 或 $apply()</p></blockquote><h4 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h4><blockquote><p>vue.js则是通过数据劫持来结合发布者订阅者模式的方式通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动的时候发布消息给订阅者，触发相应的监听回调。</p></blockquote><p>思路：</p><p>核心是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的。</p><p>过程： 1、实现一个数据监听器Observer，能够对数据对象所有属性进行监听，如有变动可拿到最新值并通知订阅者</p><p>2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</p><p>3、实现一个Watcher，作为连接Observer和Complie的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</p><p>4、mvvm入口函数，整合上述三者</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vue双向数据绑定原理&quot;&gt;&lt;a href=&quot;#Vue双向数据绑定原理&quot; class=&quot;headerlink&quot; title=&quot;Vue双向数据绑定原理&quot;&gt;&lt;/a&gt;Vue双向数据绑定原理&lt;/h3&gt;&lt;p&gt;数据绑定做法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;
      
    
    </summary>
    
    
      <category term="vue" scheme="https://tianjiec.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>学习计划</title>
    <link href="https://tianjiec.top/2019/03/06/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>https://tianjiec.top/2019/03/06/学习计划/</id>
    <published>2019-03-06T13:42:09.000Z</published>
    <updated>2019-03-06T13:45:15.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="短期"><a href="#短期" class="headerlink" title="短期"></a>短期</h2><blockquote><p>熟悉项目</p><p>看vue文档，学习vue知识</p><p>复习html、css基础核心（css样式层叠、继承，盒模型、容器，溢出及元素类型；浏览器兼容及元宽高自适应；锚点    与透明；图片整合；表格，CSS属性与滤镜）</p><p>html5+css3（新增元素和属性、表单域增强元素；css3选择器；文字字体相关样式；css3位移与变形处理；css3 2D转换与过度动画；css3 3D转换与关键帧动画、弹性盒模型；媒体查询；响应式设计）</p></blockquote><h2 id="长期"><a href="#长期" class="headerlink" title="长期"></a>长期</h2><blockquote><p>培养逻辑能力</p><p>看thinkinjava</p></blockquote><p>1、层叠</p><blockquote><p>：CSS中的层叠就是让多个来源的样式叠加在一起，然后结合样式的特殊性（后面详细介绍）、继承性，确定最终应用的样式。</p></blockquote><p>2、定位</p><table><thead><tr><th>定位position</th><th>说明</th></tr></thead><tbody><tr><td>绝对定位absolute</td><td>给它一个<code>left top</code>相对浏览器跑<br>如果子盒想相对父盒子跑，子盒子为<code>relative</code>父盒子不设值<br>或者子盒子设置<code>absolute</code>，父盒子是<code>relative</code>（子绝父相）</td></tr><tr><td>相对定位relative</td><td>给他一个left、top相对父盒子跑</td></tr><tr><td>固定定位fixed</td><td>相对于屏幕 固定在屏幕某个地方</td></tr></tbody></table><p>3、溢出</p><blockquote><p>文本：overflow换行溢出：隐藏hidden；显示visible；自动auto出现滚动条 ； overflow-x/overflow-y：hidden出现水平/垂直滚动条；</p><p>文本溢出省略：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">/*1.单行溢出隐藏显示...(在文字的容器上设置)*/</span></span><br><span class="line">&gt; <span class="selector-class">.text-box1</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">&gt;  white-space: nowrap;      /*超出的空白区域不换行*/</span><br><span class="line">&gt;  <span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;         <span class="comment">/*超出隐藏*/</span></span><br><span class="line">&gt;  <span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;  <span class="comment">/*文本超出显示省略号*/</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &lt;!<span class="selector-tag">--</span>多行溢出隐藏显示...（只兼容<span class="selector-tag">webkit</span>内核的浏览器）<span class="selector-tag">--</span>&gt;</span><br><span class="line">&gt; <span class="selector-class">.text-box2</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">&gt;  display: -webkit-box;             /*将对象转为弹性盒模型展示*/</span><br><span class="line">&gt;  <span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;     <span class="comment">/*设置弹性盒模型子元素的排列方式*/</span></span><br><span class="line">&gt;  <span class="selector-tag">-webkit-line-clamp</span>: 2;            <span class="comment">/*限制文本行数*/</span></span><br><span class="line">&gt;  <span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;                 <span class="comment">/*超出隐藏*/</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &lt;!<span class="selector-tag">--</span>多行溢出隐藏显示...(跨浏览器兼容+伪元素定位)<span class="selector-tag">--</span>&gt;</span><br><span class="line">&gt; &lt;div class="box text-box3"&gt;</span><br><span class="line">&gt;  &lt;p&gt;目录结构清晰是首要目标，至于命名只要能达到表意的目的即可。目录结构&lt;/p&gt;            </span><br><span class="line">&gt; &lt;/div&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">/*3.多行溢出隐藏显示...(跨浏览器兼容+伪元素定位)*/</span></span><br><span class="line">&gt; <span class="selector-class">.text-box3</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">&gt;  position: relative;</span><br><span class="line">&gt;  <span class="selector-tag">line-height</span>: 1<span class="selector-class">.4em</span>;        <span class="comment">/*行高和height成倍数，这里以三行文本超出隐藏举例*/</span></span><br><span class="line">&gt;  <span class="selector-tag">height</span>: 4<span class="selector-class">.2em</span>;</span><br><span class="line">&gt;  <span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="selector-class">.text-box3</span> <span class="selector-tag">p</span><span class="selector-pseudo">::after</span>&#123;         <span class="comment">/*若要兼容IE8需用:after*/</span></span><br><span class="line">&gt;  content: "...";          /*替换内容比较灵活*/</span><br><span class="line">&gt;  <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">&gt;  <span class="selector-tag">bottom</span>: 2<span class="selector-tag">px</span>;</span><br><span class="line">&gt;  <span class="selector-tag">right</span><span class="selector-pseudo">:5px</span>;</span><br><span class="line">&gt;  <span class="selector-tag">padding</span>: 0 3<span class="selector-tag">px</span>;</span><br><span class="line">&gt;  <span class="selector-tag">background</span>:<span class="selector-id">#fff</span>;         <span class="comment">/*颜色和文字背景保持一致*/</span></span><br><span class="line">&gt;  <span class="selector-tag">box-shadow</span>: 0 0 10<span class="selector-tag">px</span> <span class="selector-id">#fff</span>;  <span class="comment">/*边缘处理*/</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; 借鉴博文：https://blog.csdn.net/sinat_38426472/article/details/79654816</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>图片：</p><p>overflow:hidden 超出裁剪</p><p>未加定位从左上按原像素开始显示</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;短期&quot;&gt;&lt;a href=&quot;#短期&quot; class=&quot;headerlink&quot; title=&quot;短期&quot;&gt;&lt;/a&gt;短期&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;熟悉项目&lt;/p&gt;
&lt;p&gt;看vue文档，学习vue知识&lt;/p&gt;
&lt;p&gt;复习html、css基础核心（css样式层叠、
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博客平台移动端</title>
    <link href="https://tianjiec.top/2019/03/03/%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    <id>https://tianjiec.top/2019/03/03/博客平台移动端/</id>
    <published>2019-03-03T03:18:38.000Z</published>
    <updated>2019-03-03T03:20:32.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>宽度查询onresize 在宽度小于900px时候 自动跳转到移动端页面reload</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;宽度查询onresize 在宽度小于900px时候 自动跳转到移动端页面reload&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>express博客应用markdown插件</title>
    <link href="https://tianjiec.top/2019/03/03/express%E5%8D%9A%E5%AE%A2%E5%BA%94%E7%94%A8markdown%E6%8F%92%E4%BB%B6/"/>
    <id>https://tianjiec.top/2019/03/03/express博客应用markdown插件/</id>
    <published>2019-03-03T00:20:30.000Z</published>
    <updated>2019-03-03T01:18:36.671Z</updated>
    
    <content type="html"><![CDATA[<h3 id="博客-markdown"><a href="#博客-markdown" class="headerlink" title="博客+markdown"></a>博客+markdown</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 博客平台文章txt显示太丑，用html去写文章再用swig模板语言&#123;% autoescape %&#125;&#123;&#123; content.content&#125;&#125;&#123;% endautoescape %&#125;去显示可以 但是 写文章时候太麻烦</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>所以可借用markdown相关插件 用markdown写 转成 html显示</p></blockquote><h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><p>借助bootstrap-markdown</p><p>在页面中引入bootstrap相关文件，jquery，以及bootstrap-markdown.min.css和bootstrap-markdown.js文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"bootstrap-markdown.min.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/bootstrap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"bootstrap-markdown.js"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;--使用Bootstrap-Markdown比那家亲的方法非常简单，你只需要在一个\&lt;textarea/&gt;元素中设置data-provide="markdown"属性，它就可以自动转换为Markdown编辑器。--&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">data-provide</span>=<span class="string">"markdown"</span> <span class="attr">rows</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果要制作一个内联的Markdown编辑器，可以添加data-provide=”markdown-editable”属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div data-provide=&quot;markdown-editable&quot;&gt;</span><br><span class="line">  &lt;h3&gt;这是可以编辑的标题&lt;/h3&gt;</span><br><span class="line">  &lt;p&gt;所有在 &quot;markdown-editable&quot; 这个div中的内容都是可以编辑的。&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="初始化插件"><a href="#初始化插件" class="headerlink" title="初始化插件"></a>初始化插件</h5><p>你也可以通过js的方式来初始化该Markdown编辑器插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#some-textarea&quot;).markdown(&#123;autofocus:false,savable:false&#125;)</span><br></pre></td></tr></table></figure><h2 id="看"><a href="#看" class="headerlink" title="看"></a>看</h2><h4 id="markdown转HTML-使用editor-md"><a href="#markdown转HTML-使用editor-md" class="headerlink" title="markdown转HTML(使用editor.md)"></a>markdown转HTML(使用editor.md)</h4><p>editor.md网站地址<a href="http://pandao.github.io/editor.md/" target="_blank" rel="noopener">http://pandao.github.io/editor.md/</a></p><p>首先需要引入对应的css跟js文件，jquery一定要在前面引入</p><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入样式文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"editor.md-master/examples/css/style.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"editor.md-master/css/editormd.preview.css"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入js文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/examples/js/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/lib/marked.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/lib/prettify.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/lib/raphael.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/lib/underscore.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/lib/sequence-diagram.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/lib/flowchart.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/lib/jquery.flowchart.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"editor.md-master/editormd.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--输入需要转换的markdown文件开始--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>转换前<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"demo1"</span> <span class="attr">style</span>=<span class="string">"width:800px;height:300px;"</span>&gt;</span></span><br><span class="line">hadoop命令需在hadoop目录下使用</span><br><span class="line">        **常用命令**</span><br><span class="line">        HDFS格式化:</span><br><span class="line">bin/hadoop namenode -format    格式化namenode</span><br><span class="line">bin/hadoop datanode -format    格式化datanode</span><br><span class="line"></span><br><span class="line">*如不是第一次格式化，为了保证clusterID一致性,</span><br><span class="line">*需先删除hdfs临时目录,</span><br><span class="line">*即在配置文件中配置的hadoop.tmp.dir参数路径</span><br><span class="line">    <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!--输入需要转换的markdown文件结束--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--点击该按钮进行转换--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"mdToHml();"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>点击转Html<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>=================  华丽丽的分割线 ====================<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>转换后<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在该div中展示,如有初始化的数据可以放在textarea中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"testEditorMdview"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"appendTest"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--js开始--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//markDown转HTMl的方法</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">mdToHml</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//先对容器初始化，在需要展示的容器中创建textarea隐藏标签，</span></span></span><br><span class="line"><span class="xml">        $("#testEditorMdview").html('<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"appendTest"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span>');</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> content=$(<span class="string">"#demo1"</span>).val();<span class="comment">//获取需要转换的内容</span></span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#appendTest"</span>).val(content);<span class="comment">//将需要转换的内容加到转换后展示容器的textarea隐藏标签中</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//转换开始,第一个参数是上面的div的id</span></span></span><br><span class="line"><span class="javascript">        editormd.markdownToHTML(<span class="string">"testEditorMdview"</span>, &#123;</span></span><br><span class="line"><span class="javascript">            htmlDecode: <span class="string">"style,script,iframe"</span>, <span class="comment">//可以过滤标签解码</span></span></span><br><span class="line"><span class="javascript">            emoji: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">            taskList:<span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">            tex: <span class="literal">true</span>,               <span class="comment">// 默认不解析</span></span></span><br><span class="line"><span class="javascript">            flowChart:<span class="literal">true</span>,         <span class="comment">// 默认不解析</span></span></span><br><span class="line"><span class="javascript">            sequenceDiagram:<span class="literal">true</span>,  <span class="comment">// 默认不解析</span></span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--js结束--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编译hexo博客时遇到的坑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;%%&#125; 语法文章不能直接放入 需要放在 代码里面，不然编译报错，应该是hexo的markdown转html会读到这些语法进行解析，解析报错。。。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;博客-markdown&quot;&gt;&lt;a href=&quot;#博客-markdown&quot; class=&quot;headerlink&quot; title=&quot;博客+markdown&quot;&gt;&lt;/a&gt;博客+markdown&lt;/h3&gt;&lt;blockquote&gt;
&lt;figure class=&quot;highlight
      
    
    </summary>
    
    
      <category term="博客" scheme="https://tianjiec.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>面试题总结</title>
    <link href="https://tianjiec.top/2019/02/26/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://tianjiec.top/2019/02/26/面试题总结/</id>
    <published>2019-02-26T12:51:36.000Z</published>
    <updated>2019-02-27T11:56:30.304Z</updated>
    
    <content type="html"><![CDATA[<p>1、函数变量提升优先于值变量提升，提升到作用域最前面<br>2、在react框架里面用的比较多的es6语法</p><blockquote><p>箭头函数，解构赋值，map方法。</p></blockquote><p>3、箭头this函数和普通函数区别，<br>4、map和foreach区别，map有返回值，返回新数组。为什么react用map ，<br>5、promise怎么传值  在这里面<br>6、 es6之前块级作用域，try catch</p><blockquote><p>catch中catch部分是属于块级作用域 error只在 其中有效 </p></blockquote><p>7、 this的理解<br>8、git的使用<br>9、 react 中setdate是异步还是同步的 异步 第二个参数作用 在这里面是setdate之后的状态。</p><p>10、组件复用怎么更新数据</p><p>业务、项目模块建议、总结、学习新知识分享、专业外相关知识学习</p><p>个人总结向其它方向发展</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、函数变量提升优先于值变量提升，提升到作用域最前面&lt;br&gt;2、在react框架里面用的比较多的es6语法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;箭头函数，解构赋值，map方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、箭头this函数和普通函数区别，&lt;br&gt;4、m
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>反向代理</title>
    <link href="https://tianjiec.top/2019/02/24/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://tianjiec.top/2019/02/24/反向代理/</id>
    <published>2019-02-24T13:36:10.000Z</published>
    <updated>2019-02-24T13:47:22.002Z</updated>
    
    <content type="html"><![CDATA[<p>针对于nginx来说</p><p><strong>什么是代理服务器</strong>？</p><blockquote><p>所谓代理服务器就是位于发起请求的客户端与原始服务器端之间的一台跳板服务器，正向代理可以隐藏客户端，反向代理可以隐藏原始服务器。</p></blockquote><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><blockquote><p>正常国内电脑访问谷歌访问不了</p><p>-&gt; 国外服务器可以访问谷歌</p><p>-&gt; 我的国内电脑远程操作服务器 来达到 国内访问谷歌目的（比较累）</p><p>-&gt; 我的国内电脑访问服务器 服务器帮我请求google并返回数据（正向代理）</p></blockquote><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><blockquote><p>反向代理与正向代理是相对的。正向代理是替代客户端去发送请求，二反向代理是替代理服务器接受客户端的请求</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://5b0988e595225.cdn.sohucs.com/images/20180614/3623fd7079f948d1bfa9046c1d4260d4.jpeg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure></blockquote><p>这时候这台代理服务器其实不掌握在我们用户手里了，而是google专门用来接受请求，同时还可以作为过滤不正常的请求，防止你们黑的的一个服务器。对我们客户端来说，不掌握在我手里的东西都是别人的，所以这台服务器是反向的</p><p>假如说正向代理是黑客手里的攻击长矛，反向代理就是google握着的一个盾牌</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;针对于nginx来说&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是代理服务器&lt;/strong&gt;？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所谓代理服务器就是位于发起请求的客户端与原始服务器端之间的一台跳板服务器，正向代理可以隐藏客户端，反向代理可以隐藏原始服务器。&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
    
      <category term="服务器" scheme="https://tianjiec.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>简历</title>
    <link href="https://tianjiec.top/2019/02/13/%E7%AE%80%E5%8E%86/"/>
    <id>https://tianjiec.top/2019/02/13/简历/</id>
    <published>2019-02-13T12:55:06.000Z</published>
    <updated>2019-02-22T11:00:32.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h3><blockquote><h5 id="姓名：罗中运-年龄：24"><a href="#姓名：罗中运-年龄：24" class="headerlink" title="姓名：罗中运   年龄：24"></a>姓名：<strong>罗中运</strong>   年龄：24</h5><p><strong>毕业院校</strong>： 鲁东大学 信息与电气工程学院 （2015.9 ~ 2019.6）</p><p><strong>专业</strong>： 软件工程</p><p><strong>学历</strong>：本科</p><p><strong>联系方式</strong>：17853516710    |   luozy1230@163.com</p></blockquote><h3 id="求职意向"><a href="#求职意向" class="headerlink" title="求职意向"></a>求职意向</h3><blockquote><p>期望职位：HTML5 开发工程师</p><p>目前状况：可立即上岗</p></blockquote><h3 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h3><blockquote><p> 1、熟悉div+css，html基本布局；掌握html5+css3新特性，根据设计图完成页面制作；</p><p> 2、熟练响应式布局和弹性盒布局</p><p> 3、熟练掌握javascript，jQuery各种方法</p><p> 4、熟悉面向对象，理解mvc模式mvvm模式</p><p> 5、掌握bootstrap，曾运用bootstrap进行后端开发实现响应式布局；熟练使用jQuery，运用jQuery实现对dom操作，请求数据并对数据进行相应渲染</p><p> 6、熟练运用swiper、animate.css、mint.ui、axios插件对项目进行快速开发</p><p> 7、熟练掌握MySQL、mongodb数据库、熟练运用localstorage、cookie</p><p> 8、熟练运用ajax、jsonp、json</p><p> 9、熟练vue、react框架，掌握vuex、redux对数据进行处理</p><p> 10、熟练VSCode、Sublime、Hbuilder、Navicat、Photoshop、谷歌插件工具；熟练使用less、sass、gulp等工具辅助编程</p><p> 11、熟悉java、对php、c语言有一定了解</p><p> 12、熟悉git、github版本控制、了解SVN；熟悉swig、ejs模板语言</p></blockquote><h3 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h3><blockquote><h5 id="1、做过大量静态页面"><a href="#1、做过大量静态页面" class="headerlink" title="1、做过大量静态页面"></a>1、做过大量静态页面</h5><h5 id="2、bootstrap-express等-博客项目"><a href="#2、bootstrap-express等-博客项目" class="headerlink" title="2、bootstrap+express等 博客项目"></a>2、bootstrap+express等 博客项目</h5><h5 id="3、仿淘票票的vue项目"><a href="#3、仿淘票票的vue项目" class="headerlink" title="3、仿淘票票的vue项目"></a>3、仿淘票票的vue项目</h5><p>​    所用技术：</p><p>​    1、vue-router实现单页面应用，</p><p>​    2、借用axios请求数据</p><p>​    3、用mint-ui、swiper快速添加成熟组件，animate添加动作</p><p>​    4、标签键值对、传函数、自定义事件，bus总线、vuex实现组件间传值</p><p>​    5、公共组件复用，rem布局</p><p>​    地址：<a href="http://106.13.43.222/taopiaopiao" target="_blank" rel="noopener">http://106.13.43.222/taopiaopiao</a></p><h5 id="4、仿识货的react项目"><a href="#4、仿识货的react项目" class="headerlink" title="4、仿识货的react项目"></a>4、仿识货的react项目</h5><p>​    所用技术：</p><p>​    1、用react-router-dom实现页面跳转</p><p>​    2、借助react-redux对数据进行管理</p><p>​    3、借助axios请求数据</p><p>​    地址：<a href="http://106.13.43.222/shihuo/" target="_blank" rel="noopener">http://106.13.43.222/shihuo/</a></p></blockquote><h3 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h3><blockquote><p>对前沿技术有浓厚兴趣，非常看重写代码时的注释。自主解决bug能力较强。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;个人信息&quot;&gt;&lt;a href=&quot;#个人信息&quot; class=&quot;headerlink&quot; title=&quot;个人信息&quot;&gt;&lt;/a&gt;个人信息&lt;/h3&gt;&lt;blockquote&gt;
&lt;h5 id=&quot;姓名：罗中运-年龄：24&quot;&gt;&lt;a href=&quot;#姓名：罗中运-年龄：24&quot; class=
      
    
    </summary>
    
    
      <category term="简历" scheme="https://tianjiec.top/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>vue常用插件</title>
    <link href="https://tianjiec.top/2019/02/06/vue%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://tianjiec.top/2019/02/06/vue常用插件/</id>
    <published>2019-02-06T12:44:59.000Z</published>
    <updated>2019-02-06T12:46:38.853Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener">element</a> ★13489 - 饿了么出品的Vue2的web UI工具套件</li><li><a href="https://github.com/airyland/vux" target="_blank" rel="noopener">Vux</a> ★8133 - 基于Vue和WeUI的组件库</li><li><a href="https://github.com/iview/iview" target="_blank" rel="noopener">iview</a> ★6634 - 基于 Vuejs 的开源 UI 组件库</li><li><a href="https://github.com/ElemeFE/mint-ui" target="_blank" rel="noopener">mint-ui</a> ★6253 - Vue 2的移动UI元素</li><li><a href="https://github.com/museui/muse-ui" target="_blank" rel="noopener">muse-ui</a> ★3705 - 三端样式一致的响应式 UI 库</li><li><a href="https://github.com/marcosmoura/vue-material" target="_blank" rel="noopener">vue-material</a> ★3328 - 通过Vue Material和Vue 2建立精美的app应用</li><li><a href="https://github.com/vuetifyjs/vuetify" target="_blank" rel="noopener">vuetify</a> ★2925 - 为移动而生的Vue JS 2组件框架</li><li><a href="https://github.com/JosephusPaye/Keen-UI" target="_blank" rel="noopener">Keen-UI</a> ★2749 - 轻量级的基本UI组件合集</li><li><a href="https://github.com/wangdahoo/vonic" target="_blank" rel="noopener">vonic</a> ★1913 - 快速构建移动端单页应用</li><li><a href="https://github.com/monterail/vue-multiselect" target="_blank" rel="noopener">vue-multiselect</a> ★1539 - Vue.js选择框解决方案</li><li><a href="https://github.com/egoist/eme" target="_blank" rel="noopener">eme</a> ★1529 - 优雅的Markdown编辑器</li><li><a href="https://github.com/taylorchen709/vueAdmin" target="_blank" rel="noopener">vueAdmin</a> ★1455 - 基于vuejs2和element的简单的管理员模板</li><li><a href="https://github.com/pi0/bootstrap-vue" target="_blank" rel="noopener">bootstrap-vue</a> ★1267 - 应用于Vuejs2的Twitter的Bootstrap 4组件</li><li><a href="https://github.com/David-Desmaisons/Vue.Draggable" target="_blank" rel="noopener">Vue.Draggable</a> ★1191 - 实现拖放和视图模型数组同步</li></ul><p>[详情地址][<a href="https://blog.csdn.net/osdfhv/article/details/78892477" target="_blank" rel="noopener">https://blog.csdn.net/osdfhv/article/details/78892477</a>]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ElemeFE/element&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;element&lt;/a&gt; ★13489 - 饿了么出品的Vue2的web UI工具套件&lt;/li&gt;
&lt;li&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="-插件" scheme="https://tianjiec.top/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>react常用插件</title>
    <link href="https://tianjiec.top/2019/02/06/react%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://tianjiec.top/2019/02/06/react常用插件/</id>
    <published>2019-02-06T12:43:32.000Z</published>
    <updated>2019-02-06T12:44:32.466Z</updated>
    
    <content type="html"><![CDATA[<p>axios(http请求模块，可用于前端任何场景，很强大)<br>echarts-for-react(可视化图表，别人基于react对echarts的封装，足够用了)<br>recharts(另一个基于react封装的图表，个人觉得是没有echarts好用)<br>nprogress(顶部加载条，蛮好用)<br>react-draft-wysiwyg(别人基于react的富文本封装，如果找到其他更好的可以替换)<br>react-draggable(拖拽模块，找了个简单版的)<br>screenfull(全屏插件)<br>photoswipe(图片弹层查看插件，不依赖jQuery，还是蛮好用)<br>animate.css(css动画库)<br>redux Web 应用是一个状态机，视图与状态是一一对应的.所有的状态，保存在一个对象里面<br>redux-logger 日志<br>Reselect 记忆组件<br>redux-thunk 为了解决异步action的问题<br>redux-saga 为了解决异步action的问题<br>react-router-redux 保持路由与应用状态(state)同步</p><p>react-router-dom</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;axios(http请求模块，可用于前端任何场景，很强大)&lt;br&gt;echarts-for-react(可视化图表，别人基于react对echarts的封装，足够用了)&lt;br&gt;recharts(另一个基于react封装的图表，个人觉得是没有echarts好用)&lt;br&gt;npro
      
    
    </summary>
    
    
      <category term="-插件" scheme="https://tianjiec.top/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>React项目</title>
    <link href="https://tianjiec.top/2019/01/16/React%E9%A1%B9%E7%9B%AE/"/>
    <id>https://tianjiec.top/2019/01/16/React项目/</id>
    <published>2019-01-16T12:19:48.000Z</published>
    <updated>2019-01-16T13:11:03.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、初始化项目"><a href="#一、初始化项目" class="headerlink" title="一、初始化项目"></a>一、初始化项目</h2><p>初始化            create-react-app react-pro</p><p>抽离配置文件        yarn eject</p><p>安装相关依赖        cnpm install node-sass -D     、    cnpm i redux redux-thunk react-redux axios -S</p><h2 id="二、搭建项目结构-创建-Store"><a href="#二、搭建项目结构-创建-Store" class="headerlink" title="二、搭建项目结构 创建 Store"></a>二、搭建项目结构 创建 Store</h2><p>删除无用文件</p><h3 id="搭建项目结构："><a href="#搭建项目结构：" class="headerlink" title="搭建项目结构："></a>搭建项目结构：</h3><p>src        /assert</p><p>​        /components    /commons</p><p>​                        /pages</p><p>​                        /template-css</p><p>​                            index.js</p><p>​                            index.scss</p><p>​        /modules</p><p>​                        rem.js : 用来定义html字体，实现rem布局</p><p>​                        /axios-util</p><p>​                            get.js、post.js、index.js：提供请求数据方法</p><p>​                        /groups</p><p>​                            actionCreators.js：把所有actionCreators 这回合到这里 </p><p>​                            index.js：把react-redux的connect要处理的代码封装到这里，</p><p>​                            调用的时候 通过传参数决定 容器props的数据 和方法</p><p>​        /store（redux仓库配置）</p><p>​                        /commons(state.js, actionCreator.js, reducer.js, const.js)</p><p>​                        /index.js : 借助reducer创建 store</p><p>​                        /reducer.js :总reducer，聚合模块的reducer(conbineReducer({commons}))</p><p>​        App.js</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、初始化项目&quot;&gt;&lt;a href=&quot;#一、初始化项目&quot; class=&quot;headerlink&quot; title=&quot;一、初始化项目&quot;&gt;&lt;/a&gt;一、初始化项目&lt;/h2&gt;&lt;p&gt;初始化            create-react-app react-pro&lt;/p&gt;
&lt;p&gt;抽
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react-router</title>
    <link href="https://tianjiec.top/2019/01/14/react-router/"/>
    <id>https://tianjiec.top/2019/01/14/react-router/</id>
    <published>2019-01-14T12:46:05.000Z</published>
    <updated>2019-01-14T12:46:25.211Z</updated>
    
    <content type="html"><![CDATA[<h4 id="React-router-4"><a href="#React-router-4" class="headerlink" title="React-router 4+"></a>React-router 4+</h4><p>在这里，我们学react-router 4.0版本，需要注意的是，在4.0中，路由的搭建更灵活，我们不会基于全局的对于路由进行管理，而是在使用的时候进行路由的配置</p><p>我们需要下载的也不是react-router了，而是 react-router-dom</p><p><a href="https://www.cnblogs.com/zhanghuiming/p/7592132.html" target="_blank" rel="noopener">文档</a></p><ol><li><p>首先现在最外层包裹上Router，Router分为两种：BrowserRouter/HashRouter</p><p>BrowserRouter监听的是地址栏path的变化，HashRouter监听的是hash值的变化，注意HashRouter在某些时候会报一个警告，不允许重复跳转</p><p>  使用BrowserRouter需要后端去进行一个配置</p></li><li><p>在需要切换路由的时候，引入Route，path指定路径，component指定要渲染的组件，render可以传入一个函数，在这里逻辑判断之后再去返回一个组件，exact属性设置之后，只有完全匹配之后才能使用</p></li><li><p>switch 里面只运行渲染一个路由，可以有效的防止同级路由多次渲染</p></li></ol><switch><br>       <route exact="" path="/" component="{Home}"><br><br>       <route path="/render" render="{()" ==""> {<br>           //做出一些逻辑操作之后，返回一个组件<br>           return <div classname="content">render</div><br>       }} /&gt;<br><br>       <route path="/a/b" render="{()" ==""> {<br>           //做出一些逻辑操作之后，返回一个组件<br>           return <div classname="content">ab</div><br>       }} /&gt;<br><br>       <route path="/a" render="{()" ==""> {<br>           //做出一些逻辑操作之后，返回一个组件<br>           return <div classname="content">a</div><br>       }} /&gt;<br></route></route></route></route></switch><ol><li><p>重定向，可以使用Redirect组件，添加from、to属性进行重定向跳转</p></li><li><p>react-router中提供了Link和NavLink，都可以使用to属性进行跳转，NavLink可以对现在路由做出判断后给a标签加上样式或者类名，exact完全匹配</p></li><li><p>路由传参数,react-router4里只有一种参数就是路由参数，需要配置 /detail/:id,而query参数能传，但是传的时候，和取的 时候都没有对应的api来使用</p><p>它们都可以在this.props中的match、location里得到</p></li><li><p>withRouter高阶组件.高阶组件：就是一个函数，任务是为其他的组件添加一些属性和方法api，例如connect，可以将store中的一些东西安装到新生成的容器组件上   withRuter(App)    </p><p>withRouter可以根据传入的组件生成一个新的组件，并且为新组件添加上router相关的api</p></li><li><p>编程式导航： 在组件中获取到history的api进行跳转，如果是路由组件，直接从this.props中取出，如果不是的话，可以让外面的路由组件传入，或者可以使用withRouter高阶组件处理之后使用</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;React-router-4&quot;&gt;&lt;a href=&quot;#React-router-4&quot; class=&quot;headerlink&quot; title=&quot;React-router 4+&quot;&gt;&lt;/a&gt;React-router 4+&lt;/h4&gt;&lt;p&gt;在这里，我们学react-router 
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react-pro</title>
    <link href="https://tianjiec.top/2019/01/14/react-pro/"/>
    <id>https://tianjiec.top/2019/01/14/react-pro/</id>
    <published>2019-01-14T12:45:27.000Z</published>
    <updated>2019-01-14T12:45:42.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react项目搭建流程"><a href="#react项目搭建流程" class="headerlink" title="react项目搭建流程"></a>react项目搭建流程</h2><p>1.初始化项目  create-react-app react-pro<br>  抽离配置文件  yarn eject<br>  安装相关依赖<br>  yarn add node-sass -D<br>  yarn add redux redux-thunk react-redux axios -S</p><ol><li><p>搭建项目结构  并且  创建Store<br>src/assets<br>   /stylesheets/main.scss(_base.scss,_common.scss,_mixin.scss,_reset.scss)<br>   /components/commons<br>​              /pages<br>​              /template<br>​              /template-css<br>​               index.js<br>​               index.scss<br>   /store/commons(state.js,actionCreators.js,reducer.js,const.js)<br>​         /index.js (createStore(reducer,applyMiddlermare(thunk)))<br>​         /reducer.js (combineReducers({commons}))</p><p>   /modules/rem.js<br>​           /axios-util/</p></li><li><p>rem设置</p></li></ol><ol><li><p>配置axios<br><a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">https://www.kancloud.cn/yunye/axios/234845</a></p><p>src/modules/axios-util<br>​          (get.js/post.js/index.js)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//index.js文件</span><br><span class="line">import Post from &quot;./post&quot;</span><br><span class="line">import Get from &quot;./get&quot;</span><br><span class="line">import &#123;Component&#125; from &quot;react&quot;</span><br><span class="line">//方便在react组件中直接通过this.$post/this.$get直接请求数据</span><br><span class="line">Component.prototype.$post = Post;</span><br><span class="line">Component.prototype.$get = Get;</span><br><span class="line">//为了方便其他地方去使用请求，例如非组件的模块  actionCreators?可以发送异步请求</span><br><span class="line">export &#123;</span><br><span class="line">      Post,</span><br><span class="line">      Get</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一级路由的配置<br>cnpm install react-router-dom -S<br>  1)首先现在最外层包裹上Router，Router分为两种：BrowserRouter/HashRouter<br>  2)在需要切换路由的时候，引入Route，path指定路径，component指定要渲染的组件<br> exact属性设置之后，只有完全匹配之后才能使用<br>  3)switch 里面只运行渲染一个路由，可以有效的防止同级路由多次渲染</p>   <switch><br>​         <route path="/" component="{Home}" exact=""><br>​         <route path="/list" component="{List}"><br>​         <route path="/buycar" component="{BuyCar}"><br>​         <route path="/mine" component="{Mine}"><br>   </route></route></route></route></switch><p>   renderRoutes(){<br>   let {routes} = this.props;<br>   return (<br>​         <switch><br>​         {<br>​         routes.map(item=&gt;(<route key="{item.id}" path="{item.path}" component="{item.component}" exact="{item.exact}">))<br>​         }<br>​         </route></switch><br>   )<br>   }</p></li><li><p>AppFooter的设置<br>将通用的AppFooter放入在commons文件夹里面<br>用到AppFooter了，将他放入哪里呢？<br>1）第一种放入App.js文件里面 我们需要对于不需要底部的例如mine不需要，单独处理<br>2）第二种哪里需要直接扔哪里</p></li></ol><p>思考？<br>​      把AppFooter放入App.js文件里面，那么所有的页面都会有footer了,如果mine组件不希望有footer，怎么处理？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">让App组件监听路由的变化，然后做出判断，选择性的去渲染AppFooter</span><br><span class="line"></span><br><span class="line">*Mine组件是路由组件，app组件不是路由组件</span><br><span class="line">*Mine组件的属性上后history/location/match,app组件上没有</span><br><span class="line">-&gt;路由自身的属性上有history/location/match这些属性！</span><br><span class="line"></span><br><span class="line">*当路由切换的时候，App组件render函数会重新执行</span><br><span class="line">*只有属性或者状态改变的时候，render函数才会重新执行</span><br><span class="line">*发现app组件没有状态，属性也没用发生改变（componentWillReceiveProps不会执行），那为什么它的render函数会重新执行呢？</span><br><span class="line">*原因就是父组件Router的属性或者状态发生变化了，render了，导致子组件APP也进行了渲染，所以App的render函数会重新执行！可不可以在shouldComponentUpdate钩子函数里面进行状态的更改呢？不可以的，因为在这里设置状态，会导致死循环！</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*当hash值变化的时候，Mine组件的render函数会重新执行</span><br><span class="line">*只有属性或者状态更改的时候render函数才会重新执行</span><br><span class="line">*Mine组件没有状态，但是发现componentWillReceiveProps钩子函数每当路由变化的时候会重新执行</span><br><span class="line">-&gt;路由变化的时候，Mine组件的属性就会发生变化</span><br><span class="line">-&gt;路由变化的时候路由组件的属性会发生变化，如果我们想在路由组件中监听路由的变化，只需要在componentWillReceiveProps里面写代码即可</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*问题是： 路由组件可以监听路由的变化，但是app组件不是路由组件，如何也能让他监听路由的变化呢？</span><br><span class="line">*只要App组件外面也套一个Route路由组件，就可以监听到路由的变化了！</span><br><span class="line">*解决办法  需要引入withRouter,作用就是将不是路由组件的普通组件变成伪路由组件，不会跳转，但是呢，可以监听到路由的变化！     </span><br><span class="line">-&gt;只要引入withRouter,就可以变成伪路由组件，不是真正的路由组件，但是Route相关的属性或者方法。</span><br></pre></td></tr></table></figure><p>​<br>​       </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;react项目搭建流程&quot;&gt;&lt;a href=&quot;#react项目搭建流程&quot; class=&quot;headerlink&quot; title=&quot;react项目搭建流程&quot;&gt;&lt;/a&gt;react项目搭建流程&lt;/h2&gt;&lt;p&gt;1.初始化项目  create-react-app react-pr
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react相关知识点</title>
    <link href="https://tianjiec.top/2019/01/14/react%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://tianjiec.top/2019/01/14/react相关知识点/</id>
    <published>2019-01-14T12:42:35.000Z</published>
    <updated>2019-01-14T12:43:23.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React相关知识点"><a href="#React相关知识点" class="headerlink" title="React相关知识点"></a>React相关知识点</h2><p>React核心是组件！<br>React精髓是函数式编程！</p><p>1.react和vue对比：<br>   vue状态改变，只改变自己的视图<br>   vue很多的思想都是借鉴的react组件，并且又做了一些优化<br>   核心库都关注与视图层</p><p>2.React项目开源时间是：41395</p><p>3.React 16 将提供一个内置函数 componentDidCatch，如果 render() 函数抛出错误，则会触发该函数<br>componentDidCatch钩子函数是当项目发生错误的时候触发的</p><p>4.Redux中哪个方法收到action？<br>  dispatch方法负责收到、派发action (dispatch(action))<br>  actionCreator负责创建action<br>  reducer负责接收store传递过来的action</p><p>5.react－router4.0 核心对象包含Router/BrowserRouter/hashRouter/Route/Switch/withRouter等</p><p>6.react-router2.0中路由容器是｛this.props.children｝</p><ol><li>react中key值作用：<br>keys是什么帮助 React 跟踪哪些项目已更改、添加或从列表中删除。<br>每个 keys 在兄弟元素之间是独一无二的。<br>keys 使处理列表时更加高效，因为 React 可以使用子元素上的 keys 快速知道元素是新的还是在比较树时才被移动。<br>keys 不仅使这个过程更有效率，而且没有 keys ，React 不知道哪个本地状态对应于移动中的哪个项目。</li></ol><p>8.无状态组件与有状态的组件的区别是什么？<br>  没有状态，没有生命周期，只是简单的接受 props 渲染生成 DOM 结构。<br>  无状态组件非常简单，开销很低，如果可能的话尽量使用无状态组件。<br>  无状态的函数创建的组件是无状态组件，它是一种只负责展示的纯组件，<br>  无状态组件可以使用纯函数来实现。</p><p>  无状态组件定义函数方式如：（就是一个函数，根据接受到的属性来做不同的操作渲染）<br>​    const app = (props)=&gt;{return (<div>aaa</div>)}</p><p>9.在自定义的React组件当中，哪个生命周期函数必写？render函数</p><h2 id="flux知识点汇总：-https-www-cnblogs-com-fliu-articles-5245923-html"><a href="#flux知识点汇总：-https-www-cnblogs-com-fliu-articles-5245923-html" class="headerlink" title="flux知识点汇总：[https://www.cnblogs.com/fliu/articles/5245923.html]"></a>flux知识点汇总：[<a href="https://www.cnblogs.com/fliu/articles/5245923.html" target="_blank" rel="noopener">https://www.cnblogs.com/fliu/articles/5245923.html</a>]</h2><p>1.flux中能够调用setState方法的对象是(顶层容器)<br>2.Flux架构包含哪些部分?<br>​    View： 视图层<br>​    Action（动作）：视图层发出的消息（比如mouseClick）<br>​    Dispatcher（派发器）：用来接收Actions、执行回调函数、是中心枢纽<br>​    Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面</p><ol><li>Flux 的最大特点，就是数据的”单向流动”。<br>用户访问 View<br>View 发出用户的 Action<br>Dispatcher 收到 Action，要求 Store 进行相应的更新<br>Store 更新后，发出一个”change”事件<br>View 收到”change”事件后，更新页面</li></ol><p>可以通过redux与flux架构进行react的状态管理</p><h2 id="虚拟dom理解？-https-www-jianshu-com-p-616999666920"><a href="#虚拟dom理解？-https-www-jianshu-com-p-616999666920" class="headerlink" title="虚拟dom理解？[https://www.jianshu.com/p/616999666920]"></a>虚拟dom理解？[<a href="https://www.jianshu.com/p/616999666920" target="_blank" rel="noopener">https://www.jianshu.com/p/616999666920</a>]</h2><p>所谓virtual，指的是对真实DOM的一种模拟。相对于直接操作真实的DOM结构，我们构建一棵虚拟的树，将各种数据和操作直接应用在这棵虚拟的树上，然后再将对虚拟的树的修改应用到真实的DOM结构上。<br>通过虚拟dom可能会减少真实DOM操作次数，带来性能上的提升，即使我们频繁操作虚拟DOM，我们只需要一定时刻一次性同步修改到真实DOM上即可.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React相关知识点&quot;&gt;&lt;a href=&quot;#React相关知识点&quot; class=&quot;headerlink&quot; title=&quot;React相关知识点&quot;&gt;&lt;/a&gt;React相关知识点&lt;/h2&gt;&lt;p&gt;React核心是组件！&lt;br&gt;React精髓是函数式编程！&lt;/p&gt;
&lt;p&gt;1
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react学习2</title>
    <link href="https://tianjiec.top/2019/01/12/react%E5%AD%A6%E4%B9%A02/"/>
    <id>https://tianjiec.top/2019/01/12/react学习2/</id>
    <published>2019-01-12T09:37:50.000Z</published>
    <updated>2019-01-12T09:38:55.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React框架学习"><a href="#React框架学习" class="headerlink" title="React框架学习"></a>React框架学习</h1><h5 id="React中的事件对象"><a href="#React中的事件对象" class="headerlink" title="React中的事件对象"></a>React中的事件对象</h5><p>react中对于事件进行了处理，解决了一些兼容性问题，react事件对象上面挂载着nativeEvent，这个就是原生的事件对象</p><p>react对事件对象做了优化，如果不取值的话，值都是null</p><h5 id="React中组件通信方式"><a href="#React中组件通信方式" class="headerlink" title="React中组件通信方式"></a>React中组件通信方式</h5><p>父组件与子组件通信</p><ol><li>父组件将自己的状态传递给子组件，子组件当做属性来接收，当父组件更改自己状态的时候，子组件接收到的属性就会发生改变</li><li>父组件利用ref对子组件做标记，通过调用子组件的方法以更改子组件的状态..</li></ol><p>子组件与父组件通信</p><p>父组件将自己的某个方法传递给子组件，在方法里可以做任意操作，比如可以更改状态，子组件通过this.props接收到父组件的方法后调用。</p><p>兄弟组件通信</p><p>在react没有类似vue中的事件总线来解决这个问题，我们只能借助它们共同的父级组件来实现，将非父子关系装换成多维度的父子关系</p><p>复杂的非父子组件通信在react中很难处理，多组件间的数据共享也不好处理，所以我们会使用flux、redux来实现这样的功能，解决这个问题</p><h5 id="React中表单元素默认值"><a href="#React中表单元素默认值" class="headerlink" title="React中表单元素默认值"></a>React中表单元素默认值</h5><p>在react中，如果需要 给表单元素设置默认value或者checked，需要设置成defaultValue/defaultChecked，否则设置默认值以后，用户无法更改</p><h5 id="React-keys"><a href="#React-keys" class="headerlink" title="React-keys"></a>React-keys</h5><p>我们在react中循环列表数据的时候，需要对循环出来的虚拟jsx节点传入上key这个数据，</p><p>Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。</p><h5 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h5><p>就是如果有多个组件共享一个数据，把这个数据放到共同的父级组件中来管理</p><h5 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h5><p>在vue中有一个内容分发叫slot，在react中也有实现，就是可以在使用组件的时候，在组件标签内部放入一些不固定的内容，在该组件的模板中，只有{this.props.children}来表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//App</span><br><span class="line">&lt;Dialog</span><br><span class="line">close=&#123;this.ToggleDialogShow&#125; isShow=&#123;isDialogShow&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;ContentA/&gt;</span><br><span class="line">    &lt;ContentA/&gt;</span><br><span class="line">    &lt;ContentB/&gt;</span><br><span class="line">&lt;/Dialog&gt;</span><br><span class="line"></span><br><span class="line">//dialog</span><br><span class="line">&lt;div style=&#123;&#123;display:isShow?&apos;block&apos;:&apos;none&apos;&#125;&#125; className=&quot;dialog&quot;&gt;</span><br><span class="line">    &lt;Button handler=&#123;this.props.close&#125; text=&quot;关闭&quot;/&gt;   </span><br><span class="line">    &#123;this.props.children&#125;//这里就是slot</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React框架学习&quot;&gt;&lt;a href=&quot;#React框架学习&quot; class=&quot;headerlink&quot; title=&quot;React框架学习&quot;&gt;&lt;/a&gt;React框架学习&lt;/h1&gt;&lt;h5 id=&quot;React中的事件对象&quot;&gt;&lt;a href=&quot;#React中的事件对象&quot; c
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react学习1</title>
    <link href="https://tianjiec.top/2019/01/12/react%E5%AD%A6%E4%B9%A01/"/>
    <id>https://tianjiec.top/2019/01/12/react学习1/</id>
    <published>2019-01-12T09:37:43.000Z</published>
    <updated>2019-01-12T09:38:19.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React框架学习"><a href="#React框架学习" class="headerlink" title="React框架学习"></a>React框架学习</h1><h3 id="React的起源和发展"><a href="#React的起源和发展" class="headerlink" title="React的起源和发展"></a>React的起源和发展</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">起初facebook在建设instagram（图片分享）的时候嘞，因为牵扯到一个东西叫数据流，那为了处理数据流并且还要考虑好性能方面的问题嘞，Facebook开始对市场上的各种前端MVC框架去进行一个研究，然而并没有看上眼的，于是Facebook觉得，还是自己开发一个才是最棒的，那么他们决定抛开很多所谓的“最佳实践”，重新思考前端界面的构建方式，他们就自己开发了一套，果然大牛创造力还是很强大的。</span><br></pre></td></tr></table></figure><h3 id="React的出发点"><a href="#React的出发点" class="headerlink" title="React的出发点"></a>React的出发点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基于HTML的前端界面开发正变得越来越复杂，其本质问题基本都可以归结于如何将来自于服务器端或者用户输入的动态数据高效的反映到复杂的用户界面上。而来自Facebook的React框架正是完全面向此问题的一个解决方案，按官网描述，其出发点为：用于开发数据不断变化的大型应用程序（Building large applications with data that changes over time）。相比传统型的前端开发，React开辟了一个相当另类的途径，实现了前端界面的高性能高效率开发。</span><br></pre></td></tr></table></figure><h3 id="React与传统MVC的关系"><a href="#React与传统MVC的关系" class="headerlink" title="React与传统MVC的关系"></a>React与传统MVC的关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">轻量级的视图层框架！</span><br><span class="line"></span><br><span class="line">React不是一个完整的MVC框架，最多可以认为是MVC中的V（View），甚至React并不非常认可MVC开发模式；</span><br></pre></td></tr></table></figure><h3 id="React高性能的体现：虚拟DOM"><a href="#React高性能的体现：虚拟DOM" class="headerlink" title="React高性能的体现：虚拟DOM"></a>React高性能的体现：虚拟DOM</h3><p>React高性能的原理：</p><p>在Web开发中我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而复杂或频繁的DOM操作通常是性能瓶颈产生的原因（如何进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标）。</p><p>React为此引入了虚拟DOM（Virtual DOM）的机制：在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。而且React能够批处理虚拟DOM的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从A-B,B-A，React会认为A变成B，然后又从B变成A  UI不发生任何变化，而如果通过手动控制，这种逻辑通常是极其复杂的。</p><p>尽管每一次都需要构造完整的虚拟DOM树，但是因为虚拟DOM是内存数据，性能是极高的，部而对实际DOM进行操作的仅仅是Diff分，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体的DOM元素，而只需要关心在任意一个数据状态下，整个界面是如何Render的。数据驱动，声明式</p><h3 id="React的特点和优势"><a href="#React的特点和优势" class="headerlink" title="React的特点和优势"></a>React的特点和优势</h3><ol><li>虚拟DOM</li></ol><p>我们以前操作dom的方式是通过document.getElementById()的方式，这样的过程实际上是先去读取html的dom结构，将结构转换成变量，再进行操作</p><p>而reactjs定义了一套变量形式的dom模型，一切操作和换算直接在变量中，这样减少了操作真实dom，性能真实相当的高，和主流MVC框架有本质的区别，并不和dom打交道</p><ol><li>组件系统</li></ol><p>react最核心的思想是将页面中任何一个区域或者元素都可以看做一个组件 component</p><p>那么什么是组件呢？  .vue  template script style lang=”scss” node-sass sass-loader</p><p>组件指的就是同时包含了html、css、js、image元素的聚合体</p><p>使用react开发的核心就是将页面拆分成若干个组件，并且react一个组件中同时耦合了css、js、image，这种模式整个颠覆了过去的传统的方式</p><ol><li>单向数据流  <father><son name=""></son></father>父子通信  vuex state—&gt;component(this.$store.state) —-&gt; actions（{commit}）(this.$store.dispatch()) —-&gt; mutations(this.$store.commit()) —–&gt; state</li></ol><p>其实reactjs的核心内容就是数据绑定，所谓数据绑定指的是只要将一些服务端的数据和前端页面绑定好，开发者只关注实现业务就行了  </p><ol><li>JSX  语法  </li></ol><p>在vue中，我们使用render函数来构建组件的dom结构性能较高，因为省去了查找和编译模板的过程，但是在render中利用createElement创建结构的时候代码可读性较低，较为复杂，此时可以利用jsx语法来在render中创建dom，解决这个问题，但是前提是需要使用工具来编译jsx</p><h3 id="创建第一个组件-15-16"><a href="#创建第一个组件-15-16" class="headerlink" title="创建第一个组件  15.  16"></a>创建第一个组件  15.  16</h3><p>react开发需要引入多个依赖文件：react.js、react-dom.js，分别又有开发版本和生成版本</p><p>在这里一开始，我们先学习es5的组件写法，React.createClass，需要引入的是15+</p><p>react.js中有React对象，帮助我们创建组件等功能</p><p>react-dom.js中有ReactDOM对象，渲染组件的虚拟dom为真实dom的爆发功能<br>​<br>在编写react代码的时候会大量的使用到jsx代码，但是需要编译：</p><ol><li>浏览器端编译，通过引入browser、babel等对引入的script内的代码做编译</li><li>利用webpack等开发环境进行编译，将编译好的文件引入到应用中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//创建组件</span><br><span class="line">var Hello = React.createClass(&#123;</span><br><span class="line">    render:function () &#123;</span><br><span class="line">        //render函数和Vue组件里的render完全一样，在vue组件中可以不用编写render函数，这个时候可以使用template模板来编写组件的虚拟dom结构，然后vue组件会自动讲模板compile成虚拟dom结构放入到render中执行，但是react需要编写render函数</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            //jsx语法</span><br><span class="line">            &lt;div&gt;asdasd&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//利用ReactDOM对象的render方法将组件渲染到某个节点里</span><br><span class="line">ReactDOM.render(&lt;Hello/&gt;,document.getElementById(&quot;app&quot;))</span><br></pre></td></tr></table></figure><p>组件是通过React.createClass创建的（ES5），在es6中直接通过class关键字来创建</p><p>组件其实就是一个构造器,每次使用组件都相当于在实例化组件</p><p>react的组件必须使用render函数来创建组件的虚拟dom结构</p><p>组件需要使用ReactDOM.render方法将其挂载在某一个节点上</p><p>组件的首字母必须大写</p><h3 id="JSX语法糖"><a href="#JSX语法糖" class="headerlink" title="JSX语法糖"></a>JSX语法糖</h3><p>JSX是一种语法，全称：javascript xml</p><p>JSX语法不是必须使用的，但是因为使用了JSX语法之后会降低我们的开发难度，故而这样的语法又被成为语法糖</p><p>在不使用JSX的时候，需要使用React.createElement来创建组件的dom结构，但是这样的写法虽然不需要编译，但是维护和开发的难度很高，且可读性很差</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var world = React.createElement(&apos;h1&apos;,&#123;className:&apos;abc&apos;,id:&apos;haha&apos;&#125;,[</span><br><span class="line">    React.createElement(&apos;span&apos;,null,&apos;Hello&apos;),</span><br><span class="line">    React.createElement(&apos;mark&apos;,null,&apos;React&apos;)</span><br><span class="line">])</span><br><span class="line">            </span><br><span class="line">//利用ReactDOM对象的render方法将组件渲染到某个节点里</span><br><span class="line">ReactDOM.render(world,document.getElementById(&quot;app1&quot;))</span><br></pre></td></tr></table></figure><p>及时使用了JSX语法了之后，也是需要将其编译成原生的createElement的</p><p>JSX就是在js中使用的xml，但是，这里的xml不是真正的xml，只能借鉴了一些xml的语法，例如：</p><p>最外层必须有根节点、标签必须闭合</p><p>jsx借鉴xml的语法而不是html的语法原因：xml要比html严谨，编译更方便</p><h3 id="组件dom添加样式"><a href="#组件dom添加样式" class="headerlink" title="组件dom添加样式"></a>组件dom添加样式</h3><p>在react里表达式的符号是 “{  }”,作用和vue的表达式作用是一样的</p><p>想给虚拟dom添加行内样式，需要使用表达式传入样式对象的方式来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style = &#123; &#123;color:&apos;red&apos;,fontSize:2+&apos;em&apos;&#125; &#125;&gt;Hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>行内样式需要写入一个样式对象，而这个样式对象的位置可以放在很多地方，例如React.createClass的配置项中、render函数里、组件原型上、外链js文件中</p><p>React推荐我们使用行内样式，因为react觉得每一个组件都是一个独立的整体</p><p>其实我们大多数情况下还是大量的在为元素添加类名、id以使用某些样式，但是需要注意的是，class需要写成className（因为毕竟是在写类js代码，会收到js规则的现在，而class是关键字）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p className=&quot;bg-p&quot; id=&quot;myp&quot; style = &#123; this.style &#125;&gt;Hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="React-Event"><a href="#React-Event" class="headerlink" title="React Event"></a>React Event</h3><p>在react中，我们想要给组件的dom添加事件的话，也是 需要在行内添加的方式，事件名字需要写成小驼峰的方式，值利用表达式传入一个函数即可</p><p>注意，在没有渲染的时候，页面中没有真实dom，所以是获取不到dom的</p><p>给虚拟dom结构中的节点添加样式。在行内添加,写成驼峰形式，值是一个函数名，需要用{}包裹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">handleClick:function () &#123;</span><br><span class="line">    alert(1)</span><br><span class="line">&#125;,</span><br><span class="line">render:function () &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick = &#123;this.handleClick&#125; className=&quot;click-btn&quot;&gt;click&lt;/button&gt;</span><br><span class="line">            &lt;button onDoubleClick = &#123;this.handleClick&#125; className=&quot;click-btn&quot;&gt;click&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h3><p>将一个组件渲染到某一个节点里的时候，会将这个节点里原有内容覆盖</p><p>组件嵌套的方式就是将子组件写入到父组件的模板中去，且react没有Vue中的内容分发机制（slot），所以我们在一个组件的模板中只能看到父子关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var Hello = React.createClass(&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;h1&gt;</span><br><span class="line">                Hello </span><br><span class="line">                &lt;World&gt;&lt;/World&gt;</span><br><span class="line">            &lt;/h1&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">var World = React.createClass(&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;mark&gt;</span><br><span class="line">                World-&lt;Person/&gt; </span><br><span class="line">            &lt;/mark&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//无状态组件</span><br><span class="line">var Person =function()&#123;</span><br><span class="line">    return (&lt;mark&gt;lilei&lt;/mark&gt;)</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;Hello/&gt;,app)</span><br></pre></td></tr></table></figure><blockquote><p>注意，react中jsx里的注释要写成{/<em>  </em>/}的方式</p></blockquote><h3 id="React中的数据承载-Props-State"><a href="#React中的数据承载-Props-State" class="headerlink" title="React中的数据承载-Props/State"></a>React中的数据承载-Props/State</h3><p>数据驱动、声明式渲染：</p><p>任意的视图变化都应该由数据来控制</p><p>//$(“.a”).html(0)</p><p>var num = 0<br>function renderNum () { $(“.a”).html(num) }</p><p>React也是基于数据驱动(声明式)的框架，组件中必然需要承载一些数据，在react中起到这个作用的是属性和状态（props &amp; state）</p><ol><li>属性（props）  在组件外部传入，或者内部设置，组件内部通过this.props获得</li><li>状态（state）  在组件内部设置或者更改，组件内部通过this.state获得</li></ol><h5 id="属性-props"><a href="#属性-props" class="headerlink" title="属性(props)"></a>属性(props)</h5><p>属性一般是外部传入的，组件内部也可以通过一些方式来初始化的设置，属性不能被组件自己更改</p><p>属性是描述性质、特点的，组件自己不能随意更改</p><p>使组件拥有属性的方式：</p><ol><li>在装载（mount）组件的时候给组件传入</li></ol><p>传入数据的时候，除了字符串类型，其他的都应该包上表达式，但是为了规整，所有的数据传递，最好都包上{}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var Gouzi = React.createClass(&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;我的名字：&#123;this.props.name&#125;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;我的性别：&#123;this.props.sex&#125;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;我的年龄：&#123;this.props.age&#125;&lt;/p&gt;  </span><br><span class="line">                &lt;p&gt;我的父亲是：&#123;this.props.father&#125;&lt;/p&gt;                                              </span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let info = &#123;</span><br><span class="line">    sex:&apos;male&apos;,</span><br><span class="line">    father:&apos;狗爸&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Gouzi &#123;...info&#125; name=&#123;&quot;大狗子&quot;&#125; age=&#123;26&#125;/&gt;,app)</span><br></pre></td></tr></table></figure><ol><li>父组件给子组件传入</li></ol><p>父组件在嵌套子组件的时候为子组件传入，传入的方式和上面的方式一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//父组件的render函数</span><br><span class="line">render()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;父组件：&lt;/p&gt;</span><br><span class="line">            &lt;hr/&gt;</span><br><span class="line">            &lt;Son name=&#123;&apos;大狗子&apos;&#125;/&gt;</span><br><span class="line">            &lt;Son name=&#123;&apos;二狗子&apos;&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>子组件自己设置</li></ol><p>子组件可以通过getDefaultProps来设置默认的属性</p><p>getDefaultProps的值是函数，这个函数会返回一个对象，我们在这里对象里为组件设置默认属性</p><p>这种方式设置的属性优先级低，会被外部传入的属性值所覆盖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getDefaultProps:function () &#123;</span><br><span class="line">    console.log(&apos;getDefaultProps&apos;)</span><br><span class="line">    return &#123;</span><br><span class="line">        name:&apos;狗爸&apos;,</span><br><span class="line">        sonname:&apos;二狗子&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">//render</span><br><span class="line">&lt;p&gt;我是&#123;this.props.sonname&#125;的父亲-&#123;this.props.name&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>根据属性或状态，我们可以在render中的表达式里做一些逻辑判断，可以使用||、三元表达式、子执行函数等等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">getName()&#123;</span><br><span class="line">    return this.props.name || &apos;野狗子&apos;</span><br><span class="line">&#125;,</span><br><span class="line">render:function () &#123;</span><br><span class="line">    let &#123;name&#125; = this.props</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;我是子组件-&#123;this.props.name || &apos;野狗子&apos;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;我是子组件-&#123;this.props.name?this.props.name:&apos;野狗子&apos;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;我是子组件-&#123;this.getName()&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;我是子组件-&#123;(function (obj) &#123;</span><br><span class="line">            return obj.props.name || &apos;野狗子&apos;</span><br><span class="line">        &#125;)(this)&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="状态-state"><a href="#状态-state" class="headerlink" title="状态(state)"></a>状态(state)</h5><p>状态就是组件描述某种显示情况的数据，由组件自己设置和更改，也就是说由组件自己维护，使用状态的目的就是为了在不同的状态下使组件的显示不同(自己管理)</p><p>在组件中只能通过getInitialState的钩子函数来给组件挂载初始状态,在组件内部通过this.state获取</p><p>this.props和this.state是纯js对象,在vue中，$data属性是利用Object.defineProperty处理过的，更改$data的数据的时候会触发数据的getter和setter，但是react中没有做这样的处理，如果直接更改的话，react是无法得知的，所以，需要使用特殊的更改状态的方法：</p><p>setState(params)</p><p>在setState中传入一个对象，就会将组件的状态中键值对的部分更改，还可以传入一个函数，这个回调函数必须返回像上面方式一样的一个对象，函数可以接收prevState和props</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//1.</span><br><span class="line">let doing = this.state.doing==&apos;学习&apos;+props.knowledge?&apos;玩游戏&apos;:&apos;学习&apos;+props.knowledge</span><br><span class="line">this.setState(&#123;doing&#125;)</span><br><span class="line"></span><br><span class="line">//2.</span><br><span class="line">this.setState((prevState,props)=&gt;&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        doing:prevState.doing==&apos;学习&apos;+props.knowledge?&apos;玩游戏&apos;:&apos;学习&apos;+props.knowledge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="实现下拉菜单的方式"><a href="#实现下拉菜单的方式" class="headerlink" title="实现下拉菜单的方式"></a>实现下拉菜单的方式</h5><ol><li>通过数据来控制元素的行内样式中display的值，或者去控制类名</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul style=&#123;&#123;display:isMenuShow?&apos;block&apos;:&apos;none&apos;&#125;&#125;&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;</span><br><span class="line">...</span><br><span class="line">&lt;ul className=&#123;isMenuShow?&apos;show&apos;:&apos;hide&apos;&#125;&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;</span><br></pre></td></tr></table></figure><ol><li>根据数据控制是否渲染改节点、组件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    isMenuShow?&lt;ul&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;:&apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过ref对dom、组件进行标记，在组件内部通过this.refs获取到之后，进行操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul ref=&apos;content&apos;&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;</span><br><span class="line">...</span><br><span class="line">this.refs.content.style.display = this.state.isMenuShow?&apos;block&apos;:&apos;none&apos;</span><br></pre></td></tr></table></figure><h5 id="属性和状态的对比"><a href="#属性和状态的对比" class="headerlink" title="属性和状态的对比"></a>属性和状态的对比</h5><p>相似点：都是纯js对象，都会触发render更新，都具有确定性（状态/属性相同，结果相同）</p><p>不同点： </p><ol><li>属性能从父组件获取，状态不能</li><li>属性可以由父组件修改，状态不能</li><li>属性能在内部设置默认值 ，状态也可以</li><li>属性不在组件内部修改   ，状态要改</li></ol><p>状态只和自己相关，由自己维护</p><p>属性不要自己修改，可以从父组件获取，也可以给子组件设置</p><p>组件在运行时自己需要修改的数据其实就是状态而已</p><h4 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h4><p>react中组件也有生命周期，也就是说也有很多钩子函数供我们使用，下面是生命周期的图示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./life.jpg" alt="生命周期" title="">                </div>                <div class="image-caption">生命周期</div>            </figure><p>组件是一个构造器，每一次使用组件都相当于在实例化组件，在这个时候，组件就会经历一次生命周期，从实例化实例开始到这个实例销毁的时候，都是一次完整的生命周期</p><p>组件的生命周期，我们会分为三个阶段，初始化、运行中、销毁</p><h5 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h5><ol><li><p>实例化组件之后，组件的getDefaultProps钩子函数会执行</p><p>这个钩子函数的目的是为组件的实例挂载默认的属性</p><p>这个钩子函数只会执行一次，也就是说，只在第一次实例化的时候执行，创建出所有实例共享的默认属性，后面再实例化的时候，不会执行getDefaultProps，直接使用已有的共享的默认属性</p><p>理论上来说，写成函数返回对象的方式，是为了防止实例共享，但是react专门为了让实例共享，只能让这个函数只执行一次</p><p>组件间共享默认属性会减少内存空间的浪费，而且也不需要担心某一个实例更改属性后其他的实例也会更改的问题，因为组件不能自己更改属性，而且默认属性的优先级低。</p></li><li><p>执行getInitialState为实例挂载初始状态，且每次实例化都会执行，也就是说，每一个组件实例都拥有自己独立的状态呢</p></li><li><p>执行componentWillMount，相当于Vue里的created+beforeMount，这里是在渲染之前最后一次更改数据的机会，在这里更改的话是不会触发render的重新执行</p><p>多做一些初始数据的获取</p></li><li><p>执行render，渲染dom</p></li><li><p>执行componentDidMount ，相当于Vue里的mounted,多用于操作真实dom</p></li></ol><h5 id="运行中阶段"><a href="#运行中阶段" class="headerlink" title="运行中阶段"></a>运行中阶段</h5><p>当组件mount到页面中之后，就进入了运行中阶段，在这里有5个钩子函数，但是这5个函数只有在数据（属性、状态）发送改变的时候才会执行</p><ol><li>componentWillReceiveProps</li></ol><p>当父组件给子组件传入的属性改变的时候，子组件的这个函数才会执行</p><p>当执行的时候，函数接收的参数是子组件接收到的新参数，这个时候，新参数还没有同步到this.props上,多用于判断新属性和原有属性的变化后更改组件的状态</p><ol><li><p>接下来就会执行shouldComponentUpdate,这个函数的作用：</p><p>当属性或状态发生改变后控制组件是否要更新，提高性能,返回true就更新，否则不更新，默认返回true</p><p>接收nextProp、nextState，根据根据新属性状态和原属性状态作出对比、判断后控制是否更新</p></li><li><p>componentWillUpdate,在这里，组件马上就要重新render了，多做一些准备工作，千万千万，不要在这里修改状态，否则会死循环<br>相当于Vue中的beforeUpdate</p></li><li><p>render，重新渲染dom</p></li><li><p>componentDidUpdate，在这里，新的dom结构已经诞生了,相当于Vue里的updated</p></li></ol><h5 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h5><p>当组件被销毁之前的一刹那，会触发componentWillUnmount，临死前的挣扎</p><p>相当于Vue里的beforeDestroy，所以说一般会做一些擦屁股的事情</p><p>为什么Vue中有destroyed，而react却没有componentDidUnmount</p><p>Vue在调用$destroy方法的时候就会执行beforeDestroy，然后组件被销毁，这个时候组件的dom结构还存在于页面结构中，也就说如果想要对残留的dom结构进行处理必须在destroyed处理，但是react执行完componentWillUnmount之后把事件、数据、dom都全部处理掉了，所以根本不需要其他的钩子函数了</p><p>怎么样就算组件被销毁：</p><ol><li>当父组件从渲染这个子组件变成不渲染这个子组件的时候，子组件相当于被销毁</li><li>调用ReactDOM.unmountComponentAtNode(node) 方法来将某节点中的组件销毁</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React框架学习&quot;&gt;&lt;a href=&quot;#React框架学习&quot; class=&quot;headerlink&quot; title=&quot;React框架学习&quot;&gt;&lt;/a&gt;React框架学习&lt;/h1&gt;&lt;h3 id=&quot;React的起源和发展&quot;&gt;&lt;a href=&quot;#React的起源和发展&quot; c
      
    
    </summary>
    
    
      <category term="react" scheme="https://tianjiec.top/tags/react/"/>
    
  </entry>
  
</feed>
