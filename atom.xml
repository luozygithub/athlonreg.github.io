<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chentj&#39;s Blog</title>
  
  <subtitle>Inflexible thinking, bad humor</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tianjiec.top/"/>
  <updated>2018-12-26T12:11:47.062Z</updated>
  <id>https://tianjiec.top/</id>
  
  <author>
    <name>chentj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>xhr</title>
    <link href="https://tianjiec.top/2018/12/26/xhr/"/>
    <id>https://tianjiec.top/2018/12/26/xhr/</id>
    <published>2018-12-26T11:58:39.000Z</published>
    <updated>2018-12-26T12:11:47.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解ajax——XHR对象"><a href="#深入理解ajax——XHR对象" class="headerlink" title="深入理解ajax——XHR对象"></a>深入理解ajax——XHR对象</h1><h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>　　1999年，微软公司发布IE5，第一次引入新功能：允许javascript脚本向服务器发起HTTP请求。这个功能当时并没有引起注意，直到2004年Gmail发布和2005年Google Map发布，才引起广泛重视。2005年2月，ajax这个词第一次正式提出，指围绕这个功能进行开发的一整套做法。从此，ajax成为脚本发起HTTP通信的代名词，W3C也在2006年发布了它的国际标准。本文是ajax系列的第一篇——XHR对象</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>　　ajax是asynchronous javascript and XML的简写，中文翻译是异步的javascript和XML，这一技术能够向服务器请求额外的数据而无须卸载页面，会带来更好的用户体验。虽然名字中包含XML，但ajax通信与数据格式无关</p><p>　　ajax包括以下几步骤：<strong>1、创建AJAX对象；2、发出HTTP请求；3、接收服务器传回的数据；4、更新网页数据</strong></p><p>　　概括起来，就是一句话，<strong>ajax通过原生的<code>XMLHttpRequest</code>对象发出HTTP请求，得到服务器返回的数据后，再进行处理</strong></p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>　　ajax技术的核心是XMLHttpRequest对象(简称XHR)，这是由微软首先引入的一个特性，其他浏览器提供商后来都提供了相同的实现。XHR为向服务器发送请求和解析服务器响应提供了流畅的接口，能够以异步方式从服务器取得更多信息，意味着用户单击后，可以不必刷新页面也能取得新数据</p><p>　　IE5是第一款引入XHR对象的浏览器。在IE5中，XHR对象是通过MSXML库中的一个ActiveX对象实现的，而IE7+及其他标准浏览器都支持原生的XHR对象</p><p>　　创建一个XHR对象，也叫实例化一个XHR对象，因为XMLHTTPRequest()是一个构造函数。下面是创建XHR对象的兼容写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[注意]如果要建立N个不同的请求，就要使用N个不同的XHR对象。当然可以重用已存在的XHR对象，但这会终止之前通过该对象挂起的任何请求</p><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p><strong>open()</strong></p><p>　　在使用XHR对象时，要调用的第一个方法是open()，如下所示，该方法接受3个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"example.php"</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>1、open()方法的第<strong>一个参数用于指定发送请求的方式</strong>，这个字符串，不区分大小写，但通常使用大写字母。”GET”和”POST”是得到广泛支持的</p><p>　　“GET”用于常规请求，它适用于当URL完全指定请求资源，当请求对服务器没有任何副作用以及当服务器的响应是可缓存的情况下</p><p>　　“POST”方法常用于HTML表单。它在请求主体中包含额外数据且这些数据常存储到服务器上的数据库中。相同URL的重复POST请求从服务器得到的响应可能不同，同时不应该缓存使用这个方法的请求</p><p>　　除了”GET”和”POST”之外，参数还可以是”HEAD”、”OPTIONS”、”PUT”。而由于安全风险的原因，”CONNECT”、”TRACE”、”TRACK”被禁止使用</p><p>　　[注意]关于HTTP协议8种常用方法的详细介绍<a href="http://www.cnblogs.com/xiaohuochai/p/6156435.html#anchor3" target="_blank" rel="noopener">移步至此</a></p><p>　2、open()方法的第<strong>二个参数是URL</strong>，该URL相对于执行代码的当前页面，且只能向同一个域中使用相同端口和协议的URL发送请求。如果URL与启动请求的页面有任何差别，都会引发安全错误</p><p>　　3、open()方法的第<strong>三个参数是表示是否异步发送请求的布尔值</strong>，如果不填写，默认为true，表示异步发送</p><p>　　4、如果请求一个受密码保护的URL，把用于认证的用户名和密码作为第4和第5个参数传递给open()方法</p><p><strong>send()</strong></p><p>send()方法接收一个参数，即要作为请求主体发送的数据。调用send()方法后，请求被分派到服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;get&quot;,&quot;example.txt&quot;, true)</span><br><span class="line">xhr.send(null)</span><br></pre></td></tr></table></figure><h3 id="接收响应"><a href="#接收响应" class="headerlink" title="接收响应"></a>接收响应</h3><p>　　一个完整的HTTP响应由状态码、响应头集合和响应主体组成。在收到响应后，这些都可以通过XHR对象的属性和方法使用，主要有以下4个属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">responseText:作为响应主题被返回的文本（文本形式）</span><br><span class="line">responseXML：如果响应的内容是<span class="string">'text/xml'</span>或者是<span class="string">'application/xml'</span>,这个属性中将保存着相应数据的XML DOM文档（<span class="built_in">document</span>形式）</span><br><span class="line">status: HTTP状态码（数字形式）</span><br><span class="line">statusText：HTTP状态说明（文本形式）</span><br></pre></td></tr></table></figure><p>在接收到响应后，第一步是检查status属性，以确定响应已经成功返回。一般来说，可以将HTTP状态码为200作为成功的标志。此时，responseText属性的内容已经就绪，而且在内容类型正确的情况下，responseXML也可以访问了。此外，状态码为304表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本；当然，也意味着响应是有效的</p><p>　　无论内容类型是什么，响应主体的内容都会保存到responseText属性中，而对于非XML数据而言，responseXML属性的值将为null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((xhr.status &gt;=<span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">    alert(xhr.responseText);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    alert(<span class="string">'request was unsuccessful:'</span> + xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>　　如果接受的是同步响应，则需要将open()方法的第三个参数设置为false，那么send()方法将阻塞直到请求完成。一旦send()返回，仅需要检查XHR对象的status和responseText属性即可</p><p>　　同步请求是吸引人的，但应该避免使用它们。客户端javascript是单线程的，当send()方法阻塞时，它通常会导致整个浏览器UI冻结。如果连接的服务器响应慢，那么用户的浏览器将冻结</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">"btn"</span>&gt;获取信息&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;div id="result"&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//创建xhr对象</span></span><br><span class="line">    <span class="keyword">var</span> xhr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    xhr.open(<span class="string">'get'</span>,<span class="string">'/uploads/rs/26/ddzmgynp/message.xml'</span>,<span class="literal">false</span>);</span><br><span class="line">    xhr.send();</span><br><span class="line">    <span class="comment">//同步接受响应</span></span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">            <span class="comment">//实际操作</span></span><br><span class="line">            result.innerHTML += xhr.responseText;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="javascript:void(0);" alt="复制代码](http://common.cnblogs.com/images/copycode.gif)" title="">                </div>                <div class="image-caption">复制代码](http://common.cnblogs.com/images/copycode.gif)</div>            </figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//message.xml</span><br><span class="line">&lt;p&gt;hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure><h4 id="知识来源：http-www-cnblogs-com-xiaohuochai-p-6036475-html"><a href="#知识来源：http-www-cnblogs-com-xiaohuochai-p-6036475-html" class="headerlink" title="知识来源：http://www.cnblogs.com/xiaohuochai/p/6036475.html"></a>知识来源：<a href="http://www.cnblogs.com/xiaohuochai/p/6036475.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaohuochai/p/6036475.html</a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解ajax——XHR对象&quot;&gt;&lt;a href=&quot;#深入理解ajax——XHR对象&quot; class=&quot;headerlink&quot; title=&quot;深入理解ajax——XHR对象&quot;&gt;&lt;/a&gt;深入理解ajax——XHR对象&lt;/h1&gt;&lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="ajax" scheme="https://tianjiec.top/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>Vue.extend构造器</title>
    <link href="https://tianjiec.top/2018/12/26/Vue-extend%E6%9E%84%E9%80%A0%E5%99%A8/"/>
    <id>https://tianjiec.top/2018/12/26/Vue-extend构造器/</id>
    <published>2018-12-26T09:48:26.000Z</published>
    <updated>2018-12-26T11:51:08.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1.简单介绍"></a>1.简单介绍</h3><p>Vue.extend(options)</p><p>参数：对象</p><p>用法：使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中,data选项中必须是函数</p><blockquote><h5 id="描述：Vue-extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue-component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上"><a href="#描述：Vue-extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue-component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上" class="headerlink" title="描述：Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上"></a>描述：Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上</h5></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> author = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">"&lt;p&gt;&lt;a :href='url'&gt;&#123;&#123;author&#125;&#125;&lt;/a&gt;&lt;/p&gt;"</span>,</span><br><span class="line">  data : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      author : <span class="string">'vamous'</span>,</span><br><span class="line">      url : <span class="string">'http://blog.csdn.net/Dear_Mr/article/details/72614370'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Hello = Vue.extend(&#123;</span><br><span class="line">       template:<span class="string">"&lt;p&gt;header!!!&lt;/p&gt;"</span></span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简单介绍&quot;&gt;&lt;a href=&quot;#1-简单介绍&quot; class=&quot;headerlink&quot; title=&quot;1.简单介绍&quot;&gt;&lt;/a&gt;1.简单介绍&lt;/h3&gt;&lt;p&gt;Vue.extend(options)&lt;/p&gt;
&lt;p&gt;参数：对象&lt;/p&gt;
&lt;p&gt;用法：使用Vue构造器，创建
      
    
    </summary>
    
    
      <category term="vue" scheme="https://tianjiec.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>箭头函数</title>
    <link href="https://tianjiec.top/2018/12/26/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>https://tianjiec.top/2018/12/26/箭头函数/</id>
    <published>2018-12-26T03:27:09.000Z</published>
    <updated>2018-12-26T03:51:45.203Z</updated>
    
    <content type="html"><![CDATA[<p>##### </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个参数</span></span><br><span class="line"><span class="keyword">var</span>fn1 = <span class="function"><span class="params">a</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多个参数</span></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function">(<span class="params">a, b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a+b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有return语句 返回值</span></span><br><span class="line"><span class="keyword">var</span> fn3 = <span class="function">(<span class="params">a</span>)=&gt;</span>a</span><br><span class="line"><span class="keyword">var</span> fn4 = <span class="function">(<span class="params">a, b</span>)=&gt;</span>（a+b）</span><br></pre></td></tr></table></figure><h4 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h4><p>函数自执行（自己执行）</p><p>函数的this指向window</p><p><strong>箭头函数的this指向 其上一层（临近）的对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    username:<span class="string">"张三"</span>,</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    say2:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">json.say();<span class="comment">//&#123;username: "张三", say: ƒ, say2: ƒ&#125;</span></span><br><span class="line">json.say2();<span class="comment">//Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##### &lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/s
      
    
    </summary>
    
    
      <category term="es6 js" scheme="https://tianjiec.top/tags/es6-js/"/>
    
  </entry>
  
  <entry>
    <title>作用域、变量提升、this.js</title>
    <link href="https://tianjiec.top/2018/12/25/%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E3%80%81this-js/"/>
    <id>https://tianjiec.top/2018/12/25/作用域、变量提升、this-js/</id>
    <published>2018-12-25T11:53:29.000Z</published>
    <updated>2018-12-26T03:36:40.406Z</updated>
    
    <content type="html"><![CDATA[<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.log(a);</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">abc();</span><br></pre></td></tr></table></figure><p>function 执行过程是</p><p>查找var let 将声明提前</p><p>然后再在原有位置进行赋值</p><p>var 和 let变量提升区别：</p><p>let 局部 变量提升出现死区例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">"hey I am outside"</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//Uncaught ReferenceError: a is not defined</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">"hey I am inside"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>let变量提升 在死区部分无法访问 ，而我们不能够访问的原因事实上是因为let的死区（temporal dead zone）设计：当前作用域顶部到该变量声明位置中间的部分，都是该let变量的死区，在死区中，禁止访问该变量。由此，我们给出结论，let声明的变量存在变量提升， 但是由于死区我们无法在声明前访问这个变量。<br>原文：<a href="https://blog.csdn.net/triumphs/article/details/80142721" target="_blank" rel="noopener">https://blog.csdn.net/triumphs/article/details/80142721</a> </p><h4 id="函数变量的变量提升："><a href="#函数变量的变量提升：" class="headerlink" title="函数变量的变量提升："></a>函数变量的变量提升：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn();<span class="comment">//1</span></span><br><span class="line"><span class="comment">//声明式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn2();<span class="comment">//fn2 not is a function</span></span><br><span class="line"><span class="comment">//定义式</span></span><br><span class="line"><span class="keyword">var</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="this（有关对象和函数）"><a href="#this（有关对象和函数）" class="headerlink" title="this（有关对象和函数）"></a>this（有关对象和函数）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">username = <span class="string">"lisi"</span></span><br><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    username:<span class="string">"张三"</span>,</span><br><span class="line">    fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = json.fn()</span><br><span class="line"><span class="built_in">console</span>.log(obj.username)<span class="comment">//张三 正常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = json.fn</span><br><span class="line"><span class="built_in">console</span>.log(obj().username) <span class="comment">//lisi  原因：此时obj为一个函数，函数的this指向window</span></span><br></pre></td></tr></table></figure><h4 id="bind-call-applay"><a href="#bind-call-applay" class="headerlink" title="bind call applay"></a>bind call applay</h4><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    username:<span class="string">"张三"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//window对象上面属性不存在就会是undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.username,(a+b))</span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">//undefined NaN</span></span><br><span class="line">fn.call(json,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//张三 3</span></span><br><span class="line">fn.apply(json,[<span class="number">1</span>,<span class="number">2</span>]);<span class="comment">//张三 3</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"box"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>,a)</span><br><span class="line">&#125;.bind(json,<span class="number">100</span>);&#123;<span class="attr">username</span>: <span class="string">"张三"</span>&#125; <span class="number">100</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;变量提升&quot;&gt;&lt;a href=&quot;#变量提升&quot; class=&quot;headerlink&quot; title=&quot;变量提升&quot;&gt;&lt;/a&gt;变量提升&lt;/h4&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
    
      <category term="js" scheme="https://tianjiec.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>todoList</title>
    <link href="https://tianjiec.top/2018/12/25/todoList/"/>
    <id>https://tianjiec.top/2018/12/25/todoList/</id>
    <published>2018-12-25T09:51:57.000Z</published>
    <updated>2018-12-25T12:27:59.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h1><h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><blockquote><p>显示所有任务 ； 已完成任务 ；未完成任务；</p><p>每个任务点击对号记入已完成任务；每个任务有个删除功能；未完成任务在删除的时候弹出确认删除未完成任务的对话框；</p></blockquote><h3 id="技术："><a href="#技术：" class="headerlink" title="技术："></a>技术：</h3><p>SUI Mobile框架</p><p>vue框架</p><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><h4 id="1、借用SUI-Mobile写样式"><a href="#1、借用SUI-Mobile写样式" class="headerlink" title="1、借用SUI Mobile写样式"></a>1、借用SUI Mobile写样式</h4><p><strong>首先将sui的样式css文件引入</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"http://g.alicdn.com/msui/sm/0.6.2/css/sm.min.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ps:这里sui他给的href或src地址要加上http: ， 不然会找不到资源</p><p><strong>然后找到相应的组件</strong></p><p>标题栏、图标、卡片</p><h4 id="2、借助Vue插入数据"><a href="#2、借助Vue插入数据" class="headerlink" title="2、借助Vue插入数据"></a>2、借助Vue插入数据</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span> <span class="attr">v-for</span>=<span class="string">"todo in showTodo"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card-content-inner"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;todo.content&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"> <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">     el: <span class="string">"#app"</span>,</span></span><br><span class="line"><span class="undefined">     data: &#123;</span></span><br><span class="line"><span class="undefined">         todos: [&#123;</span></span><br><span class="line"><span class="undefined">                 id: 1,</span></span><br><span class="line"><span class="javascript">                 content: <span class="string">"hello,今天又是美好的一天"</span>,</span></span><br><span class="line"><span class="javascript">                 isFinished: <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">             &#125;,</span></span><br><span class="line"><span class="undefined">             &#123;</span></span><br><span class="line"><span class="undefined">                  id: 2,</span></span><br><span class="line"><span class="javascript">                  content: <span class="string">"你好"</span>,</span></span><br><span class="line"><span class="javascript">                  isFinished: <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">              &#125;</span></span><br><span class="line"><span class="undefined">          ],</span></span><br><span class="line"><span class="undefined">     &#125;</span></span><br><span class="line"><span class="undefined"> &#125;)</span></span><br><span class="line"><span class="undefined"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、添加完成任务和删除任务按钮"><a href="#3、添加完成任务和删除任务按钮" class="headerlink" title="3、添加完成任务和删除任务按钮"></a>3、添加完成任务和删除任务按钮</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\罗中运\AppData\Roaming\Typora\typora-user-images\1545735525618.png" alt="1545735525618" title="">                </div>                <div class="image-caption">1545735525618</div>            </figure><p>在内容 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br></pre></td></tr></table></figure><p>下添加 sui 的按钮组件</p><p>为button添加 data isFinished: false属性（在每个todo 对象里面）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"button button-round"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">:class</span>=<span class="string">"(todo.isFinished?'active':'')"</span> </span></span><br><span class="line"><span class="tag">@<span class="attr">click</span>=<span class="string">"todo.isFinished=!todo.isFinished"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><p>1、为其添加 vue的 v-bind:class  用isFinished数据控制 它的样式</p><p>2、再为其添加 v-on:click 点击事件 来改变 isFinished的值来间接控制它的样式</p><p><strong>为删除任务添加事件</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"button button-round"</span></span></span><br><span class="line"><span class="tag">@<span class="attr">click</span>=<span class="string">"checkTodo(todo.id,todo.isFinished)"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><p>在任务状态为已完成（isFinished=true时）直接删除</p><p>在任务状态为未完成  弹出对话框</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\罗中运\AppData\Roaming\Typora\typora-user-images\1545736203312.png" alt="1545736203312" title="">                </div>                <div class="image-caption">1545736203312</div>            </figure><p>为对话框是否显示 添加数据  isRemoveShow: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"isRemoveShow=false"</span> <span class="attr">v-if</span>=<span class="string">"isRemoveShow"</span> <span class="attr">class</span>=<span class="string">"decive-content"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-if =true的时候显示 =false的时候隐藏</p><p>设置点击 除确定 的地方 将其隐藏 ： @click=”isRemoveShow=false” </p><h4 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h4><p>在 vue对象中：</p><blockquote><p> 删除按钮： <a href="#" class="button button-round" @click="checkTodo(todo.id,todo.isFinished)"></a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">        removeTodo(id) &#123;</span><br><span class="line">            <span class="keyword">this</span>.todos = <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> todo.id !== id ? todo : <span class="string">""</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        checkTodo(id, isFinished) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isFinished) &#123;</span><br><span class="line">                <span class="keyword">this</span>.isRemoveShow = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.preRemoveId = id;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.removeTodo(id);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>为对话框的确定添加删除功能</p><p> <span class="modal-button modal-button-bold" @click="removeTodo(preRemoveId)">确定</span></p><p>ps:这里 点击发生了冒泡，再删除数据的同时，也冒泡触发了 其父元素的 @click=”isRemoveShow=false”事件</p><p>为了给确定指明删除哪一个</p><p>在点击删除未完成任务的时候 存一个preRemoveId 用来记录此时的数据的id</p><h4 id="4、添加分类按钮"><a href="#4、添加分类按钮" class="headerlink" title="4、添加分类按钮"></a>4、添加分类按钮</h4><p>用sui的样式 和 vue的v-for循环添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">:class</span>=<span class="string">"['button',activeType === btn.type?'active':'']"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"(btn) in btns"</span> <span class="attr">:key</span>=<span class="string">"btn.id"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">click</span>=<span class="string">"activeType=btn.type"</span></span></span><br><span class="line"><span class="tag">&gt;</span>&#123;&#123;btn.title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为按钮创建数据模型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">btns: [&#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    type: <span class="string">"all"</span>,</span><br><span class="line">    title: <span class="string">"A"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">   &#123;</span><br><span class="line">       id: <span class="number">2</span>,</span><br><span class="line">       type: <span class="string">"finished"</span>,</span><br><span class="line">       title: <span class="string">"F"</span>,</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">       id: <span class="number">3</span>,</span><br><span class="line">       type: <span class="string">"unfinished"</span>,</span><br><span class="line">       title: <span class="string">"U"</span>,</span><br><span class="line">   &#125;,</span><br><span class="line">  ],</span><br><span class="line">    activeType: <span class="string">"all"</span></span><br></pre></td></tr></table></figure><p>title 用于显示文本、type用来匹配当前选中 哪一个 activeType 用来 表示 哪个选中</p><p><strong>按钮的</strong>  :calss 用来通过数据决定哪个被选中 </p><p><strong>添加点击事件改变选中</strong>：@click=”activeType=btn.type”</p><p>PS：所以，对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>。</p><p><strong>添加计算属性 来 控制显示 哪一部分数据</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">            finished()&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> todo.isFinished?todo:<span class="string">""</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            unfinished()&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> !todo.isFinished?todo:<span class="string">""</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            showTodo()&#123;</span><br><span class="line">                <span class="keyword">switch</span>(<span class="keyword">this</span>.activeType)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"all"</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.todos;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"finished"</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.finished;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"unfinished"</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.unfinished;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//&lt;div class="card" v-for="todo in showTodo"&gt;</span></span><br><span class="line"><span class="comment">//修改循环显示的 数据</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;任务列表&quot;&gt;&lt;a href=&quot;#任务列表&quot; class=&quot;headerlink&quot; title=&quot;任务列表&quot;&gt;&lt;/a&gt;任务列表&lt;/h1&gt;&lt;h3 id=&quot;功能：&quot;&gt;&lt;a href=&quot;#功能：&quot; class=&quot;headerlink&quot; title=&quot;功能：&quot;&gt;&lt;/a&gt;功能
      
    
    </summary>
    
    
      <category term="sui vue" scheme="https://tianjiec.top/tags/sui-vue/"/>
    
  </entry>
  
  <entry>
    <title>js的this</title>
    <link href="https://tianjiec.top/2018/12/24/js%E7%9A%84this/"/>
    <id>https://tianjiec.top/2018/12/24/js的this/</id>
    <published>2018-12-24T04:14:45.000Z</published>
    <updated>2018-12-24T06:01:28.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this-指向详细解析（箭头函数）"><a href="#this-指向详细解析（箭头函数）" class="headerlink" title="this 指向详细解析（箭头函数）"></a>this 指向详细解析（箭头函数）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>this 指向问题是入坑前端必须了解知识点，现在迎来了ES6时代，因为箭头函数的出现，所以感觉有必要对 this 问题梳理一下，遂有此文</p><p>在非箭头函数下， this 指向调用其所在函数的对象，而且是离谁近就是指向谁（此对于常规对象，原型链， getter &amp; setter等都适用）；构造函数下，this与被创建的新对象绑定；DOM事件，this指向触发事件的元素；内联事件分两种情况，bind绑定， call &amp; apply 方法等， 容以下一步一步讨论。箭头函数也会穿插其中进行讨论。</p><h2 id="全局环境下"><a href="#全局环境下" class="headerlink" title="全局环境下"></a>全局环境下</h2><p>在全局环境下，this 始终指向全局对象（window）, 无论是否严格模式；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(this.document === document); // true</span><br><span class="line"></span><br><span class="line">// 在浏览器中，全局对象为 window 对象：</span><br><span class="line">console.log(this === window); // true</span><br><span class="line"></span><br><span class="line">this.a = 37;</span><br><span class="line">console.log(window.a); // 37</span><br></pre></td></tr></table></figure><h2 id="函数上下文调用"><a href="#函数上下文调用" class="headerlink" title="函数上下文调用"></a>函数上下文调用</h2><h3 id="函数直接调用"><a href="#函数直接调用" class="headerlink" title="函数直接调用"></a>函数直接调用</h3><p>普通函数内部的this分两种情况，严格模式和非严格模式。</p><p>非严格模式下，this 默认指向全局对象window</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1() === window; // true</span><br></pre></td></tr></table></figure><p>而严格模式下， this为undefined</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f2()&#123;</span><br><span class="line">  &quot;use strict&quot;; // 这里是严格模式</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2() === undefined; // true</span><br></pre></td></tr></table></figure><h3 id="对象中的this"><a href="#对象中的this" class="headerlink" title="对象中的this"></a>对象中的this</h3><p>对象内部方法的this指向调用这些方法的对象，</p><ol><li>函数的定义位置不影响其this指向，this指向只和调用函数的对象有关。</li><li>多层嵌套的对象，内部方法的this指向离被调用函数最近的对象（window也是对象，其内部对象调用方法的this指向内部对象， 而非window）。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line">var o = &#123;</span><br><span class="line">  prop: 37,</span><br><span class="line">  f: function() &#123;</span><br><span class="line">    return this.prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(o.f());  //37</span><br><span class="line">var a = o.f;</span><br><span class="line">console.log(a()):  //undefined</span><br><span class="line"></span><br><span class="line">var o = &#123;prop: 37&#125;;</span><br><span class="line"></span><br><span class="line">function independent() &#123;</span><br><span class="line">  return this.prop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f = independent;</span><br><span class="line"></span><br><span class="line">console.log(o.f()); // logs 37</span><br><span class="line"></span><br><span class="line">//2</span><br><span class="line">o.b = &#123;</span><br><span class="line">  g: independent,</span><br><span class="line">  prop: 42</span><br><span class="line">&#125;;</span><br><span class="line">console.log(o.b.g()); // logs 42</span><br></pre></td></tr></table></figure><h4 id="原型链中this"><a href="#原型链中this" class="headerlink" title="原型链中this"></a>原型链中this</h4><p>原型链中的方法的this仍然指向调用它的对象，与以上讨论一致；看个例子，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  f : function()&#123; </span><br><span class="line">    return this.a + this.b; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var p = Object.create(o);</span><br><span class="line">p.a = 1;</span><br><span class="line">p.b = 4;</span><br><span class="line"></span><br><span class="line">console.log(p.f()); // 5</span><br></pre></td></tr></table></figure><p>可以看出， 在p中没有属性f，当执行p.f()时，会查找p的原型链，找到 f 函数并执行，但这与函数内部this指向对象 p 没有任何关系，只需记住谁调用指向谁。</p><p>以上对于函数作为getter &amp; setter 调用时同样适用。</p><h3 id="构造函数中this"><a href="#构造函数中this" class="headerlink" title="构造函数中this"></a>构造函数中this</h3><p>构造函数中的this与被创建的新对象绑定。</p><p>注意：当构造器返回的默认值是一个this引用的对象时，可以手动设置返回其他的对象，如果返回值不是一个对象，返回this。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function C()&#123;</span><br><span class="line">  this.a = 37;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = new C();</span><br><span class="line">console.log(o.a); // logs 37</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function C2()&#123;</span><br><span class="line">  this.a = 37;</span><br><span class="line">  return &#123;a:38&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = new C2();</span><br><span class="line">console.log(b.a); // logs 38</span><br></pre></td></tr></table></figure><p>以上两个例子内部的this都指向对象o, 看到这里的你不妨在控制台执行下以上代码，看看对象 o 和 b ，这些是属于构造函数的内容了，此处不多做介绍。（C2函数中的this.a = 37 对整个过程完全没有影响的， 可以被忽略的）。</p><h3 id="call-amp-apply"><a href="#call-amp-apply" class="headerlink" title="call &amp; apply"></a>call &amp; apply</h3><p>当函数通过Function对象的原型中继承的方法 call() 和 apply() 方法调用时， 其函数内部的this值可绑定到 call() &amp; apply() 方法指定的第一个对象上， 如果第一个参数不是对象，JavaScript内部会尝试将其转换成对象然后指向它。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function add(c, d)&#123;</span><br><span class="line">  return this.a + this.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = &#123;a:1, b:3&#125;;</span><br><span class="line"></span><br><span class="line">add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16</span><br><span class="line"></span><br><span class="line">add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</span><br><span class="line"></span><br><span class="line">function tt() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">// 返回对象见下图（图1）</span><br><span class="line">tt.call(5);  // Number &#123;[[PrimitiveValue]]: 5&#125; </span><br><span class="line">tt.call(&apos;asd&apos;); // String &#123;0: &quot;a&quot;, 1: &quot;s&quot;, 2: &quot;d&quot;, length: 3, [[PrimitiveValue]]: &quot;asd&quot;&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144423820-371299881.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h3 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h3><p>bind方法在ES5引入， 在Function的原型链上， <code>Function.prototype.bind</code>。通过bind方法绑定后， 函数将被永远绑定在其第一个参数对象上， 而无论其在什么情况下被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">  return this.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = f.bind(&#123;a:&quot;azerty&quot;&#125;);</span><br><span class="line">console.log(g()); // azerty</span><br><span class="line"></span><br><span class="line">var o = &#123;a:37, f:f, g:g&#125;;</span><br><span class="line">console.log(o.f(), o.g()); // 37, azerty</span><br></pre></td></tr></table></figure><h3 id="DOM-事件处理函数中的-this-amp-内联事件中的-this"><a href="#DOM-事件处理函数中的-this-amp-内联事件中的-this" class="headerlink" title="DOM 事件处理函数中的 this &amp; 内联事件中的 this"></a>DOM 事件处理函数中的 this &amp; 内联事件中的 this</h3><p><strong>DOM事件处理函数</strong></p><ol><li>当函数被当做监听事件处理函数时， 其 this 指向触发该事件的元素 （针对于addEventListener事件）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 被调用时，将关联的元素变成蓝色</span><br><span class="line">  function bluify(e)&#123;</span><br><span class="line">    //在控制台打印出所点击元素</span><br><span class="line">    console.log(this);</span><br><span class="line">    //阻止时间冒泡</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    //阻止元素的默认事件</span><br><span class="line">    e.preventDefault();      </span><br><span class="line">    this.style.backgroundColor = &apos;#A5D9F3&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 获取文档中的所有元素的列表</span><br><span class="line">  var elements = document.getElementsByTagName(&apos;*&apos;);</span><br><span class="line"></span><br><span class="line">  // 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span><br><span class="line">  for(var i=0 ; i&lt;elements.length ; i++)&#123;</span><br><span class="line">    elements[i].addEventListener(&apos;click&apos;, bluify, false);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上代码建议在网页中执行以下，看下效果。</p><p><strong>内联事件</strong><br>内联事件中的this指向分两种情况：</p><ol><li>当代码被内联处理函数调用时，它的this指向监听器所在的DOM元素</li><li>当代码被包括在函数内部执行时，其this指向等同于 <strong><strong>函数直接调用</strong></strong>的情况，即在非严格模式指向全局对象window， 在严格模式指向undefined</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144449757-948944211.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>页面的代码块</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144504413-1120828849.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>在浏览器内显示三个按钮</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144511679-451778615.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>依次点击上边的三个按钮后在控制台的输出结果，</p><p>建议自己操作一遍以便于更好的理解。</p><h3 id="setTimeout-amp-setInterval"><a href="#setTimeout-amp-setInterval" class="headerlink" title="setTimeout &amp; setInterval"></a>setTimeout &amp; setInterval</h3><p>对于延时函数内部的回调函数的this指向全局对象window（当然我们可以通过bind方法改变其内部函数的this指向）<br>看下边代码及截图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//默认情况下代码</span><br><span class="line">function Person() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();//3秒后返回 window 对象</span><br><span class="line">==============================================</span><br><span class="line">//通过bind绑定</span><br><span class="line">function Person() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setTimeout((function() &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;).bind(this), 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();//3秒后返回构造函数新生成的对象 Person&#123;...&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144527554-990414883.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144536820-1525099793.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h2 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h2><p>由于箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值，</p><ol><li>所以 call() / apply() / bind() 方法对于箭头函数来说只是传入参数，对它的 this 毫无影响。</li><li>考虑到 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。（可以忽略是否在严格模式下的影响）</li></ol><p>因为箭头函数可以捕获其所在上下文的this值 所以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">        // 回调里面的 `this` 变量就指向了期望的那个对象了</span><br><span class="line">        this.age++;</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();</span><br></pre></td></tr></table></figure><p>以上代码可以得到我们所以希望的值，下图可以看到，在setTimeout中的this指向了构造函数新生成的对象，而普通函数指向了全局window对象</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144556179-936108349.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var adder = &#123;</span><br><span class="line">  base : 1,</span><br><span class="line">    </span><br><span class="line">  add : function(a) &#123;</span><br><span class="line">    var f = v =&gt; v + this.base;</span><br><span class="line">    return f(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addThruCall: function inFun(a) &#123;</span><br><span class="line">    var f = v =&gt; v + this.base;</span><br><span class="line">    var b = &#123;</span><br><span class="line">      base : 2</span><br><span class="line">    &#125;;</span><br><span class="line">            </span><br><span class="line">    return f.call(b, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(adder.add(1));         // 输出 2</span><br><span class="line">console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3，其内部的this并没有因为call() 而改变，其this值仍然为函数inFun的this值，指向对象adder</span><br></pre></td></tr></table></figure><p>bind() &amp; apply() 读者可以自行测试</p><p>对于是否严格模式示例代码（可以复制进控制台进行验证）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var f = () =&gt; &#123;&apos;use strict&apos;; return this&#125;;</span><br><span class="line">var p = () =&gt; &#123; return this&#125;;</span><br><span class="line">console.log(1,f() === window);</span><br><span class="line">console.log(2,f() === p());</span><br><span class="line">//1 true</span><br><span class="line">//2 true</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144613820-1277977431.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>以上的箭头函数都是在方法内部，总之都是以非方法的方式使用，如果将箭头函数当做一个方法使用会怎样呢？<br>上例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  i: 10,</span><br><span class="line">  b: () =&gt; console.log(this.i, this),</span><br><span class="line">  c: function() &#123;</span><br><span class="line">    console.log( this.i, this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b();  // undefined window&#123;...&#125;</span><br><span class="line">obj.c();  // 10 Object &#123;...&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144630663-1545275969.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>可以看到，作为方法的箭头函数this指向全局window对象，而普通函数则指向调用它的对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;this-指向详细解析（箭头函数）&quot;&gt;&lt;a href=&quot;#this-指向详细解析（箭头函数）&quot; class=&quot;headerlink&quot; title=&quot;this 指向详细解析（箭头函数）&quot;&gt;&lt;/a&gt;this 指向详细解析（箭头函数）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>箭头函数this</title>
    <link href="https://tianjiec.top/2018/12/24/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this/"/>
    <id>https://tianjiec.top/2018/12/24/箭头函数this/</id>
    <published>2018-12-24T04:03:14.000Z</published>
    <updated>2018-12-24T05:07:13.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h3><p>由于箭头函数不绑定this，他会捕捉所在上下文的this值，作为自己的this值，</p><p>​    1、所以call()/apply()/bind() 方法对于箭头函数来说只是传入参数，对他的this值毫无影响。</p><p>​    2、考虑到this是语法层面上的，严格模式中this相关的规则都可以忽略。（可以忽略是否在严格模式下的影响）</p><p>因为箭头函数可以捕获其上下文的this值所以</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line">     setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 回调里面的 `this` 变量就指向了期望的那个对象了</span></span><br><span class="line">        <span class="keyword">this</span>.age++;</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>以上代码可以得到我们所以希望的值，下图可以看到，在setTimeout中的this指向了构造函数新生成的对象，而普通函数指向了全局window对象</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144556179-936108349.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adder = &#123;</span><br><span class="line">  base : <span class="number">1</span>,</span><br><span class="line">    </span><br><span class="line">  add : <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="keyword">this</span>.base;</span><br><span class="line">    <span class="keyword">return</span> f(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addThruCall: <span class="function"><span class="keyword">function</span> <span class="title">inFun</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="keyword">this</span>.base;</span><br><span class="line">    <span class="keyword">var</span> b = &#123;</span><br><span class="line">      base : <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> f.call(b, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(adder.add(<span class="number">1</span>));         <span class="comment">// 输出 2</span></span><br><span class="line"><span class="built_in">console</span>.log(adder.addThruCall(<span class="number">1</span>)); <span class="comment">// 仍然输出 2（而不是3，其内部的this并没有因为call() 而改变，其this值仍然为函数inFun的this值，指向对象adder</span></span><br></pre></td></tr></table></figure><p>bind() &amp; apply() 读者可以自行测试</p><p>对于是否严格模式示例代码（可以复制进控制台进行验证）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="string">'use strict'</span>; <span class="keyword">return</span> <span class="keyword">this</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>,f() === <span class="built_in">window</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>,f() === p());</span><br><span class="line"><span class="comment">//1 true</span></span><br><span class="line"><span class="comment">//2 true</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144613820-1277977431.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>以上的箭头函数都是在方法内部，总之都是以非方法的方式使用，如果将箭头函数当做一个方法使用会怎样呢？<br>上例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  i: <span class="number">10</span>,</span><br><span class="line">  b: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.i, <span class="keyword">this</span>),</span><br><span class="line">  c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.i, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b();  <span class="comment">// undefined window&#123;...&#125;</span></span><br><span class="line">obj.c();  <span class="comment">// 10 Object &#123;...&#125;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144630663-1545275969.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>可以看到，作为方法的箭头函数this指向全局window对象，而普通函数则指向调用它的对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;箭头函数中的this&quot;&gt;&lt;a href=&quot;#箭头函数中的this&quot; class=&quot;headerlink&quot; title=&quot;箭头函数中的this&quot;&gt;&lt;/a&gt;箭头函数中的this&lt;/h3&gt;&lt;p&gt;由于箭头函数不绑定this，他会捕捉所在上下文的this值，作为自己的thi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue1</title>
    <link href="https://tianjiec.top/2018/12/24/Vue1/"/>
    <id>https://tianjiec.top/2018/12/24/Vue1/</id>
    <published>2018-12-24T03:09:56.000Z</published>
    <updated>2018-12-24T05:05:34.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总结一"><a href="#总结一" class="headerlink" title="总结一"></a>总结一</h1><h4 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./base/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//每一个应用都是从创建一个实例开始的</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//每一个应用起码得来这么一个实例</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//声明式渲染：声明一条数据之后再利用特殊的模板语法将数据渲染到页面中</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line"><span class="undefined">        data:&#123;</span></span><br><span class="line"><span class="javascript">            message:<span class="string">"hello world"</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="mvc-设计模式示例"><a href="#mvc-设计模式示例" class="headerlink" title="mvc 设计模式示例"></a>mvc 设计模式示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span>&gt;</span>toggle<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn2"</span>&gt;</span>big<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./base/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//mvc的设计模式  设计项目逻辑</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//m: model 数据模型  v: view 视图  c: controller 控制器</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//c层需要控制model 在 view 进行显示</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//M层的数据和v层的显示存在一个映射关系， 当我们建立好c层之后，焦点关注在数据变化上就行了。</span></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">//通过简单的mvc的设计思想来构建</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//view层</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> view = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'box'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    <span class="comment">//model</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> model = &#123;</span></span><br><span class="line"><span class="javascript">        isShow: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        isBig: <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//controller</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">Controller</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.init()；</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    Controller.prototype = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">constructor</span>: Controller,</span></span><br><span class="line"><span class="undefined">        init()&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">this</span>.addEvent();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.render();</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        addEvent()&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//let self = self;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//let This = this;</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"btn"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> btn2 = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"btn2"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">            btn.onclick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="undefined">                model.isShow = !model.isShow;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.render();</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            btn2.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                model.isBig = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.render();</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        render()&#123;<span class="comment">//渲染的过程</span></span></span><br><span class="line"><span class="javascript">            view.style.display = model.isShow?<span class="string">"block"</span>:<span class="string">"none"</span>;</span></span><br><span class="line"><span class="javascript">            view.style.width = (model.isBig ? <span class="number">400</span> : <span class="number">50</span>)+<span class="string">"px"</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Controller();</span></span><br></pre></td></tr></table></figure><h3 id="vue的mvvm-设计模式"><a href="#vue的mvvm-设计模式" class="headerlink" title="vue的mvvm 设计模式"></a>vue的mvvm 设计模式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标签内 数据不需要&#123;&#123;&#125;&#125; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-model 是vue 提供的指令 它的作用是操作dom --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//Vue 采用的是MVVM模式，这是MVC衍生出来的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//区别：视图与vieqmodel直接的关系紧密</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//M层的数据会与v层视图 建立联系</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//v-model就是vue提供的指令 操作dom</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="javascript">            message: <span class="string">"hello World"</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">".app"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="comment">// data:data</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//data与data名相同 可简写为data</span></span></span><br><span class="line"><span class="undefined">            data</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="javascript">        <span class="comment">//Vue当中实现双向数据绑定的原理：</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//vue在创建viewmodel的时候，会将数据配置在实例中，然后会是使用Object.defineProperty对这</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//些数据进行处理，并且为这些数据添加getter，setter方法，当数据改变之后，就会触发此数据绑定的setter方法</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//从而触发vm的watcher方法，然后数据改变了，然后vm进一步渲染view视图。</span></span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="javascript">            message: <span class="string">"Hello world"</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">".app"</span>,</span></span><br><span class="line"><span class="undefined">            data</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//Object.defineProperty()  es5提供的 ie8不支持</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> _data = &#123;</span></span><br><span class="line"><span class="undefined">            </span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> temp = <span class="number">123</span>;</span></span><br><span class="line"><span class="undefined">          temp = 123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Object</span>.defineProperty(_data,<span class="string">"msg"</span>,&#123;</span></span><br><span class="line"><span class="undefined">            get()&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"getter"</span>)</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> temp;</span></span><br><span class="line"><span class="undefined">              </span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            set(vel)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"setter"</span>)</span></span><br><span class="line"><span class="undefined">                temp = vel;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="javascript">        <span class="comment">//获取数据</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(_data.msg)</span></span><br><span class="line"><span class="javascript">        <span class="comment">//设置属性的时候会执行setter方法</span></span></span><br><span class="line"><span class="undefined">        _data.msg = 456;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(_data.msg)</span></span><br><span class="line"><span class="javascript">        <span class="comment">//vue双向数据绑定原理</span></span></span><br><span class="line"><span class="undefined">        /* </span></span><br><span class="line"><span class="undefined">            当view层数据改变时， 通过监听viewmodel获取数据  viewmodel再去改变 model数据层</span></span><br><span class="line"><span class="undefined">            数据修改之后 viewmodel再去设置 view层的显示</span></span><br><span class="line"><span class="undefined">         */</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;总结一&quot;&gt;&lt;a href=&quot;#总结一&quot; class=&quot;headerlink&quot; title=&quot;总结一&quot;&gt;&lt;/a&gt;总结一&lt;/h1&gt;&lt;h4 id=&quot;demo1&quot;&gt;&lt;a href=&quot;#demo1&quot; class=&quot;headerlink&quot; title=&quot;demo1&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node.js取参的四种方法</title>
    <link href="https://tianjiec.top/2018/12/21/node-js%E5%8F%96%E5%8F%82%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://tianjiec.top/2018/12/21/node-js取参的四种方法/</id>
    <published>2018-12-21T11:59:17.000Z</published>
    <updated>2018-12-21T12:01:13.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="node-js取参四种方法"><a href="#node-js取参四种方法" class="headerlink" title="node.js取参四种方法"></a>node.js取参四种方法</h1><h4 id="req-body-req-params-req-param-req-body"><a href="#req-body-req-params-req-param-req-body" class="headerlink" title="req.body,req.params,req.param,req.body"></a>req.body,req.params,req.param,req.body</h4><p>参考：<a href="https://my.oschina.net/u/2519530/blog/535309" target="_blank" rel="noopener">https://my.oschina.net/u/2519530/blog/535309</a></p><p>获取请求很中的参数是每个web后台处理的必经之路，nodejs的 <strong>express框架</strong> 提供了四种方法来实现。</p><p>1,req.body</p><p>2,req.query</p><p>3,req.params</p><p>4,req.param()</p><p><strong>首先介绍第一个req.body</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">官方文档解释：</span><br><span class="line">Contains key-value pairs of data submitted in the request body. By default, it is undefined,</span><br><span class="line"> and is populated when you use body-parsing middleware such as body-parser and multer.</span><br><span class="line"></span><br><span class="line">稍微翻译一下：包含了提交数据的键值对在请求的body中，默认是underfined,</span><br><span class="line">你可以用body-parser或者multer来解析body</span><br></pre></td></tr></table></figure><p>解析body不是nodejs默认提供的，你需要载入body-parser中间件才可以使用req.body；</p><p>此方法通常用来解析POST请求中的数据</p><p><strong>第二种是req.query</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">官方文档解释：</span><br><span class="line">An object containing a property for each query string parameter in the route. </span><br><span class="line">If there is no query string, it is the empty object, &#123;&#125;.</span><br><span class="line">翻译一下:包含在路由中每个查询字符串参数属性的对象。如果没有，默认为&#123;&#125;</span><br></pre></td></tr></table></figure><p>有nodejs默认提供，无需载入中间件</p><p>举例说明（官方摘录）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /search?q=tobi+ferret</span></span><br><span class="line">req.query.q</span><br><span class="line"><span class="comment">// =&gt; "tobi ferret"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=converse</span></span><br><span class="line">req.query.order</span><br><span class="line"><span class="comment">// =&gt; "desc"</span></span><br><span class="line">req.query.shoe.color</span><br><span class="line"><span class="comment">// =&gt; "blue"</span></span><br><span class="line">req.query.shoe.type</span><br><span class="line"><span class="comment">// =&gt; "converse"</span></span><br></pre></td></tr></table></figure><p><strong>注意：此方法多适用于GET请求，解析GET里的参数</strong></p><p><strong>第三种是 req.params</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">官方文档：</span><br><span class="line">An object containing properties mapped to the named route “parameters”. </span><br><span class="line">For example, <span class="keyword">if</span> you have the route /user/:name, </span><br><span class="line">then the “name” property is available <span class="keyword">as</span> req.params.name. This object defaults to &#123;&#125;.</span><br><span class="line"></span><br><span class="line">翻译：包含映射到指定的路线“参数”属性的对象。</span><br><span class="line">例如，如果你有route/user/：name，那么“name”属性可作为req.params.name。</span><br><span class="line">该对象默认为&#123;&#125;。</span><br></pre></td></tr></table></figure><p>nodejs默认提供，无需载入其他中间件</p><p>举例说明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /user/tj</span></span><br><span class="line">req.params.name</span><br><span class="line"><span class="comment">// =&gt; "tj"</span></span><br></pre></td></tr></table></figure><p><strong>多适用于restful风格url中的参数的解析</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eq.query与req.params的区别</span><br><span class="line">req.params包含路由参数（在URL的路径部分），而req.query包含URL的查询参数（在URL的？后的参数）。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;node-js取参四种方法&quot;&gt;&lt;a href=&quot;#node-js取参四种方法&quot; class=&quot;headerlink&quot; title=&quot;node.js取参四种方法&quot;&gt;&lt;/a&gt;node.js取参四种方法&lt;/h1&gt;&lt;h4 id=&quot;req-body-req-params-r
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>soket</title>
    <link href="https://tianjiec.top/2018/12/20/soket/"/>
    <id>https://tianjiec.top/2018/12/20/soket/</id>
    <published>2018-12-20T12:35:54.000Z</published>
    <updated>2018-12-20T12:43:12.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>当前程序执行：</p><p>同步：阻塞，当前程序是否能够去执行，必须等前一个程序执行完毕之后，才能够去执行。</p><p>异步：非阻塞，当前程序的执行，并不受前一个程序是否执行完毕的影响。</p><p>多个程序之间的关系 （串行/并行）</p><p>并行： 多个程序之间可以同时或者不同时去执行，叫做并行</p><p>串行： 多个程序之间必须按照顺序去执行，这叫串行。</p><p>1、同步执行的程序，必然是串行的</p><p>2、异步执行的程序，可以实现串行</p><p>3、并行的程序必然是异步执行</p><p>套接字：</p><p>上传视频 ： 视频 =&gt; 二进制 =&gt; 分块（编码） + ip：port=&gt; 传输 =&gt; 组装</p><p>SOCKET</p><p>网络上两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="file:///C:/Users/罗中运/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image001.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h4 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h4><table><thead><tr><th>创建用来接收数据和广播数据的 服务器：</th><th></th></tr></thead><tbody><tr><td>创建socket</td><td>socket（）</td></tr><tr><td>绑定soket和端口号</td><td>bind（）</td></tr><tr><td>监听端口号</td><td>listen（）</td></tr><tr><td>接受信息</td><td>accept（）</td></tr><tr><td>从socket中读取字符</td><td>recv（）</td></tr><tr><td>关闭socket</td><td>close（）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;同步和异步&quot;&gt;&lt;a href=&quot;#同步和异步&quot; class=&quot;headerlink&quot; title=&quot;同步和异步&quot;&gt;&lt;/a&gt;同步和异步&lt;/h2&gt;&lt;p&gt;当前程序执行：&lt;/p&gt;
&lt;p&gt;同步：阻塞，当前程序是否能够去执行，必须等前一个程序执行完毕之后，才能够去执行。&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>5-1Node.js编写</title>
    <link href="https://tianjiec.top/2018/12/20/5-1Node-js%E7%BC%96%E5%86%99/"/>
    <id>https://tianjiec.top/2018/12/20/5-1Node-js编写/</id>
    <published>2018-12-20T09:17:09.000Z</published>
    <updated>2018-12-20T09:18:20.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学前需求"><a href="#学前需求" class="headerlink" title="学前需求"></a>学前需求</h2><blockquote><h3 id="一、node安装和运行"><a href="#一、node安装和运行" class="headerlink" title="一、node安装和运行"></a>一、node安装和运行</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">会安装node，搭建node环境</span><br><span class="line">会运行node执行node程序</span><br></pre></td></tr></table></figure><blockquote><h3 id="二、node基础模块的使用"><a href="#二、node基础模块的使用" class="headerlink" title="二、node基础模块的使用"></a>二、node基础模块的使用</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Buffer：二进制数据处理模块</span><br><span class="line">Events：事件模块</span><br><span class="line">fs：文件系统模块</span><br><span class="line">Net：网络模块</span><br><span class="line">Http：http模块</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://nodejs.org/api/" target="_blank" rel="noopener">https://nodejs.org/api/</a></p></blockquote><h2 id="前台管理功能"><a href="#前台管理功能" class="headerlink" title="前台管理功能"></a>前台管理功能</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/BUkKRSYer6YG8srS1RteyV39UGe04Zi8kcWL7bwoQas!/b/dGYBAAAAAAAA&bo=cgF6AQAAAAADByo!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="后台页面"><a href="#后台页面" class="headerlink" title="后台页面"></a>后台页面</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/R660H48.QMim2kKOUN.K5Pkfhpdcpu2cfnZmsIuDq.k!/b/dDEBAAAAAAAA&bo=KAKqAwAAAAADB6E!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="三、技术框架介绍"><a href="#三、技术框架介绍" class="headerlink" title="三、技术框架介绍"></a>三、技术框架介绍</h3><p>NodeJS、Express、Mongodb</p><h3 id="四、第三方模块-amp-中间件"><a href="#四、第三方模块-amp-中间件" class="headerlink" title="四、第三方模块&amp;中间件"></a>四、第三方模块&amp;中间件</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body-parser:解析post请求数据</span><br><span class="line">cookies:读/写cookie</span><br><span class="line">swig:模板解析引擎</span><br><span class="line">mongoose:操作mongodb数据</span><br><span class="line">markdown:markdown语法解析生成模块</span><br></pre></td></tr></table></figure><blockquote><h3 id="五、项目初始化"><a href="#五、项目初始化" class="headerlink" title="五、项目初始化"></a>五、项目初始化</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><blockquote><h3 id="六、依赖模块安装（要联网、要联网、要联网）"><a href="#六、依赖模块安装（要联网、要联网、要联网）" class="headerlink" title="六、依赖模块安装（要联网、要联网、要联网）"></a>六、依赖模块安装（要联网、要联网、要联网）</h3></blockquote><h2 id="应用创建"><a href="#应用创建" class="headerlink" title="应用创建"></a>应用创建</h2><blockquote><h3 id="准备：目录结构"><a href="#准备：目录结构" class="headerlink" title="准备：目录结构"></a>准备：目录结构</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/KEvmeky95HuJ4YaPSjoF5hjfAx9M9Q3bz6WsqtErtqQ!/b/dFYBAAAAAAAA&bo=xgKcAQAAAAADB3s!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="一、创建应用、监听端口-app-js中"><a href="#一、创建应用、监听端口-app-js中" class="headerlink" title="一、创建应用、监听端口(app.js中)"></a>一、创建应用、监听端口(app.js中)</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//加载express模块</span><br><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">//创建app应用  =&gt; NodeJS Http.createServer();</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">//监听http请求</span><br><span class="line">app.listen(8081);</span><br></pre></td></tr></table></figure><blockquote><h3 id="二、用户的访问"><a href="#二、用户的访问" class="headerlink" title="二、用户的访问"></a>二、用户的访问</h3><p>(1)用户通过URL访问web应用，如 http:localhost:8081/<br>(2)web后端根据用户访问的URL处理不同的业务逻辑</p><h3 id="三、处理请求输出"><a href="#三、处理请求输出" class="headerlink" title="三、处理请求输出"></a>三、处理请求输出</h3><p>(1)路由绑定：<br>通过app.get()或者app.post()等方法可以把一个url路径和一个或N个函数进行绑定。<br>app.get(“/“, function(req, res, next){}) req：request对象 - 保存客户端请求的一个数据 http.request<br>res：response对象 - 服务端输出对象，提供了一些服务器端输出相关的一些方法 - http.response<br>next：方法，用于执行下一个和路径匹配的函数</p><h3 id="四、内容输出"><a href="#四、内容输出" class="headerlink" title="四、内容输出"></a>四、内容输出</h3><p>通过res.send(string)发送内容到客户端</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//加载express模块</span><br><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">//创建app应用  =&gt; NodeJS Http.createServer();</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">首页</span><br><span class="line">监听到输入路径/，处理的操作</span><br><span class="line">*/</span><br><span class="line">app.get(&quot;/&quot;, function(req, res, next)&#123;</span><br><span class="line">res.send(&quot;&lt;h1&gt;欢迎光临我的博客!&lt;/h1&gt;&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//监听http请求</span><br><span class="line">app.listen(8081);</span><br></pre></td></tr></table></figure><blockquote><h3 id="五、使用模板"><a href="#五、使用模板" class="headerlink" title="五、使用模板"></a>五、使用模板</h3><p>（1）模板的使用<br>后端逻辑和页面表现分离 - 前后端分离<br>（2）模板的配置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//加载express模块</span><br><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">//加载模板处理前后端</span><br><span class="line">var swig = require(&quot;swig&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建app应用  =&gt; NodeJS Http.createServer();</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">//配置应用模板</span><br><span class="line">/*</span><br><span class="line">定义当前应用所使用的模板引擎,使用swig.renderFile方法解析后缀为html的文件</span><br><span class="line">第一个参数：模板引擎的名称，同时也是模板文件的后缀</span><br><span class="line">第二个参数：表示用于解析处理模板内容的方法</span><br><span class="line">*/</span><br><span class="line">app.engine(&quot;html&quot;, swig.renderFile);</span><br><span class="line">/*</span><br><span class="line">设置模板文件存放的目录</span><br><span class="line">第一个参数必须是views</span><br><span class="line">第二个参数是目录</span><br><span class="line">*/</span><br><span class="line">app.set(&quot;views&quot;, &quot;./views&quot;);</span><br><span class="line">/*</span><br><span class="line">注册所使用的模板引擎</span><br><span class="line">第一个参数：不能改必须是view engine</span><br><span class="line">第二个参数：和app.engine这个方法中定义的模板引擎的名称（第一个参数）是一致的</span><br><span class="line">*/</span><br><span class="line">app.set(&quot;view engine&quot;, &quot;html&quot;);</span><br><span class="line">/*</span><br><span class="line">【注】这里注意，在开发过程中，需要取消模板缓存</span><br><span class="line">*/</span><br><span class="line">swig.setDefaults(&#123;cache: false&#125;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">首页</span><br><span class="line">监听到输入路径/，处理的操作</span><br><span class="line">*/</span><br><span class="line">app.get(&quot;/&quot;, function(req, res, next)&#123;</span><br><span class="line">// res.send(&quot;&lt;h1&gt;欢迎光临我的博客!&lt;/h1&gt;&quot;);</span><br><span class="line">//将前后台页面进行分离</span><br><span class="line">/*</span><br><span class="line">读取view目录下的指定文件，解析并返回给客户端</span><br><span class="line">第一个参数，表示模板文件，相对于views目录 views/index.html</span><br><span class="line">第二个参数，传递给模板使用的数据。</span><br><span class="line">*/</span><br><span class="line">res.render(&quot;index&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//监听http请求</span><br><span class="line">app.listen(8081);</span><br></pre></td></tr></table></figure><blockquote><p>当我们在设置main.css样式链接的时候，提示请求失败，是因为我们没有设置对应的路由操作</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(&quot;/main.css&quot;, function(req, res, next)&#123;</span><br><span class="line"></span><br><span class="line">// 默认发送的是html格式数据，没有办法解析</span><br><span class="line">// 在这里需要设置解析格式头</span><br><span class="line"></span><br><span class="line">res.setHeader(&quot;content-type&quot;, &quot;text/css&quot;);</span><br><span class="line"></span><br><span class="line">res.send(&quot;body &#123;background-color: red;&#125;&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>但是上述这种操作处理静态文件过于麻烦，我们可以设置静态文件托管目录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//修改index.html</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;/public/main.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">//修改app.js</span><br><span class="line">/*</span><br><span class="line">设置静态文件托管</span><br><span class="line">下述代码的意思是，如果加载路径url是以/public开头的，就以后续操作处理</span><br><span class="line">*/</span><br><span class="line">app.use(&quot;/public&quot;, express.static(__dirname + &quot;/public&quot;));</span><br></pre></td></tr></table></figure><blockquote><p>【注】项目逻辑：<br>用户发送http请求 -&gt; url -&gt; 解析路由 -&gt; 找到匹配的规则 -&gt; 满足规则执行绑定的函数 -&gt; 返回对应的内容。<br>/public -&gt; 静态 -&gt; 直接读取指定目录下的文件，返回用户<br>动态 -&gt; 处理业务逻辑，加载模板，解析模板 -&gt; 返回数据给用户。</p><h2 id="六、划分模块"><a href="#六、划分模块" class="headerlink" title="六、划分模块"></a>六、划分模块</h2><h3 id="根据功能进行模块划分"><a href="#根据功能进行模块划分" class="headerlink" title="根据功能进行模块划分"></a>根据功能进行模块划分</h3><p>前台模块<br>后台管理模块<br>API模块</p><p>使用app.use()进行模块划分</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(&quot;/admin&quot;, require(&apos;./routers/admin&apos;));</span><br><span class="line">app.use(&quot;/api&quot;, require(&quot;.routers/api&quot;));</span><br><span class="line">app.use(&quot;/&quot;, require(&quot;./routers/main&quot;));</span><br></pre></td></tr></table></figure><blockquote><p>创建routers/admin.js routers/api.js routers/main.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line">//这里不需要些/admin/user，因为前面已经处理过了</span><br><span class="line">router.get(&quot;/user&quot;, function(req, res, next)&#123;</span><br><span class="line">res.send(&quot;ADMIN - User&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure><blockquote><h3 id="前台路由-模板"><a href="#前台路由-模板" class="headerlink" title="前台路由+模板"></a>前台路由+模板</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/yrwfg0RB5*BrSANs3IltkSPIIe76l7bseNEbdTw4DDY!/b/dFYBAAAAAAAA&bo=BAKIAQAAAAADB60!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="后台路由-模块"><a href="#后台路由-模块" class="headerlink" title="后台路由+模块"></a>后台路由+模块</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/yd3sN3SlMU22RfznIbFMYtreROhe80JUaw8Zx0xj7QU!/b/dFYBAAAAAAAA&bo=BgIEAgAAAAADByA!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="功能开发顺序"><a href="#功能开发顺序" class="headerlink" title="功能开发顺序"></a>功能开发顺序</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/Rh6kslhjswehoKgecSqxrliFSMIG4q9rm*DjmbSuZs8!/b/dF4BAAAAAAAA&bo=EgJeAQAAAAADB20!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="首先我们来看一下如何链接数据库mongoDB"><a href="#首先我们来看一下如何链接数据库mongoDB" class="headerlink" title="首先我们来看一下如何链接数据库mongoDB"></a>首先我们来看一下如何链接数据库mongoDB</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --dbpath=磁盘路径 port=端口号</span><br></pre></td></tr></table></figure><blockquote><h3 id="数据库的使用"><a href="#数据库的使用" class="headerlink" title="数据库的使用"></a>数据库的使用</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/bDrNzQyw4OQ2Xwat*g6CDTXSQcAgDzaFrgLSIH0L4HY!/b/dGcBAAAAAAAA&bo=JgJ0AQAAAAADB3M!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><p>（1）首先在app.js中链接数据库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//加载数据库模块</span><br><span class="line">var mongoose = require(&quot;mongoose&quot;);</span><br><span class="line">//链接数据库</span><br><span class="line">mongoose.connect(&quot;mongodb://127.0.0.1:27017&quot;, function(err)&#123;</span><br><span class="line">if(err)&#123;</span><br><span class="line">console.log(&quot;数据库链接失败：&quot; + err);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">console.log(&quot;数据库链接成功&quot;);</span><br><span class="line">//当我们数据库链接成功以后，监听http请求</span><br><span class="line">app.listen(8081);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>（2）创建schemas/users.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&quot;mongoose&quot;);</span><br><span class="line"></span><br><span class="line">//定义用户的表结构,并对外提供接口</span><br><span class="line">module.exports = new mongoose.Schema(&#123;</span><br><span class="line">//用户名</span><br><span class="line">username: String,</span><br><span class="line">//密码</span><br><span class="line">password: String</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>（3）创建models/User.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&quot;mongoose&quot;);</span><br><span class="line"></span><br><span class="line">var usersSchema = require(&quot;../schemas/users&quot;);</span><br><span class="line"></span><br><span class="line">//完成了一个模型类</span><br><span class="line">module.exports = mongoose.model(&quot;User&quot;, usersSchema);</span><br><span class="line">/*</span><br><span class="line">【注】后期可以通过这个模型类创建对象</span><br><span class="line">直接对表中的数据进行操作。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><blockquote><h3 id="用户注册"><a href="#用户注册" class="headerlink" title="用户注册"></a>用户注册</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/YRE0y3xWBvM4MuKGsuZoc0aAjLYcIhTQP6kXcNCa73o!/b/dFYBAAAAAAAA&bo=jAEOAQAAAAADB6A!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="设置用户主页"><a href="#设置用户主页" class="headerlink" title="设置用户主页"></a>设置用户主页</h3><p>修改routers/main.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line">//这里不需要些/admin/user，因为前面已经处理过了</span><br><span class="line">router.get(&quot;/&quot;, function(req, res, next)&#123;</span><br><span class="line">// res.send(&quot;首页&quot;);</span><br><span class="line">//加载index.html</span><br><span class="line">res.render(&quot;main/index&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure><blockquote><p>拷贝对应的index.html（已经写好了） 页面到views/main/index.html<br>同时拷贝对应的其他文件到public中</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/x3.YvajSctA1zqznjRIefek90Yg7PR.8IIHL4RPwLx8!/b/dFYBAAAAAAAA&bo=8AFkAQAAAAADB7Y!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><p>在public/js/index.js中编写登录注册逻辑</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//设置登录和注册互斥显示</span><br><span class="line">$(function()&#123;</span><br><span class="line">$loginBox = $(&quot;#loginBox&quot;);</span><br><span class="line">$registerBox = $(&quot;#registerBox&quot;);</span><br><span class="line"></span><br><span class="line">//点击马上注册，切换到注册面板</span><br><span class="line">$loginBox.find(&quot;a&quot;).on(&quot;click&quot;, function()&#123;</span><br><span class="line">$registerBox.show();</span><br><span class="line">$loginBox.hide();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//切换到登录面板</span><br><span class="line">$registerBox.find(&quot;a&quot;).on(&quot;click&quot;, function()&#123;</span><br><span class="line">$registerBox.hide();</span><br><span class="line">$loginBox.show();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//注册</span><br><span class="line">$registerBox.find(&quot;button&quot;).on(&quot;click&quot;, function()&#123;</span><br><span class="line">//点击注册按钮，通过ajax提交请求</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">type: &quot;POST&quot;,</span><br><span class="line">url: &quot;/api/user/register&quot;,</span><br><span class="line">data: &#123;</span><br><span class="line">username: $registerBox.find(&quot;[name=username]&quot;).val(),</span><br><span class="line">password: $registerBox.find(&quot;[name=password]&quot;).val(),</span><br><span class="line">repassword: $registerBox.find(&quot;[name=repassword]&quot;).val()</span><br><span class="line">&#125;,</span><br><span class="line">dataType: &quot;json&quot;,</span><br><span class="line">success: function(result)&#123;</span><br><span class="line">console.log(result);</span><br><span class="line">&#125;,</span><br><span class="line">error: function(err)&#123;</span><br><span class="line">console.log(&quot;请求错误：&quot; + err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">//这个部分我们只是完成了前端注册信息的提交</span><br></pre></td></tr></table></figure><blockquote><p>下面我们给后端增加注册的逻辑<br>处理post请求数据需要引入body-parser模块<br>在app.js中设置该模块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var bodyParser = require(&quot;body-parser&quot;); </span><br><span class="line">/*</span><br><span class="line">bodyParser设置</span><br><span class="line">*/</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended: true&#125;));</span><br></pre></td></tr></table></figure><blockquote><p>在 routers/api.js 中实现</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line">//定义统一返回格式</span><br><span class="line">var responseData;</span><br><span class="line"></span><br><span class="line">router.use(function(req, res, next)&#123;</span><br><span class="line">responseData = &#123;</span><br><span class="line">code: 0,    //错误码</span><br><span class="line">message: &quot;&quot; //信息</span><br><span class="line">&#125;</span><br><span class="line">next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//这里不需要些/admin/user，因为前面已经处理过了</span><br><span class="line">//在api.js中增加路由</span><br><span class="line">/*</span><br><span class="line">用户注册</span><br><span class="line">这里我们需要获取到提交的post数据，</span><br><span class="line">这里需要用到模块body-parser,用来处理post提交过来的数据</span><br><span class="line">在app.js中引入该模块</span><br><span class="line">body-parser引入以后，还需要进行一些相关配置，具体百度</span><br><span class="line">设置以后，会自动在req中增加一个属性body</span><br><span class="line">这个属性中有我们post请求提交的数据</span><br><span class="line">*/</span><br><span class="line">router.post(&quot;/user/register&quot;, function(req, res, next)&#123;</span><br><span class="line">// console.log(&quot;register&quot;);</span><br><span class="line">// console.log(req.body);</span><br><span class="line">/*</span><br><span class="line">下面我们编写注册逻辑</span><br><span class="line">1、基本的注册逻辑判断</span><br><span class="line">（1）用户名不能为空</span><br><span class="line">（2）密码不能为空</span><br><span class="line">（3）两次输入的密码必须一致</span><br><span class="line">2、和数据库中的数据进行比对，判断是否被注册了</span><br><span class="line">（1）数据库的查询</span><br><span class="line">【注】在判断过程中，我们需要随时返回判断结果，所以需要设置统一接口</span><br><span class="line">*/</span><br><span class="line">var username = req.body.username;</span><br><span class="line">var password = req.body.password;</span><br><span class="line">var repassword = req.body.repassword;</span><br><span class="line"></span><br><span class="line">//用户名是否为空</span><br><span class="line">if(username == &quot;&quot;)&#123;</span><br><span class="line">responseData.code = 1;</span><br><span class="line">responseData.message = &quot;用户名不能为空&quot;;</span><br><span class="line">//返回前端</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//密码不能为空</span><br><span class="line">if(password == &quot;&quot;)&#123;</span><br><span class="line">responseData.code = 2;</span><br><span class="line">responseData.message = &quot;密码不能为空&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//两次输入的密码不一致，必须一致</span><br><span class="line">if(password != repassword)&#123;</span><br><span class="line">responseData.code = 3</span><br><span class="line">responseData.message = &quot;两次输入的密码不一致&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//注册成功</span><br><span class="line">responseData.message = &quot;注册成功&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure><blockquote><h3 id="添加数据库验证"><a href="#添加数据库验证" class="headerlink" title="添加数据库验证"></a>添加数据库验证</h3><p>routers/api.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   //引入数据模型</span><br><span class="line">   var User = require(&quot;../models/User&quot;);</span><br><span class="line">   //插入到一般判断后面</span><br><span class="line">/*</span><br><span class="line">用户名是否已经被注册了，</span><br><span class="line">如果数据库已经存在和我们要注册的用户名同名的数据</span><br><span class="line">表示用户名已经被注册了</span><br><span class="line">*/</span><br><span class="line">User.findOne(&#123;</span><br><span class="line">username: username</span><br><span class="line">&#125;).then(function(userInfo)&#123;</span><br><span class="line">// console.log(userInfo);</span><br><span class="line">if(userInfo)&#123;</span><br><span class="line">//表示数据库中有该记录</span><br><span class="line">responseData.code = 4;</span><br><span class="line">responseData.message = &quot;用户名已经被注册了&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//保存用户注册的信息到数据库中</span><br><span class="line">var user = new User(&#123;</span><br><span class="line">username: username,</span><br><span class="line">password: password</span><br><span class="line">&#125;);</span><br><span class="line">//保存到数据库</span><br><span class="line">return user.save(); </span><br><span class="line">&#125;).then(function(newUserInfo)&#123;</span><br><span class="line">console.log(newUserInfo);</span><br><span class="line">//注册成功 数据成功存储在了admin数据库中</span><br><span class="line">responseData.message = &quot;注册成功&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>将注册成功的信息显示在页面上(public/js/index.js)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">success: function(result)&#123;</span><br><span class="line">// console.log(result);</span><br><span class="line">$registerBox.find(&quot;.colWarning&quot;).html(result.message);</span><br><span class="line">if(!result.code)&#123;</span><br><span class="line">//注册成功</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">//显示登录页面，隐藏注册页面</span><br><span class="line">$registerBox.hide();</span><br><span class="line">$loginBox.show();</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>同样的原理，编写登录<br>public/js/index.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//登录</span><br><span class="line">$loginBox.find(&quot;button&quot;).on(&quot;click&quot;, function()&#123;</span><br><span class="line">//通过ajax提交请求</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">type: &quot;post&quot;,</span><br><span class="line">url: &quot;api/user/login&quot;,</span><br><span class="line">data: &#123;</span><br><span class="line">username: $loginBox.find(&quot;[name=username]&quot;).val(),</span><br><span class="line">password: $loginBox.find(&quot;[name=password]&quot;).val()</span><br><span class="line">&#125;,</span><br><span class="line">dataType: &quot;json&quot;,</span><br><span class="line">success: function(result)&#123;</span><br><span class="line">//提示信息</span><br><span class="line">$loginBox.find(&quot;.colWarning&quot;).html(result.message);</span><br><span class="line">// console.log(result);</span><br><span class="line">if(!result.code)&#123;</span><br><span class="line">//登录成功</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">//显示登录页面，隐藏注册页面</span><br><span class="line">$loginBox.hide();</span><br><span class="line">$userInfo.show();</span><br><span class="line"></span><br><span class="line">//将用户信息显示在页面上</span><br><span class="line">$userInfo.find(&quot;.username&quot;).html(result.userInfo.username);</span><br><span class="line">$userInfo.find(&quot;.info&quot;).html(&quot;你好，欢迎光临我的博客！😁&quot;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在routers/api.js中新增登录的路由</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//新增登录的路由</span><br><span class="line">/*</span><br><span class="line">登录</span><br><span class="line">*/</span><br><span class="line">router.post(&quot;/user/login&quot;, function(req, res, next)&#123;</span><br><span class="line">var username = req.body.username;</span><br><span class="line">var password = req.body.password;</span><br><span class="line"></span><br><span class="line">if(username == &quot;&quot; || password == &quot;&quot;)&#123;</span><br><span class="line">responseData.code = 1;</span><br><span class="line">responseData.message = &quot;用户名和密码不能为空&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查询数据库中相同用户名和密码的记录是否存在，如果存在则登录成功</span><br><span class="line">User.findOne(&#123;</span><br><span class="line">username: username,</span><br><span class="line">password: password</span><br><span class="line">&#125;).then(function(userInfo)&#123;</span><br><span class="line">if(!userInfo)&#123;</span><br><span class="line">responseData.code = 2;</span><br><span class="line">responseData.message = &quot;用户名或密码错误&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用户名和密码正确</span><br><span class="line">responseData.message = &quot;登录成功&quot;;</span><br><span class="line">//将登录信息返回前端页面</span><br><span class="line">responseData.userInfo = &#123;</span><br><span class="line">_id: userInfo._id,</span><br><span class="line">username: userInfo.username</span><br><span class="line">&#125;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学前需求&quot;&gt;&lt;a href=&quot;#学前需求&quot; class=&quot;headerlink&quot; title=&quot;学前需求&quot;&gt;&lt;/a&gt;学前需求&lt;/h2&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;一、node安装和运行&quot;&gt;&lt;a href=&quot;#一、node安装和运行&quot; class=&quot;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>express的路由</title>
    <link href="https://tianjiec.top/2018/12/20/express%E7%9A%84%E8%B7%AF%E7%94%B1/"/>
    <id>https://tianjiec.top/2018/12/20/express的路由/</id>
    <published>2018-12-20T02:42:13.000Z</published>
    <updated>2018-12-20T03:07:29.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="express路由与应用模式"><a href="#express路由与应用模式" class="headerlink" title="express路由与应用模式"></a>express路由与应用模式</h1><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><blockquote><p>Express是一个基于Node.js的轻量级web开发框架，具有体积小，使用灵活等特点。查看Express的源码，如果不计供使用的中间件，主体框架只有一千余行代码，非常简练。</p><p>Express模型的核心为Express中定义的路由和路由器。分析Express源码可发现Express的路由提供多种灵活的应用模式。</p><p>我们首先介绍一下Express中的路由、路由器相关概念、结构及其特点，然后针对典型场景描述使用Express路由的四种应用模式。</p></blockquote><h3 id="2-Express中的路由与路由器"><a href="#2-Express中的路由与路由器" class="headerlink" title="2.Express中的路由与路由器"></a>2.Express中的路由与路由器</h3><p>Express具有典型的MVC模型特征。我们将路由定义为一个二元组route=(path, endpoint)：其中path为HTTP请求的路径，endpoint为请求路径应映射到的端点（端点可视为处理该请求的实体）,则Express中的路由器负责将请求映射到对应端点进行处理。</p><p>Express中的路由器分为两种类型:</p><p>app类型的路由器常使用如下代码创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br></pre></td></tr></table></figure><p>router类型的路由器常使用如下代码创建:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br></pre></td></tr></table></figure><blockquote><p>app和router是形为function(request, response, next)形式的函数对象，使用app.verb()，router.verb()形式函数实现路由注册（路由注册本质上是一个观察者模式）。</p><p>app.verb()和router.verb()中的verb常使用use、get、post、put、delete、route等动词，不同动词管辖的HTTP请求方法范围不同，这些动词函数的参数形式常为(pathExp, handleCallback)形式：其中pathExp表示请求路径，可为正则表达式；handleCallback为路径映射处理函数。</p></blockquote><p>app是Express框架所构建程序的请求处理入口，app可作为顶层路由器使用，在应用中也可挂载下级路由器（使用router对象）以实现分级路由。其间的关系可由下图表示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://s1.51cto.com/images/20180716/1531726860898789.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="express对象关系图.jpg" title="">                </div>                <div class="image-caption">express对象关系图.jpg</div>            </figure><p><strong>考察如下代码：</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/reports'</span>, router1);</span><br><span class="line">router1.get(<span class="string">'/querymysql/:id'</span>, queryMysqlData, handleQueryData);</span><br></pre></td></tr></table></figure><blockquote><p>对于http请求URL“/reports/querymysql/1”，Express中的路由器将此请求路由到queryMysqlData函数处理。</p></blockquote><h3 id="3、Express中的路由应用模式"><a href="#3、Express中的路由应用模式" class="headerlink" title="3、Express中的路由应用模式"></a>3、Express中的路由应用模式</h3><h3 id="3-1-REST模式"><a href="#3-1-REST模式" class="headerlink" title="3.1.   REST模式"></a>3.1.   REST模式</h3><p>对于一个使用restful风格的应用, 让我们想一想在不使用Express的时候如何在Node.js中处理rest请求，我们常常会写下如下示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">switch</span> (request.url) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'uri1'</span></span><br><span class="line">                        handleUri1 (request, response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' uri2'</span></span><br><span class="line">                        handleU ri2(request, response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' uri3'</span></span><br><span class="line">                        handleU ri3 (request, response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' uri4'</span></span><br><span class="line">                        handleU ri4 (request, response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        logToConsole(<span class="string">'unknown path:'</span> + path);</span><br><span class="line">                        response.writeHead(<span class="number">404</span>);</span><br><span class="line">                        response.end(<span class="string">"404 Not found"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Express将上面代码中对每个rest资源的操作(switch分支)转换为路由，路由中的路径为rest资源的URI，处理端点为function(request, response, next)形式、对rest资源的操作函数。</p><p>常使用app.route函数实现一个完整的restful接口，如下示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.route(<span class="string">'/uri1'</span>)</span><br><span class="line">  .get(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    handleGetUri1();</span><br><span class="line">  &#125;)</span><br><span class="line">  .post(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    handlePost Uri1 ();</span><br><span class="line">  &#125;)</span><br><span class="line">  .put(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    handlePut Uri <span class="number">1</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">.delete(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    handleDeleteUri <span class="number">1</span>();</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="3-2-AOP模式"><a href="#3-2-AOP模式" class="headerlink" title="3.2.   AOP模式"></a>3.2.   AOP模式</h3><p>在处理不同路径的HTTP请求时，常常需要在请求处理前和处理后做一些通用操作，这种应用需求是一个典型的AOP应用要求。</p><p>Express中允许定义一个具有通配路径的路由，在调用其它路径的路由前会先调用该通配路径路由。此通配路径路由也成为其它路径路由切面的一个注入点，考察如下示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.use(<span class="function"><span class="keyword">function</span> <span class="title">timelog</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"receive report request time is:"</span>,<span class="built_in">Date</span>.now());</span><br><span class="line">    next(); <span class="comment">//注意next函数的使用，必须声明该函数才能调用后继映射函数</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">router.get(<span class="string">'/chart1'</span>, proxy(&#123;</span><br><span class="line">    target: <span class="string">'http://127.0.0.1:8082'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">        <span class="string">'^/reports/chart1'</span>: <span class="string">'/loadChart1'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br><span class="line"> </span><br><span class="line">router.get(<span class="string">'/querymysql/:id'</span>, queryMysqlData, handleQueryData);</span><br></pre></td></tr></table></figure><p>上述代码中，在执行router的’/chart1’路由和’/querymysql/:id’路由之前都会执行timelog函数，在日志中记录当前路由执行时间。</p><h3 id="3-3-责任链模式"><a href="#3-3-责任链模式" class="headerlink" title="3.3.   责任链模式"></a>3.3.   责任链模式</h3><p>在Node.js中，由于多使用异步函数，常会出现异步回调函数中嵌套异步回调函数的情形。当出现多重异步回调时,则代码会变得混乱和难以维护。</p><p>考察一个应用场景：应用需要在数据库中进行多次查询，并对多次查询的结果综合处理。若使用数据库提供的异步查询接口，则需要在前一个查询操作的回调函数中进行下一个查询操作，若写在一个回调函数中，代码显臃肿。</p><p>Express的一个路由可定义多个处理函数，这些处理函数可设计为链式调用，实现了责任链模式，考察如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/test'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    handle1();</span><br><span class="line">    next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    handle2();</span><br><span class="line">    next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">   handle3();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述代码中：handle1, handle2, handle3构成了一个处理责任链“handle1-&gt;handle2-&gt;handle3”，通过next函数指引链式调用。</p><p>Express中路由的责任链应用特性使得多重异步嵌套的代码变得清晰和优雅。</p><p>​    针对本节开始提到的数据库查询应用场景，下面的示例代码展示了责任链模式的应用特点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/querymysql/:id'</span>, queryMysqlData, handleQueryData);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//查询mysql表中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryMysqlData</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"id"</span> <span class="keyword">in</span> req.params) &#123;</span><br><span class="line">        dbpool.query(<span class="string">" select * from articles where id=?"</span> ,[req.params.id], <span class="function"><span class="keyword">function</span> (<span class="params">err, rows, fields</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                res.send(err.stack);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rows &amp;&amp; rows.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'The queried rows is: '</span>, rows.length);</span><br><span class="line">                    res.articles = rows;</span><br><span class="line">                    next();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.send(<span class="string">"no query results!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.send(<span class="string">"invalid query params!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//处理查询mysql后得到的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleQueryData</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"articles"</span> <span class="keyword">in</span> res) &#123;</span><br><span class="line">        res.send(<span class="string">"id:"</span> + req.params.id + <span class="string">";title:"</span> + res.articles[<span class="number">0</span>].title);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.send(<span class="string">"no query data handled!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-熔断器模式"><a href="#3-4-熔断器模式" class="headerlink" title="3.4.   熔断器模式"></a>3.4.   熔断器模式</h3><p>上节提到的责任链模式本质上是一个逐级调用模型。在分布式服务架构（微服务架构）中，深度调用常常需要考虑调用可达性问题，即需要考虑某级调用会否一直不响应。调用可达性问题常使用熔断器模式，即在调用端设置一个熔断器，熔断条件产生时，熔断器发生熔断，返回给调用方调用失败信息。</p><p>考虑这样的应用场景：对于一些有处理时间要求的请求，当在指定时间内没有完成处理，需要向请求方返回处理失败信息。针对此应用场景，可在Express路由中设置超时熔断器，当处理超时，开启熔断器，通知请求方本次处理请求失败。</p><p>上述应用场景可使用如下示例代码应对：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/circuit'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bt=setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        next(<span class="string">'route'</span>); <span class="comment">//触发熔断</span></span><br><span class="line">    &#125;,<span class="number">3000</span>); <span class="comment">//设置熔断时间为3秒</span></span><br><span class="line">   res.breakTimer = bt;</span><br><span class="line">   next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    handle2();</span><br><span class="line">    next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">   handle3();</span><br><span class="line">   clearTimeout(res.breakTimer);<span class="comment">//正常执行完毕，取消熔断定时器</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/circuit '</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!res.finished)&#123; <span class="comment">//如果还没有响应，启动熔断</span></span><br><span class="line">    <span class="comment">//返回给调用者熔断信息</span></span><br><span class="line">    res.send(<span class="string">"breakCondition is true, notify the invoker."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="路径和句柄"><a href="#路径和句柄" class="headerlink" title="路径和句柄"></a>路径和句柄</h2><h3 id="理解了路径和句柄，才算真的会了Express路由的使用"><a href="#理解了路径和句柄，才算真的会了Express路由的使用" class="headerlink" title="理解了路径和句柄，才算真的会了Express路由的使用"></a>理解了路径和句柄，才算真的会了Express路由的使用</h3><p>路由：就是如何处理HTTP请求中的路径部分。</p><p>每个路径都会有对应的函数来处理（这个函数叫句柄），下面一个一个来说。</p><h4 id="一、有关路径"><a href="#一、有关路径" class="headerlink" title="一、有关路径"></a>一、有关路径</h4><p>路径可以是一个String类型也可以是一个正则表达式，例子：</p><p>1、当路径是String：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1053068413,3123129933&fm=173&s=AC9825D24BFEB6CA40BCCD030100E0C2&w=515&h=278&img.JPEG" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>如上图所示配置路由，页面分别访问：</p><p><a href="http://localhost:1234/abcd" target="_blank" rel="noopener">http://localhost:1234/abcd</a></p><p>输出：This is list</p><p><a href="http://localhost:1234/list/news/" target="_blank" rel="noopener">http://localhost:1234/list/news/</a></p><p>输出：This is news</p><p><a href="http://localhost:1234/list/news/123" target="_blank" rel="noopener">http://localhost:1234/list/news/123</a></p><p>输出：This is list news:123</p><p>2、当路径是正则表达式：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=1685331371,3718706668&fm=173&s=AC9835D3C9C8B4415AE5C50F0100E0C2&w=509&h=158&img.JPEG" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>第一个路由匹配的是/mobile/1[十个数字]，页面访问：</p><p><a href="http://localhost:1234/mobile/1XXXXXXXXXX" target="_blank" rel="noopener">http://localhost:1234/mobile/1XXXXXXXXXX</a></p><p>输出：This is a mobile phone ……</p><p>第二个路由匹配的是/abcd或者/acd。</p><h4 id="二、有关句柄"><a href="#二、有关句柄" class="headerlink" title="二、有关句柄"></a>二、有关句柄</h4><p>有关句柄，说两个问题</p><p>1、next和next（’route’）区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request,response,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req, res ,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    next(<span class="string">'route'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res ,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    next()</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req, res ,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    next(<span class="string">'route'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上图所示，有三个地方加了next，实例测试发现：</p><p>当位置1是next()时，结果输出：1234</p><p>当位置1是next(‘router’)时，结果输出：134</p><h5 id="由此可见，二者的区别就是：next从下一个处理函数开始往下执行，next-‘router’-，直接执行下一个相同路由。"><a href="#由此可见，二者的区别就是：next从下一个处理函数开始往下执行，next-‘router’-，直接执行下一个相同路由。" class="headerlink" title="由此可见，二者的区别就是：next从下一个处理函数开始往下执行，next(‘router’)，直接执行下一个相同路由。"></a>由此可见，二者的区别就是：next从下一个处理函数开始往下执行，next(‘router’)，直接执行下一个相同路由。</h5><p>2】param</p><p>param在路由中也相当于是一个中间件作用。例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.param(<span class="string">"listname"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next, listname</span>)</span>&#123;</span><br><span class="line">    req.list = [<span class="string">'item0'</span>, <span class="string">'item1'</span>, <span class="string">'item2'</span>];</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">'/list/:listname'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'list:\n'</span> + req.list.join(<span class="string">''</span>));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面这个路由输出：list:item0item1item2</p><p>app.param会在路由前执行，需要注意的是listname参数一定要对应。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;express路由与应用模式&quot;&gt;&lt;a href=&quot;#express路由与应用模式&quot; class=&quot;headerlink&quot; title=&quot;express路由与应用模式&quot;&gt;&lt;/a&gt;express路由与应用模式&lt;/h1&gt;&lt;h3 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mongoose</title>
    <link href="https://tianjiec.top/2018/12/20/mongoose/"/>
    <id>https://tianjiec.top/2018/12/20/mongoose/</id>
    <published>2018-12-20T02:18:28.000Z</published>
    <updated>2018-12-20T02:23:42.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>　　Mongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具</p><p>　　那么要使用它，首先你得装上node.js和mongodb,关于mongodb的安装和操作介绍可以参考：<a href="http://www.cnblogs.com/zhongweiv/p/node_mongodb.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhongweiv/p/node_mongodb.html</a></p><p>　　Github地址：<a href="https://github.com/Automattic/mongoose" target="_blank" rel="noopener">https://github.com/Automattic/mongoose</a></p><p>　　API Docs：<a href="http://mongoosejs.com/docs/guide.html" target="_blank" rel="noopener">http://mongoosejs.com/docs/guide.html</a></p><p>　　前面有介绍过用node-mongodb-native来操作mongodb，实际开发中估计更多会选用类似mongoose的模块来操作来提升开发效率</p><p>　　下面我们一步步来了解mongoose的基本操作^_^!</p><h1 id="mongoose安装"><a href="#mongoose安装" class="headerlink" title="mongoose安装"></a>mongoose安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mongoose</span><br></pre></td></tr></table></figure><p>　　安装成功后如下图：</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images.cnblogs.com/cnblogs_com/zhongweiv/804376/o_1.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure></blockquote><p>　　安装成功后，就可以通过 require(‘mongoose’) 来使用！</p><h1 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h1><p>　　创建一个db.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line">DB_URL = <span class="string">'mongodb://localhost:27017/mongoosedemo'</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mongoose.connect(DB_URL);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;　　Mongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具&lt;/p&gt;
&lt;p&gt;　　那么要使用它，首先你得装上no
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>框架初探-blog项目</title>
    <link href="https://tianjiec.top/2018/12/19/%E6%A1%86%E6%9E%B6%E5%88%9D%E6%8E%A2-blog%E9%A1%B9%E7%9B%AE/"/>
    <id>https://tianjiec.top/2018/12/19/框架初探-blog项目/</id>
    <published>2018-12-19T11:51:16.000Z</published>
    <updated>2018-12-19T11:51:16.179Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6 Promise用法</title>
    <link href="https://tianjiec.top/2018/12/19/ES6-Promise%E7%94%A8%E6%B3%95/"/>
    <id>https://tianjiec.top/2018/12/19/ES6-Promise用法/</id>
    <published>2018-12-19T11:33:07.000Z</published>
    <updated>2018-12-19T11:46:28.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-Promise-用法讲解"><a href="#ES6-Promise-用法讲解" class="headerlink" title="ES6 Promise 用法讲解"></a><a href="https://www.cnblogs.com/whybxy/p/7645578.html" target="_blank" rel="noopener">ES6 Promise 用法讲解</a></h1><blockquote><p>Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。</p></blockquote><p>那就new一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//异步操作</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"执行完成"</span>);</span><br><span class="line">        resolve(<span class="string">"data"</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。</p><p>在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并且调用resolve方法。</p><p>运行代码，会在2秒后输出“执行完成”。注意！我只是new了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'执行完成'</span>);</span><br><span class="line">            resolve(<span class="string">'随便什么数据'</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line">runAsync()</span><br></pre></td></tr></table></figure><p>这时候你应该有两个疑问：1.包装这么一个函数有毛线用？2.resolve(‘随便什么数据’);这是干毛的？</p><p>我们继续来讲。在我们包装好的函数最后，会return出Promise对象，也就是说，执行这个函数我们得到了一个Promise对象。还记得Promise对象上有then、catch方法吧？这就是强大之处了，看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">runAsync().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="comment">//后面可以用传过来的数据做些其他操作</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“随便什么数据”。</p><p>这时候你应该有所领悟了，原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。</p><p>你可能会不屑一顾，那么牛逼轰轰的Promise就这点能耐？我把回调函数封装一下，给runAsync传进去不也一样吗，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'执行完成'</span>);</span><br><span class="line">        callback(<span class="string">'随便什么数据'</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runAsync(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>效果也是一样的，还费劲用Promise干嘛。那么问题来了，有多层回调该怎么办？如果callback也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个callback2，然后给callback传进去吧。而Promise的优势在于，可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。</p><p> <strong>链式操作的用法</strong></p><p>所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">runAsync1()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> runAsync2();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> runAsync3();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样能够按顺序，每隔两秒输出每个异步回调中的内容，在runAsync2中传给resolve的数据，能在接下来的then方法中拿到。运行结果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004311507-221152206.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h2 id="reject的用法"><a href="#reject的用法" class="headerlink" title="reject的用法"></a><strong>reject的用法</strong></h2><p>到这里，你应该对“Promise是什么玩意”有了最基本的了解。那么我们接着来看看ES6的Promise还有哪些功能。我们光用了resolve，还没用reject呢，它是做什么的呢？事实上，我们前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function getNumber()&#123;</span><br><span class="line">    var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">        //做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            var num = Math.ceil(Math.random()*10); //生成1-10的随机数</span><br><span class="line">            if(num&lt;=5)&#123;</span><br><span class="line">                resolve(num);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                reject(&apos;数字太大了&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getNumber()</span><br><span class="line">.then(</span><br><span class="line">    function(data)&#123;</span><br><span class="line">        console.log(&apos;resolved&apos;);</span><br><span class="line">        console.log(data);</span><br><span class="line">    &#125;, </span><br><span class="line">    function(reason, data)&#123;</span><br><span class="line">        console.log(&apos;rejected&apos;);</span><br><span class="line">        console.log(reason);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。</p><p>运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004616257-1024778840.png" alt="img](https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004607960-1156803894.png)或者![img" title="">                </div>                <div class="image-caption">img](https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004607960-1156803894.png)或者![img</div>            </figure><h2 id="catch的用法"><a href="#catch的用法" class="headerlink" title="catch的用法"></a><strong>catch的用法</strong></h2><p>我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调，用法是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getNumber()</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(&apos;resolved&apos;);</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(&apos;rejected&apos;);</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getNumber()</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(&apos;resolved&apos;);</span><br><span class="line">    console.log(data);</span><br><span class="line">    console.log(somedata); //此处的somedata未定义</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(&apos;rejected&apos;);</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004747147-1508291069.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能。</p><h2 id="all的用法"><a href="#all的用法" class="headerlink" title="all的用法"></a><strong>all的用法</strong></h2><p>Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。我们仍旧使用上面定义好的runAsync1、runAsync2、runAsync3这三个函数，看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br><span class="line">.all([runAsync1(), runAsync2(), runAsync3()])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>用Promise.all来执行，all接收一个数组参数，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。所以上面代码的输出结果就是：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004843491-346782307.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</p><h2 id="race的用法"><a href="#race的用法" class="headerlink" title="race的用法"></a><strong>race的用法</strong></h2><p>all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思。race的用法与all一样，我们把上面runAsync1的延时改为1秒来看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br><span class="line">.race([runAsync1(), runAsync2(), runAsync3()])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这三个异步操作同样是并行执行的。结果你应该可以猜到，1秒后runAsync1已经执行完了，此时then里面的就执行了。结果是这样的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004946022-706413123.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>你猜对了吗？不完全，是吧。在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧再执行。于是再过1秒后，输出了他们结束的标志。</p><p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//请求某个图片资源</span><br><span class="line">function requestImg()&#123;</span><br><span class="line">    var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">        var img = new Image();</span><br><span class="line">        img.onload = function()&#123;</span><br><span class="line">            resolve(img);</span><br><span class="line">        &#125;</span><br><span class="line">        img.src = &apos;xxxxxx&apos;;</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//延时函数，用于给请求计时</span><br><span class="line">function timeout()&#123;</span><br><span class="line">    var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            reject(&apos;图片请求超时&apos;);</span><br><span class="line">        &#125;, 5000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise</span><br><span class="line">.race([requestImg(), timeout()])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>requestImg函数会异步请求一张图片，我把地址写为”xxxxxx”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。运行结果如下：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6-Promise-用法讲解&quot;&gt;&lt;a href=&quot;#ES6-Promise-用法讲解&quot; class=&quot;headerlink&quot; title=&quot;ES6 Promise 用法讲解&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/whybx
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面包屑导航</title>
    <link href="https://tianjiec.top/2018/12/19/%E9%9D%A2%E5%8C%85%E5%B1%91%E5%AF%BC%E8%88%AA/"/>
    <id>https://tianjiec.top/2018/12/19/面包屑导航/</id>
    <published>2018-12-19T11:27:56.000Z</published>
    <updated>2018-12-19T11:32:35.426Z</updated>
    
    <content type="html"><![CDATA[<p>面包屑<a href="https://baike.baidu.com/item/%E5%AF%BC%E8%88%AA" target="_blank" rel="noopener">导航</a>(BreadcrumbNavigation)这个概念来自童话故事”<a href="https://baike.baidu.com/item/%E6%B1%89%E8%B5%9B%E5%B0%94" target="_blank" rel="noopener">汉赛尔</a>和<a href="https://baike.baidu.com/item/%E6%A0%BC%E8%8E%B1%E7%89%B9" target="_blank" rel="noopener">格莱特</a>“，当汉赛尔和格莱特穿过森林时，不小心迷路了，但是他们发现在沿途走过的地方都撒下了面包屑，让这些面包屑来帮助他们找到回家的路。所以，面包屑导航的作用是告诉<a href="https://baike.baidu.com/item/%E8%AE%BF%E9%97%AE%E8%80%85/2774711" target="_blank" rel="noopener">访问者</a>他们目前在网站中的位置以及如何返回。</p><p>主页 &gt;栏目页&gt;文章页面</p><p>小型站点便于优化，可以把主页改成你的关键词，目的是关键词集权于首页。</p><p>关键词&gt;<a href="https://baike.baidu.com/item/%E6%A0%8F%E7%9B%AE%E9%A1%B5" target="_blank" rel="noopener">栏目页</a>&gt;文章页非常清晰，且不存在交叉；否则，面包屑导航的路径</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>1、让用户了解当前所处位置，以及当前页面在整个网站中的位置。</p><p>2、体现了网站的架构层级，能够帮助用户快速学习和了解网站内容和组织方式，从而形成很好的位置感。</p><p>3、提供返回各个层级的快速入口，方便用户操作。</p><p>4、<a href="https://baike.baidu.com/item/Google" target="_blank" rel="noopener">Google</a>已经将面包屑导航整合到搜索结果里面，因此优化面包屑导航每个层级的名称，多使用关键字，都可以实现SEO优化。面包屑路径，对于提高用户体验来说，是很有帮助的。</p><p>5、方便用户，面包屑主要用于为用户提供导航一个网站的次要方法，通过为一个大型多级网站的所有页面提供面包屑路径，用户可以更容易的定位到上一次目录，引导用户通行；</p><p>6、减少返回到上一级页面的点击或操作，不用使用浏览器的“返回”按钮或网站的主要导航来返回到上一级页面；</p><p>7、不用常常占用屏幕空间，因为它们通常是水平排列以及简单的样式，面包屑路径不会占用页面太多的空间。这样的好处是，从内容过载方面来说，他们几乎没有任何负面影响；</p><p>8、降低<a href="https://baike.baidu.com/item/%E8%B7%B3%E5%87%BA%E7%8E%87" target="_blank" rel="noopener">跳出率</a>，面包屑路径会是一个诱惑首次访问者在进入一个页面后去浏览这个网站的非常好的方法。比如说，一个用户通过谷歌搜索到一个页面，然后看到一个面包屑路径，这将会诱使用户点击上一级页面去浏览感兴趣的相关主题。这样，从而，可以降低网站的总体跳出率。</p><p>9、有利于百度蜘蛛对网站的抓取，蜘蛛直接沿着那个链走就可以了，很方便。</p><p>10、面包屑有利于网站<a href="https://baike.baidu.com/item/%E5%86%85%E9%93%BE" target="_blank" rel="noopener">内链</a>的建设，用面包屑大大增加了网站的内部连接，提高用户体验。</p><h3 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h3><p>虽然眼下很多网站都流行使用面包屑导航，但是并不是所有的网站都适用。符合下面两个条件的网站才适合使用面包屑导航。1、层级较深的网站，面包屑导航适合层级较深的网站，如果只有一级分类的话，通过主导航就可以起到快速定位的作用。比如“<a href="https://baike.baidu.com/item/%E8%B1%86%E7%93%A3%E7%BD%91" target="_blank" rel="noopener">豆瓣网</a>”类型扁平构架的网站就没有使用面包屑导航。2、独立不交叉的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%AB%99%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">网站结构</a>，由于面包屑网站导航路径是线性结构的，因此网站内容必须划分的非常清晰，且不存在交叉；否则，面包屑导航的路径就不是唯一的，同一分类可能出现在不同的路径中，让用户感到困惑。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>编辑</p><p>一、基于位置的面包屑导航</p><p>这种类型是最常见的。这种类型的面包屑导航可以很好的指出当前页面与整个站点的层次结构。这种面包屑导航可以显示当前页面的前一个页面或者目录的<a href="https://baike.baidu.com/item/%E9%93%BE%E6%8E%A5" target="_blank" rel="noopener">链接</a>。可以使访客了解自己的位置，以及可以更快的找到自己想要到达的页面。可以很好的提高用户的友好体验。</p><p>二、基于属性的面包屑导航</p><p>这种面包屑导航最常出现在电子商务站点。这种面包屑导航可以很好的指出当前页面内产品的其他属性或者类别。对于一个产品来说，所具有的属性往往不只有一种，而通过这种面包屑导航可以给消费者一个更加直观的了解。</p><p>三、基于路径的面包屑导航</p><p>这种面包屑导航是最不常见到的。这种面包屑导航和上文所说的童话故事类型很像。他们可以显示访客在到达页面前所访问过的<a href="https://baike.baidu.com/item/%E7%BD%91%E9%A1%B5" target="_blank" rel="noopener">网页</a>的链接。这种面包屑导航不是很受欢迎，因为他们的功能基本上是和前进和后退的按钮是一样的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面包屑&lt;a href=&quot;https://baike.baidu.com/item/%E5%AF%BC%E8%88%AA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;导航&lt;/a&gt;(BreadcrumbNavigation)这个概念来自童话故事”&lt;a hre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="https://tianjiec.top/2018/12/18/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://tianjiec.top/2018/12/18/面试题/</id>
    <published>2018-12-18T01:21:11.000Z</published>
    <updated>2018-12-21T01:51:13.222Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？"><a href="#1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？" class="headerlink" title="1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？"></a>1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？</h4><p>IE：trident内核</p><p>Firefox：gecko内核</p><p>Safari：webkit内核</p><p>Opera：以前是presto内核，现在改用Google的Chrome的blink内核</p><p>Chrome：blink（基于webkit，Google与Opera共同开发）</p><h4 id="2、每个HTML文件里开头都有一个很重要的东西，Doctype，知道这是干什么的吗？"><a href="#2、每个HTML文件里开头都有一个很重要的东西，Doctype，知道这是干什么的吗？" class="headerlink" title="2、每个HTML文件里开头都有一个很重要的东西，Doctype，知道这是干什么的吗？"></a>2、每个HTML文件里开头都有一个很重要的东西，Doctype，知道这是干什么的吗？</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE&gt;</span> 声明于文档中的最前面的位置，处于<span class="tag">&lt;<span class="name">html</span>&gt;</span> 标签之前。此标签可告知浏览器文档使用哪种HTML 或 XHTML 规范。（重点：告诉浏览器按照何种规范解析页面）</span><br></pre></td></tr></table></figure><h4 id="3、Quirks-模式-是什么？-他和Standards模式有什么区别"><a href="#3、Quirks-模式-是什么？-他和Standards模式有什么区别" class="headerlink" title="3、Quirks 模式 是什么？ 他和Standards模式有什么区别"></a>3、Quirks 模式 是什么？ 他和Standards模式有什么区别</h4><p>从IE6开始，引入了Standards模式， 标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。</p><p>在IE6之前 CSS 还不够成熟， 所以 IE5 等之前的浏览器 对 CSS 的支持很差， IE6将对CSS提供更好的支持，然而这时的问题来了，因为有很多页面是基于旧的布局方式写的，而如果IE6支持CSS则将令这些页面显示不正常，如果在既保证不破坏现有页面，有提供新的渲染机制呢？</p><p>在写程序的时候我们也会经常遇到这样的问题，如何保证原来的接口不变，有提供更强大的功能，尤其是新功能不兼容旧功能的时候。 遇到这样的问题是一个常见的做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数不为真时，就是使用旧功能，这样就能不破坏原有程序，又提供新功能。IE刘也是类似这样做的，它将DTD当成了这个参数，就意味着这个页面都将采用CSS支持更好的布局，而如果没有，则将采用兼容之前的布局方式。 这就是Quirks模式（怪癖模式，诡异模式， 怪异模式）。</p><p>区别：</p><p>总体会有布局、 样式解析和脚本执行这三方面的区别。</p><p>盒模型：</p><p>在W3C标准中，如果设置了一个元素的宽和高，指的是元素内容的宽度和高度，而在Quirks模式下。IE的宽度和高度还包含了padding和border。</p><p>设置行内元素的高度：</p><p>在Standards 模式下，给<span>等行内元素设置width和height都不会生效，而在quirks模式下，则会生效。</span></p><p>设置百分比的高度：在standards模式下， 一个元素的高度石油其包含的元素内容来决定的，如果父元素没有设置百分比高度，子元素设置一个百分比高度是无效的。</p><p>margin：0 auto设置水平居中：使用margin:0 auto 在standards模式下 可以使元素水平居中，但在quirks 模式下会失效</p><p>（还有很多，答出什么不重要，关键是看他答出的这些是不是自己经验遇到的，还是说都是看文章看的，甚至完全不知道。）</p><h4 id="4、div-css布局较table布局有什么优点？"><a href="#4、div-css布局较table布局有什么优点？" class="headerlink" title="4、div+css布局较table布局有什么优点？"></a>4、div+css布局较table布局有什么优点？</h4><p>改版的时候更方便  是要改css文件。</p><p>页面加载的速度更快、结构化清晰、页面显示简洁。</p><p>表现与结构相分离；</p><p>易于优化（seo）搜索引擎更友好，排名更靠前。</p><h4 id="5、img的alt-与-title-有何异同？-strong-与-em-的异同？"><a href="#5、img的alt-与-title-有何异同？-strong-与-em-的异同？" class="headerlink" title="5、img的alt 与 title 有何异同？ strong 与 em 的异同？"></a>5、img的alt 与 title 有何异同？ strong 与 em 的异同？</h4><p>a: alt（alt text）： 为了能显示图像、窗体或applets的用户代理（UA），alt属性用来指定替换的文字。</p><p>替换文字的语言用lang属性来决定。（在IE浏览器下会在没有title时把 alt 当成 tool tip 显示）</p><p>title（tool tip）：该属性为设置该属性的元素提供建议性的信息。</p><p>strong：粗体强调标签，强调，表示内容的重要性；</p><p>em：斜体强调标签，更强烈强调，表示内容强调点；</p><h4 id="6、你能描述一下渐进增强和优雅降级之间的不同吗？"><a href="#6、你能描述一下渐进增强和优雅降级之间的不同吗？" class="headerlink" title="6、你能描述一下渐进增强和优雅降级之间的不同吗？"></a>6、你能描述一下渐进增强和优雅降级之间的不同吗？</h4><p><strong>渐进增强</strong>： progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后在针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p><p><strong>优雅降级</strong>：graceful degradation ： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</p><p><strong>区别：</strong>优雅降级是从复杂的现状开始的，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</p><p><strong>优雅降级</strong>观点</p><p>优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为过时 或有功能缺失的浏览器下的测试安排在开发周期的最后阶段，并把测试对象限定为主流浏览器 （如IE、Mozilla等）的前一个版本。</p><p>在这种设计规范下，旧版本的浏览器被认为仅能提供“简陋却无妨（poor ，but passable）”的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于他们并非我们所关注的焦点，因此除了修复较大的错误之外，其他的差异将被直接忽略。</p><p><strong>渐进增强</strong>观点</p><p>渐进增强观点则认为应关注内容本身。</p><p>内容使我们创建网站的诱因。有的网站展示它，有的网站收集他，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p><p>那么问题来了。现在产品经理看到IE6,7,8网页效果相对高版本现代浏览器少了很多圆角，阴影（CSS3），要求兼容（使用图片背景，放弃CSS3），你会如何说服他？</p><h4 id="7、为什么利用多个域名来存储网站资源会更有效？"><a href="#7、为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="7、为什么利用多个域名来存储网站资源会更有效？"></a>7、为什么利用多个域名来存储网站资源会更有效？</h4><p>CDN缓存更方便</p><p>突破浏览器并发限制</p><p>节约cookie带宽</p><p>节约主域名的连接数，优化页面响应速度</p><p>防止不必要的安全问题</p><h4 id="8、请谈一下你对网页标准和标准定义机构重要性的理解。"><a href="#8、请谈一下你对网页标准和标准定义机构重要性的理解。" class="headerlink" title="8、请谈一下你对网页标准和标准定义机构重要性的理解。"></a>8、请谈一下你对网页标准和标准定义机构重要性的理解。</h4><p>网页标准和标准定制机构都是为了让web发展的更健康，开发者遵循统一的标准，降低开发难度，开发成本，SEO也会更好做，也不会因为滥用代码而导致各种BUG、安全问题，最终提高网站的易用性。</p><h4 id="9、请你描述一下cookies，sessionStorage和localStorage的-区别"><a href="#9、请你描述一下cookies，sessionStorage和localStorage的-区别" class="headerlink" title="9、请你描述一下cookies，sessionStorage和localStorage的    区别"></a>9、请你描述一下cookies，sessionStorage和localStorage的    区别</h4><p>sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动去删除数据，否则数据是永远不会过期的。</p><p>web storage 和 cookie 的区别</p><p>web storage 的概念和 cookie 相似，区别是它是为了更大容量存储设计的。cookie的大小是受限制的，而且没刺激你请求一个新的页面的时候cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可跨域调用。</p><p>除此之外，webstorage拥有setitem，getitem，removeitem，clear等方法， 不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在， 而Web Storage仅仅是为了本地存储数据而生的。</p><h4 id="10、简述下src和href的区别"><a href="#10、简述下src和href的区别" class="headerlink" title="10、简述下src和href的区别"></a>10、简述下src和href的区别</h4><p>src用于替换当前元素，href用于在当前文档引用资源之间确认联系。</p><p>src是 source 的缩写， 指向外部资源的位置， 指向的内容将会嵌入到文档中但钱标签所在的位置，在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src = &quot;js.js&quot;&gt; &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当浏览器解析到该元素时，会暂停其它资源的下载和处理，直到将该元素资源加载、编译、执行完毕，图片和框架等元素也是如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。</p><p>href是Hypertext的缩写 reference的缩写， 指向网络资源所在的位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href= &quot;common.css&quot; rel=&quot;stylesheet&quot; /&gt;</span><br></pre></td></tr></table></figure><p>name浏览器会识别该文档为css文件，就会并行下载资源并且不会停止当前文档的处理。这也是为什么建议用link方式加载css，而不是使用@import方式。</p><h4 id="11、知道的网页制作用到的图片格式都有哪些"><a href="#11、知道的网页制作用到的图片格式都有哪些" class="headerlink" title="11、知道的网页制作用到的图片格式都有哪些"></a>11、知道的网页制作用到的图片格式都有哪些</h4><p>png-8，png-24，jpeg，gif，svg。</p><p>Webp</p><p>Webp：Webp格式，谷歌（google）开发的一种旨在加快图片速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook、eBay等知名网站已开始测试并使用Webp格式。</p><p>在质量相同的情况下，Webp格式图像体积要比JPEG格式图像小40%。</p><h4 id="12、知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？"><a href="#12、知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？" class="headerlink" title="12、知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？"></a>12、知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？</h4><p>微格式（Microformats）是一种让机器可读的语义化XHML词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式。</p><p>优点：将智能数据添加到网页上，让网页内容在搜索引擎结果页面可以显示额外的提示。</p><h4 id="13、在css-js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理。"><a href="#13、在css-js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理。" class="headerlink" title="13、在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理。"></a>13、在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理。</h4><p>dns缓存，dcn缓存，浏览器缓存，服务器缓存。</p><h4 id="14、一个页面上有大量的图片（大型电商网站），加载很慢，有哪些方法优化这些图片的加载，给用户更好的体验。"><a href="#14、一个页面上有大量的图片（大型电商网站），加载很慢，有哪些方法优化这些图片的加载，给用户更好的体验。" class="headerlink" title="14、一个页面上有大量的图片（大型电商网站），加载很慢，有哪些方法优化这些图片的加载，给用户更好的体验。"></a>14、一个页面上有大量的图片（大型电商网站），加载很慢，有哪些方法优化这些图片的加载，给用户更好的体验。</h4><p>图片懒加载，在页面上的未可视域可添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离 ，如果前者小于后者，优先加载。</p><p>如果为幻灯片、相册等，可以使用图片预加载技术，将当前战士的前一张和后一张优先下载。</p><p>如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。</p><p>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</p><p>如果图片展示区域小于图片的真是大小，则因在服务器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？&quot;&gt;&lt;a href=&quot;#1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？&quot; class=&quot;headerlink&quot; title=&quot;1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>夜、萤火虫和你</title>
    <link href="https://tianjiec.top/2018/12/14/%E5%A4%9C%E3%80%81%E8%90%A4%E7%81%AB%E8%99%AB%E5%92%8C%E4%BD%A0/"/>
    <id>https://tianjiec.top/2018/12/14/夜、萤火虫和你/</id>
    <published>2018-12-14T12:51:36.000Z</published>
    <updated>2018-12-14T13:06:22.092Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"音乐/夜、萤火虫和你.mp3"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>  <span class="attr">autoplay</span> <span class="attr">preload</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>18/11/7</title>
    <link href="https://tianjiec.top/2018/11/07/18-11-7/"/>
    <id>https://tianjiec.top/2018/11/07/18-11-7/</id>
    <published>2018-11-07T03:48:52.000Z</published>
    <updated>2018-11-07T04:52:38.330Z</updated>
    
    <content type="html"><![CDATA[<p>每当我想好好学习<br>总有人和我说回去睡吧别学了<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://qzonestyle.gtimg.cn/qzone/em/e295.gif" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><br>今天又是爱我熙哥的一天</p><p><img src="http://p1lzepiq0.bkt.clouddn.com/%E7%BD%97%E4%BA%91%E7%86%99.jpg" width="280px" height="400px"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每当我想好好学习&lt;br&gt;总有人和我说回去睡吧别学了&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay
      
    
    </summary>
    
    
  </entry>
  
</feed>
