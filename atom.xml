<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chentj&#39;s Blog</title>
  
  <subtitle>Inflexible thinking, bad humor</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tianjiec.top/"/>
  <updated>2018-12-24T03:36:55.093Z</updated>
  <id>https://tianjiec.top/</id>
  
  <author>
    <name>chentj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue1</title>
    <link href="https://tianjiec.top/2018/12/24/Vue1/"/>
    <id>https://tianjiec.top/2018/12/24/Vue1/</id>
    <published>2018-12-24T03:09:56.000Z</published>
    <updated>2018-12-24T03:36:55.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总结一"><a href="#总结一" class="headerlink" title="总结一"></a>总结一</h1><h4 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./base/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    //每一个应用都是从创建一个实例开始的</span></span><br><span class="line"><span class="undefined">    //每一个应用起码得来这么一个实例</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    //声明式渲染：声明一条数据之后再利用特殊的模板语法将数据渲染到页面中</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    new Vue(&#123;</span></span><br><span class="line"><span class="undefined">        el:"#app",</span></span><br><span class="line"><span class="undefined">        data:&#123;</span></span><br><span class="line"><span class="undefined">            message:"hello world"</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="mvc-设计模式示例"><a href="#mvc-设计模式示例" class="headerlink" title="mvc 设计模式示例"></a>mvc 设计模式示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span>&gt;</span>toggle<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn2"</span>&gt;</span>big<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./base/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    //mvc的设计模式  设计项目逻辑</span></span><br><span class="line"><span class="undefined">    //m: model 数据模型  v: view 视图  c: controller 控制器</span></span><br><span class="line"><span class="undefined">    //c层需要控制model 在 view 进行显示</span></span><br><span class="line"><span class="undefined">    //M层的数据和v层的显示存在一个映射关系， 当我们建立好c层之后，焦点关注在数据变化上就行了。</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined">    //通过简单的mvc的设计思想来构建</span></span><br><span class="line"><span class="undefined">    //view层</span></span><br><span class="line"><span class="undefined">    let view = document.getElementsByClassName('box')[0];</span></span><br><span class="line"><span class="undefined">    //model</span></span><br><span class="line"><span class="undefined">    let model = &#123;</span></span><br><span class="line"><span class="undefined">        isShow: true,</span></span><br><span class="line"><span class="undefined">        isBig: false</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    //controller</span></span><br><span class="line"><span class="undefined">    function Controller()&#123;</span></span><br><span class="line"><span class="undefined">        this.init()；</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    Controller.prototype = &#123;</span></span><br><span class="line"><span class="undefined">        constructor: Controller,</span></span><br><span class="line"><span class="undefined">        init()&#123;</span></span><br><span class="line"><span class="undefined">this.addEvent();</span></span><br><span class="line"><span class="undefined">            this.render();</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        addEvent()&#123;</span></span><br><span class="line"><span class="undefined">            //let self = self;</span></span><br><span class="line"><span class="undefined">            //let This = this;</span></span><br><span class="line"><span class="undefined">            let btn = document.getElementsByClassName("btn")[0];</span></span><br><span class="line"><span class="undefined">            let btn2 = document.getElementsByClassName("btn2")[0];</span></span><br><span class="line"><span class="undefined">            btn.onclick = ()=&gt;&#123;</span></span><br><span class="line"><span class="undefined">                model.isShow = !model.isShow;</span></span><br><span class="line"><span class="undefined">                this.render();</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">            btn2.onclick = () =&gt; &#123;</span></span><br><span class="line"><span class="undefined">                model.isBig = true;</span></span><br><span class="line"><span class="undefined">                this.render();</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        render()&#123;//渲染的过程</span></span><br><span class="line"><span class="undefined">            view.style.display = model.isShow?"block":"none";</span></span><br><span class="line"><span class="undefined">            view.style.width = (model.isBig ? 400 : 50)+"px";</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    new Controller();</span></span><br></pre></td></tr></table></figure><h3 id="vue的mvvm-设计模式"><a href="#vue的mvvm-设计模式" class="headerlink" title="vue的mvvm 设计模式"></a>vue的mvvm 设计模式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标签内 数据不需要&#123;&#123;&#125;&#125; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-model 是vue 提供的指令 它的作用是操作dom --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        //Vue 采用的是MVVM模式，这是MVC衍生出来的</span></span><br><span class="line"><span class="undefined">        //区别：视图与vieqmodel直接的关系紧密</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        //M层的数据会与v层视图 建立联系</span></span><br><span class="line"><span class="undefined">        //v-model就是vue提供的指令 操作dom</span></span><br><span class="line"><span class="undefined">        let data = &#123;</span></span><br><span class="line"><span class="undefined">            message: "hello World"</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        let vm = new Vue(&#123;</span></span><br><span class="line"><span class="undefined">            el:".app",</span></span><br><span class="line"><span class="undefined">            // data:data</span></span><br><span class="line"><span class="undefined">            //data与data名相同 可简写为data</span></span><br><span class="line"><span class="undefined">            data</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">        //Vue当中实现双向数据绑定的原理：</span></span><br><span class="line"><span class="undefined">        //vue在创建viewmodel的时候，会将数据配置在实例中，然后会是使用Object.defineProperty对这</span></span><br><span class="line"><span class="undefined">        //些数据进行处理，并且为这些数据添加getter，setter方法，当数据改变之后，就会触发此数据绑定的setter方法</span></span><br><span class="line"><span class="undefined">        //从而触发vm的watcher方法，然后数据改变了，然后vm进一步渲染view视图。</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="undefined">        let data = &#123;</span></span><br><span class="line"><span class="undefined">            message: "Hello world"</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        let vm = new Vue(&#123;</span></span><br><span class="line"><span class="undefined">            el:".app",</span></span><br><span class="line"><span class="undefined">            data</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">        //Object.defineProperty()  es5提供的 ie8不支持</span></span><br><span class="line"><span class="undefined">        let _data = &#123;</span></span><br><span class="line"><span class="undefined">            </span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        let temp = 123;</span></span><br><span class="line"><span class="undefined">          temp = 123;</span></span><br><span class="line"><span class="undefined">        Object.defineProperty(_data,"msg",&#123;</span></span><br><span class="line"><span class="undefined">            get()&#123;</span></span><br><span class="line"><span class="undefined">                console.log("getter")</span></span><br><span class="line"><span class="undefined">                return temp;</span></span><br><span class="line"><span class="undefined">              </span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            set(vel)&#123;</span></span><br><span class="line"><span class="undefined">                console.log("setter")</span></span><br><span class="line"><span class="undefined">                temp = vel;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">        //获取数据</span></span><br><span class="line"><span class="undefined">        console.log(_data.msg)</span></span><br><span class="line"><span class="undefined">        //设置属性的时候会执行setter方法</span></span><br><span class="line"><span class="undefined">        _data.msg = 456;</span></span><br><span class="line"><span class="undefined">        console.log(_data.msg)</span></span><br><span class="line"><span class="undefined">        //vue双向数据绑定原理</span></span><br><span class="line"><span class="undefined">        /* </span></span><br><span class="line"><span class="undefined">            当view层数据改变时， 通过监听viewmodel获取数据  viewmodel再去改变 model数据层</span></span><br><span class="line"><span class="undefined">            数据修改之后 viewmodel再去设置 view层的显示</span></span><br><span class="line"><span class="undefined">         */</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;总结一&quot;&gt;&lt;a href=&quot;#总结一&quot; class=&quot;headerlink&quot; title=&quot;总结一&quot;&gt;&lt;/a&gt;总结一&lt;/h1&gt;&lt;h4 id=&quot;demo1&quot;&gt;&lt;a href=&quot;#demo1&quot; class=&quot;headerlink&quot; title=&quot;demo1&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="-js -vue" scheme="https://tianjiec.top/tags/js-vue/"/>
    
  </entry>
  
  <entry>
    <title>node.js取参的四种方法</title>
    <link href="https://tianjiec.top/2018/12/21/node-js%E5%8F%96%E5%8F%82%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://tianjiec.top/2018/12/21/node-js取参的四种方法/</id>
    <published>2018-12-21T11:59:17.000Z</published>
    <updated>2018-12-21T12:01:13.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="node-js取参四种方法"><a href="#node-js取参四种方法" class="headerlink" title="node.js取参四种方法"></a>node.js取参四种方法</h1><h4 id="req-body-req-params-req-param-req-body"><a href="#req-body-req-params-req-param-req-body" class="headerlink" title="req.body,req.params,req.param,req.body"></a>req.body,req.params,req.param,req.body</h4><p>参考：<a href="https://my.oschina.net/u/2519530/blog/535309" target="_blank" rel="noopener">https://my.oschina.net/u/2519530/blog/535309</a></p><p>获取请求很中的参数是每个web后台处理的必经之路，nodejs的 <strong>express框架</strong> 提供了四种方法来实现。</p><p>1,req.body</p><p>2,req.query</p><p>3,req.params</p><p>4,req.param()</p><p><strong>首先介绍第一个req.body</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">官方文档解释：</span><br><span class="line">Contains key-value pairs of data submitted in the request body. By default, it is undefined,</span><br><span class="line"> and is populated when you use body-parsing middleware such as body-parser and multer.</span><br><span class="line"></span><br><span class="line">稍微翻译一下：包含了提交数据的键值对在请求的body中，默认是underfined,</span><br><span class="line">你可以用body-parser或者multer来解析body</span><br></pre></td></tr></table></figure><p>解析body不是nodejs默认提供的，你需要载入body-parser中间件才可以使用req.body；</p><p>此方法通常用来解析POST请求中的数据</p><p><strong>第二种是req.query</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">官方文档解释：</span><br><span class="line">An object containing a property for each query string parameter in the route. </span><br><span class="line">If there is no query string, it is the empty object, &#123;&#125;.</span><br><span class="line">翻译一下:包含在路由中每个查询字符串参数属性的对象。如果没有，默认为&#123;&#125;</span><br></pre></td></tr></table></figure><p>有nodejs默认提供，无需载入中间件</p><p>举例说明（官方摘录）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /search?q=tobi+ferret</span></span><br><span class="line">req.query.q</span><br><span class="line"><span class="comment">// =&gt; "tobi ferret"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=converse</span></span><br><span class="line">req.query.order</span><br><span class="line"><span class="comment">// =&gt; "desc"</span></span><br><span class="line">req.query.shoe.color</span><br><span class="line"><span class="comment">// =&gt; "blue"</span></span><br><span class="line">req.query.shoe.type</span><br><span class="line"><span class="comment">// =&gt; "converse"</span></span><br></pre></td></tr></table></figure><p><strong>注意：此方法多适用于GET请求，解析GET里的参数</strong></p><p><strong>第三种是 req.params</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">官方文档：</span><br><span class="line">An object containing properties mapped to the named route “parameters”. </span><br><span class="line">For example, <span class="keyword">if</span> you have the route /user/:name, </span><br><span class="line">then the “name” property is available <span class="keyword">as</span> req.params.name. This object defaults to &#123;&#125;.</span><br><span class="line"></span><br><span class="line">翻译：包含映射到指定的路线“参数”属性的对象。</span><br><span class="line">例如，如果你有route/user/：name，那么“name”属性可作为req.params.name。</span><br><span class="line">该对象默认为&#123;&#125;。</span><br></pre></td></tr></table></figure><p>nodejs默认提供，无需载入其他中间件</p><p>举例说明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /user/tj</span></span><br><span class="line">req.params.name</span><br><span class="line"><span class="comment">// =&gt; "tj"</span></span><br></pre></td></tr></table></figure><p><strong>多适用于restful风格url中的参数的解析</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eq.query与req.params的区别</span><br><span class="line">req.params包含路由参数（在URL的路径部分），而req.query包含URL的查询参数（在URL的？后的参数）。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;node-js取参四种方法&quot;&gt;&lt;a href=&quot;#node-js取参四种方法&quot; class=&quot;headerlink&quot; title=&quot;node.js取参四种方法&quot;&gt;&lt;/a&gt;node.js取参四种方法&lt;/h1&gt;&lt;h4 id=&quot;req-body-req-params-r
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>soket</title>
    <link href="https://tianjiec.top/2018/12/20/soket/"/>
    <id>https://tianjiec.top/2018/12/20/soket/</id>
    <published>2018-12-20T12:35:54.000Z</published>
    <updated>2018-12-20T12:43:12.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>当前程序执行：</p><p>同步：阻塞，当前程序是否能够去执行，必须等前一个程序执行完毕之后，才能够去执行。</p><p>异步：非阻塞，当前程序的执行，并不受前一个程序是否执行完毕的影响。</p><p>多个程序之间的关系 （串行/并行）</p><p>并行： 多个程序之间可以同时或者不同时去执行，叫做并行</p><p>串行： 多个程序之间必须按照顺序去执行，这叫串行。</p><p>1、同步执行的程序，必然是串行的</p><p>2、异步执行的程序，可以实现串行</p><p>3、并行的程序必然是异步执行</p><p>套接字：</p><p>上传视频 ： 视频 =&gt; 二进制 =&gt; 分块（编码） + ip：port=&gt; 传输 =&gt; 组装</p><p>SOCKET</p><p>网络上两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="file:///C:/Users/罗中运/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image001.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h4 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h4><table><thead><tr><th>创建用来接收数据和广播数据的 服务器：</th><th></th></tr></thead><tbody><tr><td>创建socket</td><td>socket（）</td></tr><tr><td>绑定soket和端口号</td><td>bind（）</td></tr><tr><td>监听端口号</td><td>listen（）</td></tr><tr><td>接受信息</td><td>accept（）</td></tr><tr><td>从socket中读取字符</td><td>recv（）</td></tr><tr><td>关闭socket</td><td>close（）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;同步和异步&quot;&gt;&lt;a href=&quot;#同步和异步&quot; class=&quot;headerlink&quot; title=&quot;同步和异步&quot;&gt;&lt;/a&gt;同步和异步&lt;/h2&gt;&lt;p&gt;当前程序执行：&lt;/p&gt;
&lt;p&gt;同步：阻塞，当前程序是否能够去执行，必须等前一个程序执行完毕之后，才能够去执行。&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>5-1Node.js编写</title>
    <link href="https://tianjiec.top/2018/12/20/5-1Node-js%E7%BC%96%E5%86%99/"/>
    <id>https://tianjiec.top/2018/12/20/5-1Node-js编写/</id>
    <published>2018-12-20T09:17:09.000Z</published>
    <updated>2018-12-20T09:18:20.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学前需求"><a href="#学前需求" class="headerlink" title="学前需求"></a>学前需求</h2><blockquote><h3 id="一、node安装和运行"><a href="#一、node安装和运行" class="headerlink" title="一、node安装和运行"></a>一、node安装和运行</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">会安装node，搭建node环境</span><br><span class="line">会运行node执行node程序</span><br></pre></td></tr></table></figure><blockquote><h3 id="二、node基础模块的使用"><a href="#二、node基础模块的使用" class="headerlink" title="二、node基础模块的使用"></a>二、node基础模块的使用</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Buffer：二进制数据处理模块</span><br><span class="line">Events：事件模块</span><br><span class="line">fs：文件系统模块</span><br><span class="line">Net：网络模块</span><br><span class="line">Http：http模块</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://nodejs.org/api/" target="_blank" rel="noopener">https://nodejs.org/api/</a></p></blockquote><h2 id="前台管理功能"><a href="#前台管理功能" class="headerlink" title="前台管理功能"></a>前台管理功能</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/BUkKRSYer6YG8srS1RteyV39UGe04Zi8kcWL7bwoQas!/b/dGYBAAAAAAAA&bo=cgF6AQAAAAADByo!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="后台页面"><a href="#后台页面" class="headerlink" title="后台页面"></a>后台页面</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/R660H48.QMim2kKOUN.K5Pkfhpdcpu2cfnZmsIuDq.k!/b/dDEBAAAAAAAA&bo=KAKqAwAAAAADB6E!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="三、技术框架介绍"><a href="#三、技术框架介绍" class="headerlink" title="三、技术框架介绍"></a>三、技术框架介绍</h3><p>NodeJS、Express、Mongodb</p><h3 id="四、第三方模块-amp-中间件"><a href="#四、第三方模块-amp-中间件" class="headerlink" title="四、第三方模块&amp;中间件"></a>四、第三方模块&amp;中间件</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body-parser:解析post请求数据</span><br><span class="line">cookies:读/写cookie</span><br><span class="line">swig:模板解析引擎</span><br><span class="line">mongoose:操作mongodb数据</span><br><span class="line">markdown:markdown语法解析生成模块</span><br></pre></td></tr></table></figure><blockquote><h3 id="五、项目初始化"><a href="#五、项目初始化" class="headerlink" title="五、项目初始化"></a>五、项目初始化</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><blockquote><h3 id="六、依赖模块安装（要联网、要联网、要联网）"><a href="#六、依赖模块安装（要联网、要联网、要联网）" class="headerlink" title="六、依赖模块安装（要联网、要联网、要联网）"></a>六、依赖模块安装（要联网、要联网、要联网）</h3></blockquote><h2 id="应用创建"><a href="#应用创建" class="headerlink" title="应用创建"></a>应用创建</h2><blockquote><h3 id="准备：目录结构"><a href="#准备：目录结构" class="headerlink" title="准备：目录结构"></a>准备：目录结构</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/KEvmeky95HuJ4YaPSjoF5hjfAx9M9Q3bz6WsqtErtqQ!/b/dFYBAAAAAAAA&bo=xgKcAQAAAAADB3s!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="一、创建应用、监听端口-app-js中"><a href="#一、创建应用、监听端口-app-js中" class="headerlink" title="一、创建应用、监听端口(app.js中)"></a>一、创建应用、监听端口(app.js中)</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//加载express模块</span><br><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">//创建app应用  =&gt; NodeJS Http.createServer();</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">//监听http请求</span><br><span class="line">app.listen(8081);</span><br></pre></td></tr></table></figure><blockquote><h3 id="二、用户的访问"><a href="#二、用户的访问" class="headerlink" title="二、用户的访问"></a>二、用户的访问</h3><p>(1)用户通过URL访问web应用，如 http:localhost:8081/<br>(2)web后端根据用户访问的URL处理不同的业务逻辑</p><h3 id="三、处理请求输出"><a href="#三、处理请求输出" class="headerlink" title="三、处理请求输出"></a>三、处理请求输出</h3><p>(1)路由绑定：<br>通过app.get()或者app.post()等方法可以把一个url路径和一个或N个函数进行绑定。<br>app.get(“/“, function(req, res, next){}) req：request对象 - 保存客户端请求的一个数据 http.request<br>res：response对象 - 服务端输出对象，提供了一些服务器端输出相关的一些方法 - http.response<br>next：方法，用于执行下一个和路径匹配的函数</p><h3 id="四、内容输出"><a href="#四、内容输出" class="headerlink" title="四、内容输出"></a>四、内容输出</h3><p>通过res.send(string)发送内容到客户端</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//加载express模块</span><br><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">//创建app应用  =&gt; NodeJS Http.createServer();</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">首页</span><br><span class="line">监听到输入路径/，处理的操作</span><br><span class="line">*/</span><br><span class="line">app.get(&quot;/&quot;, function(req, res, next)&#123;</span><br><span class="line">res.send(&quot;&lt;h1&gt;欢迎光临我的博客!&lt;/h1&gt;&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//监听http请求</span><br><span class="line">app.listen(8081);</span><br></pre></td></tr></table></figure><blockquote><h3 id="五、使用模板"><a href="#五、使用模板" class="headerlink" title="五、使用模板"></a>五、使用模板</h3><p>（1）模板的使用<br>后端逻辑和页面表现分离 - 前后端分离<br>（2）模板的配置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//加载express模块</span><br><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">//加载模板处理前后端</span><br><span class="line">var swig = require(&quot;swig&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建app应用  =&gt; NodeJS Http.createServer();</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">//配置应用模板</span><br><span class="line">/*</span><br><span class="line">定义当前应用所使用的模板引擎,使用swig.renderFile方法解析后缀为html的文件</span><br><span class="line">第一个参数：模板引擎的名称，同时也是模板文件的后缀</span><br><span class="line">第二个参数：表示用于解析处理模板内容的方法</span><br><span class="line">*/</span><br><span class="line">app.engine(&quot;html&quot;, swig.renderFile);</span><br><span class="line">/*</span><br><span class="line">设置模板文件存放的目录</span><br><span class="line">第一个参数必须是views</span><br><span class="line">第二个参数是目录</span><br><span class="line">*/</span><br><span class="line">app.set(&quot;views&quot;, &quot;./views&quot;);</span><br><span class="line">/*</span><br><span class="line">注册所使用的模板引擎</span><br><span class="line">第一个参数：不能改必须是view engine</span><br><span class="line">第二个参数：和app.engine这个方法中定义的模板引擎的名称（第一个参数）是一致的</span><br><span class="line">*/</span><br><span class="line">app.set(&quot;view engine&quot;, &quot;html&quot;);</span><br><span class="line">/*</span><br><span class="line">【注】这里注意，在开发过程中，需要取消模板缓存</span><br><span class="line">*/</span><br><span class="line">swig.setDefaults(&#123;cache: false&#125;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">首页</span><br><span class="line">监听到输入路径/，处理的操作</span><br><span class="line">*/</span><br><span class="line">app.get(&quot;/&quot;, function(req, res, next)&#123;</span><br><span class="line">// res.send(&quot;&lt;h1&gt;欢迎光临我的博客!&lt;/h1&gt;&quot;);</span><br><span class="line">//将前后台页面进行分离</span><br><span class="line">/*</span><br><span class="line">读取view目录下的指定文件，解析并返回给客户端</span><br><span class="line">第一个参数，表示模板文件，相对于views目录 views/index.html</span><br><span class="line">第二个参数，传递给模板使用的数据。</span><br><span class="line">*/</span><br><span class="line">res.render(&quot;index&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//监听http请求</span><br><span class="line">app.listen(8081);</span><br></pre></td></tr></table></figure><blockquote><p>当我们在设置main.css样式链接的时候，提示请求失败，是因为我们没有设置对应的路由操作</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(&quot;/main.css&quot;, function(req, res, next)&#123;</span><br><span class="line"></span><br><span class="line">// 默认发送的是html格式数据，没有办法解析</span><br><span class="line">// 在这里需要设置解析格式头</span><br><span class="line"></span><br><span class="line">res.setHeader(&quot;content-type&quot;, &quot;text/css&quot;);</span><br><span class="line"></span><br><span class="line">res.send(&quot;body &#123;background-color: red;&#125;&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>但是上述这种操作处理静态文件过于麻烦，我们可以设置静态文件托管目录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//修改index.html</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;/public/main.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">//修改app.js</span><br><span class="line">/*</span><br><span class="line">设置静态文件托管</span><br><span class="line">下述代码的意思是，如果加载路径url是以/public开头的，就以后续操作处理</span><br><span class="line">*/</span><br><span class="line">app.use(&quot;/public&quot;, express.static(__dirname + &quot;/public&quot;));</span><br></pre></td></tr></table></figure><blockquote><p>【注】项目逻辑：<br>用户发送http请求 -&gt; url -&gt; 解析路由 -&gt; 找到匹配的规则 -&gt; 满足规则执行绑定的函数 -&gt; 返回对应的内容。<br>/public -&gt; 静态 -&gt; 直接读取指定目录下的文件，返回用户<br>动态 -&gt; 处理业务逻辑，加载模板，解析模板 -&gt; 返回数据给用户。</p><h2 id="六、划分模块"><a href="#六、划分模块" class="headerlink" title="六、划分模块"></a>六、划分模块</h2><h3 id="根据功能进行模块划分"><a href="#根据功能进行模块划分" class="headerlink" title="根据功能进行模块划分"></a>根据功能进行模块划分</h3><p>前台模块<br>后台管理模块<br>API模块</p><p>使用app.use()进行模块划分</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(&quot;/admin&quot;, require(&apos;./routers/admin&apos;));</span><br><span class="line">app.use(&quot;/api&quot;, require(&quot;.routers/api&quot;));</span><br><span class="line">app.use(&quot;/&quot;, require(&quot;./routers/main&quot;));</span><br></pre></td></tr></table></figure><blockquote><p>创建routers/admin.js routers/api.js routers/main.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line">//这里不需要些/admin/user，因为前面已经处理过了</span><br><span class="line">router.get(&quot;/user&quot;, function(req, res, next)&#123;</span><br><span class="line">res.send(&quot;ADMIN - User&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure><blockquote><h3 id="前台路由-模板"><a href="#前台路由-模板" class="headerlink" title="前台路由+模板"></a>前台路由+模板</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/yrwfg0RB5*BrSANs3IltkSPIIe76l7bseNEbdTw4DDY!/b/dFYBAAAAAAAA&bo=BAKIAQAAAAADB60!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="后台路由-模块"><a href="#后台路由-模块" class="headerlink" title="后台路由+模块"></a>后台路由+模块</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/yd3sN3SlMU22RfznIbFMYtreROhe80JUaw8Zx0xj7QU!/b/dFYBAAAAAAAA&bo=BgIEAgAAAAADByA!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="功能开发顺序"><a href="#功能开发顺序" class="headerlink" title="功能开发顺序"></a>功能开发顺序</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/Rh6kslhjswehoKgecSqxrliFSMIG4q9rm*DjmbSuZs8!/b/dF4BAAAAAAAA&bo=EgJeAQAAAAADB20!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="首先我们来看一下如何链接数据库mongoDB"><a href="#首先我们来看一下如何链接数据库mongoDB" class="headerlink" title="首先我们来看一下如何链接数据库mongoDB"></a>首先我们来看一下如何链接数据库mongoDB</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --dbpath=磁盘路径 port=端口号</span><br></pre></td></tr></table></figure><blockquote><h3 id="数据库的使用"><a href="#数据库的使用" class="headerlink" title="数据库的使用"></a>数据库的使用</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/bDrNzQyw4OQ2Xwat*g6CDTXSQcAgDzaFrgLSIH0L4HY!/b/dGcBAAAAAAAA&bo=JgJ0AQAAAAADB3M!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><p>（1）首先在app.js中链接数据库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//加载数据库模块</span><br><span class="line">var mongoose = require(&quot;mongoose&quot;);</span><br><span class="line">//链接数据库</span><br><span class="line">mongoose.connect(&quot;mongodb://127.0.0.1:27017&quot;, function(err)&#123;</span><br><span class="line">if(err)&#123;</span><br><span class="line">console.log(&quot;数据库链接失败：&quot; + err);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">console.log(&quot;数据库链接成功&quot;);</span><br><span class="line">//当我们数据库链接成功以后，监听http请求</span><br><span class="line">app.listen(8081);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>（2）创建schemas/users.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&quot;mongoose&quot;);</span><br><span class="line"></span><br><span class="line">//定义用户的表结构,并对外提供接口</span><br><span class="line">module.exports = new mongoose.Schema(&#123;</span><br><span class="line">//用户名</span><br><span class="line">username: String,</span><br><span class="line">//密码</span><br><span class="line">password: String</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>（3）创建models/User.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&quot;mongoose&quot;);</span><br><span class="line"></span><br><span class="line">var usersSchema = require(&quot;../schemas/users&quot;);</span><br><span class="line"></span><br><span class="line">//完成了一个模型类</span><br><span class="line">module.exports = mongoose.model(&quot;User&quot;, usersSchema);</span><br><span class="line">/*</span><br><span class="line">【注】后期可以通过这个模型类创建对象</span><br><span class="line">直接对表中的数据进行操作。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><blockquote><h3 id="用户注册"><a href="#用户注册" class="headerlink" title="用户注册"></a>用户注册</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/YRE0y3xWBvM4MuKGsuZoc0aAjLYcIhTQP6kXcNCa73o!/b/dFYBAAAAAAAA&bo=jAEOAQAAAAADB6A!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="设置用户主页"><a href="#设置用户主页" class="headerlink" title="设置用户主页"></a>设置用户主页</h3><p>修改routers/main.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line">//这里不需要些/admin/user，因为前面已经处理过了</span><br><span class="line">router.get(&quot;/&quot;, function(req, res, next)&#123;</span><br><span class="line">// res.send(&quot;首页&quot;);</span><br><span class="line">//加载index.html</span><br><span class="line">res.render(&quot;main/index&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure><blockquote><p>拷贝对应的index.html（已经写好了） 页面到views/main/index.html<br>同时拷贝对应的其他文件到public中</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/x3.YvajSctA1zqznjRIefek90Yg7PR.8IIHL4RPwLx8!/b/dFYBAAAAAAAA&bo=8AFkAQAAAAADB7Y!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><p>在public/js/index.js中编写登录注册逻辑</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//设置登录和注册互斥显示</span><br><span class="line">$(function()&#123;</span><br><span class="line">$loginBox = $(&quot;#loginBox&quot;);</span><br><span class="line">$registerBox = $(&quot;#registerBox&quot;);</span><br><span class="line"></span><br><span class="line">//点击马上注册，切换到注册面板</span><br><span class="line">$loginBox.find(&quot;a&quot;).on(&quot;click&quot;, function()&#123;</span><br><span class="line">$registerBox.show();</span><br><span class="line">$loginBox.hide();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//切换到登录面板</span><br><span class="line">$registerBox.find(&quot;a&quot;).on(&quot;click&quot;, function()&#123;</span><br><span class="line">$registerBox.hide();</span><br><span class="line">$loginBox.show();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//注册</span><br><span class="line">$registerBox.find(&quot;button&quot;).on(&quot;click&quot;, function()&#123;</span><br><span class="line">//点击注册按钮，通过ajax提交请求</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">type: &quot;POST&quot;,</span><br><span class="line">url: &quot;/api/user/register&quot;,</span><br><span class="line">data: &#123;</span><br><span class="line">username: $registerBox.find(&quot;[name=username]&quot;).val(),</span><br><span class="line">password: $registerBox.find(&quot;[name=password]&quot;).val(),</span><br><span class="line">repassword: $registerBox.find(&quot;[name=repassword]&quot;).val()</span><br><span class="line">&#125;,</span><br><span class="line">dataType: &quot;json&quot;,</span><br><span class="line">success: function(result)&#123;</span><br><span class="line">console.log(result);</span><br><span class="line">&#125;,</span><br><span class="line">error: function(err)&#123;</span><br><span class="line">console.log(&quot;请求错误：&quot; + err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">//这个部分我们只是完成了前端注册信息的提交</span><br></pre></td></tr></table></figure><blockquote><p>下面我们给后端增加注册的逻辑<br>处理post请求数据需要引入body-parser模块<br>在app.js中设置该模块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var bodyParser = require(&quot;body-parser&quot;); </span><br><span class="line">/*</span><br><span class="line">bodyParser设置</span><br><span class="line">*/</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended: true&#125;));</span><br></pre></td></tr></table></figure><blockquote><p>在 routers/api.js 中实现</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line">//定义统一返回格式</span><br><span class="line">var responseData;</span><br><span class="line"></span><br><span class="line">router.use(function(req, res, next)&#123;</span><br><span class="line">responseData = &#123;</span><br><span class="line">code: 0,    //错误码</span><br><span class="line">message: &quot;&quot; //信息</span><br><span class="line">&#125;</span><br><span class="line">next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//这里不需要些/admin/user，因为前面已经处理过了</span><br><span class="line">//在api.js中增加路由</span><br><span class="line">/*</span><br><span class="line">用户注册</span><br><span class="line">这里我们需要获取到提交的post数据，</span><br><span class="line">这里需要用到模块body-parser,用来处理post提交过来的数据</span><br><span class="line">在app.js中引入该模块</span><br><span class="line">body-parser引入以后，还需要进行一些相关配置，具体百度</span><br><span class="line">设置以后，会自动在req中增加一个属性body</span><br><span class="line">这个属性中有我们post请求提交的数据</span><br><span class="line">*/</span><br><span class="line">router.post(&quot;/user/register&quot;, function(req, res, next)&#123;</span><br><span class="line">// console.log(&quot;register&quot;);</span><br><span class="line">// console.log(req.body);</span><br><span class="line">/*</span><br><span class="line">下面我们编写注册逻辑</span><br><span class="line">1、基本的注册逻辑判断</span><br><span class="line">（1）用户名不能为空</span><br><span class="line">（2）密码不能为空</span><br><span class="line">（3）两次输入的密码必须一致</span><br><span class="line">2、和数据库中的数据进行比对，判断是否被注册了</span><br><span class="line">（1）数据库的查询</span><br><span class="line">【注】在判断过程中，我们需要随时返回判断结果，所以需要设置统一接口</span><br><span class="line">*/</span><br><span class="line">var username = req.body.username;</span><br><span class="line">var password = req.body.password;</span><br><span class="line">var repassword = req.body.repassword;</span><br><span class="line"></span><br><span class="line">//用户名是否为空</span><br><span class="line">if(username == &quot;&quot;)&#123;</span><br><span class="line">responseData.code = 1;</span><br><span class="line">responseData.message = &quot;用户名不能为空&quot;;</span><br><span class="line">//返回前端</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//密码不能为空</span><br><span class="line">if(password == &quot;&quot;)&#123;</span><br><span class="line">responseData.code = 2;</span><br><span class="line">responseData.message = &quot;密码不能为空&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//两次输入的密码不一致，必须一致</span><br><span class="line">if(password != repassword)&#123;</span><br><span class="line">responseData.code = 3</span><br><span class="line">responseData.message = &quot;两次输入的密码不一致&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//注册成功</span><br><span class="line">responseData.message = &quot;注册成功&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure><blockquote><h3 id="添加数据库验证"><a href="#添加数据库验证" class="headerlink" title="添加数据库验证"></a>添加数据库验证</h3><p>routers/api.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   //引入数据模型</span><br><span class="line">   var User = require(&quot;../models/User&quot;);</span><br><span class="line">   //插入到一般判断后面</span><br><span class="line">/*</span><br><span class="line">用户名是否已经被注册了，</span><br><span class="line">如果数据库已经存在和我们要注册的用户名同名的数据</span><br><span class="line">表示用户名已经被注册了</span><br><span class="line">*/</span><br><span class="line">User.findOne(&#123;</span><br><span class="line">username: username</span><br><span class="line">&#125;).then(function(userInfo)&#123;</span><br><span class="line">// console.log(userInfo);</span><br><span class="line">if(userInfo)&#123;</span><br><span class="line">//表示数据库中有该记录</span><br><span class="line">responseData.code = 4;</span><br><span class="line">responseData.message = &quot;用户名已经被注册了&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//保存用户注册的信息到数据库中</span><br><span class="line">var user = new User(&#123;</span><br><span class="line">username: username,</span><br><span class="line">password: password</span><br><span class="line">&#125;);</span><br><span class="line">//保存到数据库</span><br><span class="line">return user.save(); </span><br><span class="line">&#125;).then(function(newUserInfo)&#123;</span><br><span class="line">console.log(newUserInfo);</span><br><span class="line">//注册成功 数据成功存储在了admin数据库中</span><br><span class="line">responseData.message = &quot;注册成功&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>将注册成功的信息显示在页面上(public/js/index.js)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">success: function(result)&#123;</span><br><span class="line">// console.log(result);</span><br><span class="line">$registerBox.find(&quot;.colWarning&quot;).html(result.message);</span><br><span class="line">if(!result.code)&#123;</span><br><span class="line">//注册成功</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">//显示登录页面，隐藏注册页面</span><br><span class="line">$registerBox.hide();</span><br><span class="line">$loginBox.show();</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>同样的原理，编写登录<br>public/js/index.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//登录</span><br><span class="line">$loginBox.find(&quot;button&quot;).on(&quot;click&quot;, function()&#123;</span><br><span class="line">//通过ajax提交请求</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">type: &quot;post&quot;,</span><br><span class="line">url: &quot;api/user/login&quot;,</span><br><span class="line">data: &#123;</span><br><span class="line">username: $loginBox.find(&quot;[name=username]&quot;).val(),</span><br><span class="line">password: $loginBox.find(&quot;[name=password]&quot;).val()</span><br><span class="line">&#125;,</span><br><span class="line">dataType: &quot;json&quot;,</span><br><span class="line">success: function(result)&#123;</span><br><span class="line">//提示信息</span><br><span class="line">$loginBox.find(&quot;.colWarning&quot;).html(result.message);</span><br><span class="line">// console.log(result);</span><br><span class="line">if(!result.code)&#123;</span><br><span class="line">//登录成功</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">//显示登录页面，隐藏注册页面</span><br><span class="line">$loginBox.hide();</span><br><span class="line">$userInfo.show();</span><br><span class="line"></span><br><span class="line">//将用户信息显示在页面上</span><br><span class="line">$userInfo.find(&quot;.username&quot;).html(result.userInfo.username);</span><br><span class="line">$userInfo.find(&quot;.info&quot;).html(&quot;你好，欢迎光临我的博客！😁&quot;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在routers/api.js中新增登录的路由</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//新增登录的路由</span><br><span class="line">/*</span><br><span class="line">登录</span><br><span class="line">*/</span><br><span class="line">router.post(&quot;/user/login&quot;, function(req, res, next)&#123;</span><br><span class="line">var username = req.body.username;</span><br><span class="line">var password = req.body.password;</span><br><span class="line"></span><br><span class="line">if(username == &quot;&quot; || password == &quot;&quot;)&#123;</span><br><span class="line">responseData.code = 1;</span><br><span class="line">responseData.message = &quot;用户名和密码不能为空&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查询数据库中相同用户名和密码的记录是否存在，如果存在则登录成功</span><br><span class="line">User.findOne(&#123;</span><br><span class="line">username: username,</span><br><span class="line">password: password</span><br><span class="line">&#125;).then(function(userInfo)&#123;</span><br><span class="line">if(!userInfo)&#123;</span><br><span class="line">responseData.code = 2;</span><br><span class="line">responseData.message = &quot;用户名或密码错误&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用户名和密码正确</span><br><span class="line">responseData.message = &quot;登录成功&quot;;</span><br><span class="line">//将登录信息返回前端页面</span><br><span class="line">responseData.userInfo = &#123;</span><br><span class="line">_id: userInfo._id,</span><br><span class="line">username: userInfo.username</span><br><span class="line">&#125;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学前需求&quot;&gt;&lt;a href=&quot;#学前需求&quot; class=&quot;headerlink&quot; title=&quot;学前需求&quot;&gt;&lt;/a&gt;学前需求&lt;/h2&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;一、node安装和运行&quot;&gt;&lt;a href=&quot;#一、node安装和运行&quot; class=&quot;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>express的路由</title>
    <link href="https://tianjiec.top/2018/12/20/express%E7%9A%84%E8%B7%AF%E7%94%B1/"/>
    <id>https://tianjiec.top/2018/12/20/express的路由/</id>
    <published>2018-12-20T02:42:13.000Z</published>
    <updated>2018-12-20T03:07:29.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="express路由与应用模式"><a href="#express路由与应用模式" class="headerlink" title="express路由与应用模式"></a>express路由与应用模式</h1><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><blockquote><p>Express是一个基于Node.js的轻量级web开发框架，具有体积小，使用灵活等特点。查看Express的源码，如果不计供使用的中间件，主体框架只有一千余行代码，非常简练。</p><p>Express模型的核心为Express中定义的路由和路由器。分析Express源码可发现Express的路由提供多种灵活的应用模式。</p><p>我们首先介绍一下Express中的路由、路由器相关概念、结构及其特点，然后针对典型场景描述使用Express路由的四种应用模式。</p></blockquote><h3 id="2-Express中的路由与路由器"><a href="#2-Express中的路由与路由器" class="headerlink" title="2.Express中的路由与路由器"></a>2.Express中的路由与路由器</h3><p>Express具有典型的MVC模型特征。我们将路由定义为一个二元组route=(path, endpoint)：其中path为HTTP请求的路径，endpoint为请求路径应映射到的端点（端点可视为处理该请求的实体）,则Express中的路由器负责将请求映射到对应端点进行处理。</p><p>Express中的路由器分为两种类型:</p><p>app类型的路由器常使用如下代码创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br></pre></td></tr></table></figure><p>router类型的路由器常使用如下代码创建:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br></pre></td></tr></table></figure><blockquote><p>app和router是形为function(request, response, next)形式的函数对象，使用app.verb()，router.verb()形式函数实现路由注册（路由注册本质上是一个观察者模式）。</p><p>app.verb()和router.verb()中的verb常使用use、get、post、put、delete、route等动词，不同动词管辖的HTTP请求方法范围不同，这些动词函数的参数形式常为(pathExp, handleCallback)形式：其中pathExp表示请求路径，可为正则表达式；handleCallback为路径映射处理函数。</p></blockquote><p>app是Express框架所构建程序的请求处理入口，app可作为顶层路由器使用，在应用中也可挂载下级路由器（使用router对象）以实现分级路由。其间的关系可由下图表示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://s1.51cto.com/images/20180716/1531726860898789.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="express对象关系图.jpg" title="">                </div>                <div class="image-caption">express对象关系图.jpg</div>            </figure><p><strong>考察如下代码：</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/reports'</span>, router1);</span><br><span class="line">router1.get(<span class="string">'/querymysql/:id'</span>, queryMysqlData, handleQueryData);</span><br></pre></td></tr></table></figure><blockquote><p>对于http请求URL“/reports/querymysql/1”，Express中的路由器将此请求路由到queryMysqlData函数处理。</p></blockquote><h3 id="3、Express中的路由应用模式"><a href="#3、Express中的路由应用模式" class="headerlink" title="3、Express中的路由应用模式"></a>3、Express中的路由应用模式</h3><h3 id="3-1-REST模式"><a href="#3-1-REST模式" class="headerlink" title="3.1.   REST模式"></a>3.1.   REST模式</h3><p>对于一个使用restful风格的应用, 让我们想一想在不使用Express的时候如何在Node.js中处理rest请求，我们常常会写下如下示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">switch</span> (request.url) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'uri1'</span></span><br><span class="line">                        handleUri1 (request, response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' uri2'</span></span><br><span class="line">                        handleU ri2(request, response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' uri3'</span></span><br><span class="line">                        handleU ri3 (request, response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' uri4'</span></span><br><span class="line">                        handleU ri4 (request, response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        logToConsole(<span class="string">'unknown path:'</span> + path);</span><br><span class="line">                        response.writeHead(<span class="number">404</span>);</span><br><span class="line">                        response.end(<span class="string">"404 Not found"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Express将上面代码中对每个rest资源的操作(switch分支)转换为路由，路由中的路径为rest资源的URI，处理端点为function(request, response, next)形式、对rest资源的操作函数。</p><p>常使用app.route函数实现一个完整的restful接口，如下示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.route(<span class="string">'/uri1'</span>)</span><br><span class="line">  .get(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    handleGetUri1();</span><br><span class="line">  &#125;)</span><br><span class="line">  .post(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    handlePost Uri1 ();</span><br><span class="line">  &#125;)</span><br><span class="line">  .put(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    handlePut Uri <span class="number">1</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">.delete(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    handleDeleteUri <span class="number">1</span>();</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="3-2-AOP模式"><a href="#3-2-AOP模式" class="headerlink" title="3.2.   AOP模式"></a>3.2.   AOP模式</h3><p>在处理不同路径的HTTP请求时，常常需要在请求处理前和处理后做一些通用操作，这种应用需求是一个典型的AOP应用要求。</p><p>Express中允许定义一个具有通配路径的路由，在调用其它路径的路由前会先调用该通配路径路由。此通配路径路由也成为其它路径路由切面的一个注入点，考察如下示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.use(<span class="function"><span class="keyword">function</span> <span class="title">timelog</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"receive report request time is:"</span>,<span class="built_in">Date</span>.now());</span><br><span class="line">    next(); <span class="comment">//注意next函数的使用，必须声明该函数才能调用后继映射函数</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">router.get(<span class="string">'/chart1'</span>, proxy(&#123;</span><br><span class="line">    target: <span class="string">'http://127.0.0.1:8082'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">        <span class="string">'^/reports/chart1'</span>: <span class="string">'/loadChart1'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br><span class="line"> </span><br><span class="line">router.get(<span class="string">'/querymysql/:id'</span>, queryMysqlData, handleQueryData);</span><br></pre></td></tr></table></figure><p>上述代码中，在执行router的’/chart1’路由和’/querymysql/:id’路由之前都会执行timelog函数，在日志中记录当前路由执行时间。</p><h3 id="3-3-责任链模式"><a href="#3-3-责任链模式" class="headerlink" title="3.3.   责任链模式"></a>3.3.   责任链模式</h3><p>在Node.js中，由于多使用异步函数，常会出现异步回调函数中嵌套异步回调函数的情形。当出现多重异步回调时,则代码会变得混乱和难以维护。</p><p>考察一个应用场景：应用需要在数据库中进行多次查询，并对多次查询的结果综合处理。若使用数据库提供的异步查询接口，则需要在前一个查询操作的回调函数中进行下一个查询操作，若写在一个回调函数中，代码显臃肿。</p><p>Express的一个路由可定义多个处理函数，这些处理函数可设计为链式调用，实现了责任链模式，考察如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/test'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    handle1();</span><br><span class="line">    next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    handle2();</span><br><span class="line">    next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">   handle3();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述代码中：handle1, handle2, handle3构成了一个处理责任链“handle1-&gt;handle2-&gt;handle3”，通过next函数指引链式调用。</p><p>Express中路由的责任链应用特性使得多重异步嵌套的代码变得清晰和优雅。</p><p>​    针对本节开始提到的数据库查询应用场景，下面的示例代码展示了责任链模式的应用特点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/querymysql/:id'</span>, queryMysqlData, handleQueryData);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//查询mysql表中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryMysqlData</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"id"</span> <span class="keyword">in</span> req.params) &#123;</span><br><span class="line">        dbpool.query(<span class="string">" select * from articles where id=?"</span> ,[req.params.id], <span class="function"><span class="keyword">function</span> (<span class="params">err, rows, fields</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                res.send(err.stack);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rows &amp;&amp; rows.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'The queried rows is: '</span>, rows.length);</span><br><span class="line">                    res.articles = rows;</span><br><span class="line">                    next();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.send(<span class="string">"no query results!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.send(<span class="string">"invalid query params!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//处理查询mysql后得到的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleQueryData</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"articles"</span> <span class="keyword">in</span> res) &#123;</span><br><span class="line">        res.send(<span class="string">"id:"</span> + req.params.id + <span class="string">";title:"</span> + res.articles[<span class="number">0</span>].title);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.send(<span class="string">"no query data handled!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-熔断器模式"><a href="#3-4-熔断器模式" class="headerlink" title="3.4.   熔断器模式"></a>3.4.   熔断器模式</h3><p>上节提到的责任链模式本质上是一个逐级调用模型。在分布式服务架构（微服务架构）中，深度调用常常需要考虑调用可达性问题，即需要考虑某级调用会否一直不响应。调用可达性问题常使用熔断器模式，即在调用端设置一个熔断器，熔断条件产生时，熔断器发生熔断，返回给调用方调用失败信息。</p><p>考虑这样的应用场景：对于一些有处理时间要求的请求，当在指定时间内没有完成处理，需要向请求方返回处理失败信息。针对此应用场景，可在Express路由中设置超时熔断器，当处理超时，开启熔断器，通知请求方本次处理请求失败。</p><p>上述应用场景可使用如下示例代码应对：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/circuit'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bt=setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        next(<span class="string">'route'</span>); <span class="comment">//触发熔断</span></span><br><span class="line">    &#125;,<span class="number">3000</span>); <span class="comment">//设置熔断时间为3秒</span></span><br><span class="line">   res.breakTimer = bt;</span><br><span class="line">   next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    handle2();</span><br><span class="line">    next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">   handle3();</span><br><span class="line">   clearTimeout(res.breakTimer);<span class="comment">//正常执行完毕，取消熔断定时器</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/circuit '</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!res.finished)&#123; <span class="comment">//如果还没有响应，启动熔断</span></span><br><span class="line">    <span class="comment">//返回给调用者熔断信息</span></span><br><span class="line">    res.send(<span class="string">"breakCondition is true, notify the invoker."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="路径和句柄"><a href="#路径和句柄" class="headerlink" title="路径和句柄"></a>路径和句柄</h2><h3 id="理解了路径和句柄，才算真的会了Express路由的使用"><a href="#理解了路径和句柄，才算真的会了Express路由的使用" class="headerlink" title="理解了路径和句柄，才算真的会了Express路由的使用"></a>理解了路径和句柄，才算真的会了Express路由的使用</h3><p>路由：就是如何处理HTTP请求中的路径部分。</p><p>每个路径都会有对应的函数来处理（这个函数叫句柄），下面一个一个来说。</p><h4 id="一、有关路径"><a href="#一、有关路径" class="headerlink" title="一、有关路径"></a>一、有关路径</h4><p>路径可以是一个String类型也可以是一个正则表达式，例子：</p><p>1、当路径是String：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1053068413,3123129933&fm=173&s=AC9825D24BFEB6CA40BCCD030100E0C2&w=515&h=278&img.JPEG" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>如上图所示配置路由，页面分别访问：</p><p><a href="http://localhost:1234/abcd" target="_blank" rel="noopener">http://localhost:1234/abcd</a></p><p>输出：This is list</p><p><a href="http://localhost:1234/list/news/" target="_blank" rel="noopener">http://localhost:1234/list/news/</a></p><p>输出：This is news</p><p><a href="http://localhost:1234/list/news/123" target="_blank" rel="noopener">http://localhost:1234/list/news/123</a></p><p>输出：This is list news:123</p><p>2、当路径是正则表达式：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=1685331371,3718706668&fm=173&s=AC9835D3C9C8B4415AE5C50F0100E0C2&w=509&h=158&img.JPEG" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>第一个路由匹配的是/mobile/1[十个数字]，页面访问：</p><p><a href="http://localhost:1234/mobile/1XXXXXXXXXX" target="_blank" rel="noopener">http://localhost:1234/mobile/1XXXXXXXXXX</a></p><p>输出：This is a mobile phone ……</p><p>第二个路由匹配的是/abcd或者/acd。</p><h4 id="二、有关句柄"><a href="#二、有关句柄" class="headerlink" title="二、有关句柄"></a>二、有关句柄</h4><p>有关句柄，说两个问题</p><p>1、next和next（’route’）区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request,response,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req, res ,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    next(<span class="string">'route'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res ,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    next()</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req, res ,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    next(<span class="string">'route'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上图所示，有三个地方加了next，实例测试发现：</p><p>当位置1是next()时，结果输出：1234</p><p>当位置1是next(‘router’)时，结果输出：134</p><h5 id="由此可见，二者的区别就是：next从下一个处理函数开始往下执行，next-‘router’-，直接执行下一个相同路由。"><a href="#由此可见，二者的区别就是：next从下一个处理函数开始往下执行，next-‘router’-，直接执行下一个相同路由。" class="headerlink" title="由此可见，二者的区别就是：next从下一个处理函数开始往下执行，next(‘router’)，直接执行下一个相同路由。"></a>由此可见，二者的区别就是：next从下一个处理函数开始往下执行，next(‘router’)，直接执行下一个相同路由。</h5><p>2】param</p><p>param在路由中也相当于是一个中间件作用。例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.param(<span class="string">"listname"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next, listname</span>)</span>&#123;</span><br><span class="line">    req.list = [<span class="string">'item0'</span>, <span class="string">'item1'</span>, <span class="string">'item2'</span>];</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">'/list/:listname'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'list:\n'</span> + req.list.join(<span class="string">''</span>));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面这个路由输出：list:item0item1item2</p><p>app.param会在路由前执行，需要注意的是listname参数一定要对应。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;express路由与应用模式&quot;&gt;&lt;a href=&quot;#express路由与应用模式&quot; class=&quot;headerlink&quot; title=&quot;express路由与应用模式&quot;&gt;&lt;/a&gt;express路由与应用模式&lt;/h1&gt;&lt;h3 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mongoose</title>
    <link href="https://tianjiec.top/2018/12/20/mongoose/"/>
    <id>https://tianjiec.top/2018/12/20/mongoose/</id>
    <published>2018-12-20T02:18:28.000Z</published>
    <updated>2018-12-20T02:23:42.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>　　Mongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具</p><p>　　那么要使用它，首先你得装上node.js和mongodb,关于mongodb的安装和操作介绍可以参考：<a href="http://www.cnblogs.com/zhongweiv/p/node_mongodb.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhongweiv/p/node_mongodb.html</a></p><p>　　Github地址：<a href="https://github.com/Automattic/mongoose" target="_blank" rel="noopener">https://github.com/Automattic/mongoose</a></p><p>　　API Docs：<a href="http://mongoosejs.com/docs/guide.html" target="_blank" rel="noopener">http://mongoosejs.com/docs/guide.html</a></p><p>　　前面有介绍过用node-mongodb-native来操作mongodb，实际开发中估计更多会选用类似mongoose的模块来操作来提升开发效率</p><p>　　下面我们一步步来了解mongoose的基本操作^_^!</p><h1 id="mongoose安装"><a href="#mongoose安装" class="headerlink" title="mongoose安装"></a>mongoose安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mongoose</span><br></pre></td></tr></table></figure><p>　　安装成功后如下图：</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images.cnblogs.com/cnblogs_com/zhongweiv/804376/o_1.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure></blockquote><p>　　安装成功后，就可以通过 require(‘mongoose’) 来使用！</p><h1 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h1><p>　　创建一个db.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line">DB_URL = <span class="string">'mongodb://localhost:27017/mongoosedemo'</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mongoose.connect(DB_URL);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;　　Mongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具&lt;/p&gt;
&lt;p&gt;　　那么要使用它，首先你得装上no
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>框架初探-blog项目</title>
    <link href="https://tianjiec.top/2018/12/19/%E6%A1%86%E6%9E%B6%E5%88%9D%E6%8E%A2-blog%E9%A1%B9%E7%9B%AE/"/>
    <id>https://tianjiec.top/2018/12/19/框架初探-blog项目/</id>
    <published>2018-12-19T11:51:16.000Z</published>
    <updated>2018-12-19T11:51:16.179Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6 Promise用法</title>
    <link href="https://tianjiec.top/2018/12/19/ES6-Promise%E7%94%A8%E6%B3%95/"/>
    <id>https://tianjiec.top/2018/12/19/ES6-Promise用法/</id>
    <published>2018-12-19T11:33:07.000Z</published>
    <updated>2018-12-19T11:46:28.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-Promise-用法讲解"><a href="#ES6-Promise-用法讲解" class="headerlink" title="ES6 Promise 用法讲解"></a><a href="https://www.cnblogs.com/whybxy/p/7645578.html" target="_blank" rel="noopener">ES6 Promise 用法讲解</a></h1><blockquote><p>Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。</p></blockquote><p>那就new一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//异步操作</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"执行完成"</span>);</span><br><span class="line">        resolve(<span class="string">"data"</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。</p><p>在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并且调用resolve方法。</p><p>运行代码，会在2秒后输出“执行完成”。注意！我只是new了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'执行完成'</span>);</span><br><span class="line">            resolve(<span class="string">'随便什么数据'</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line">runAsync()</span><br></pre></td></tr></table></figure><p>这时候你应该有两个疑问：1.包装这么一个函数有毛线用？2.resolve(‘随便什么数据’);这是干毛的？</p><p>我们继续来讲。在我们包装好的函数最后，会return出Promise对象，也就是说，执行这个函数我们得到了一个Promise对象。还记得Promise对象上有then、catch方法吧？这就是强大之处了，看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">runAsync().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="comment">//后面可以用传过来的数据做些其他操作</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“随便什么数据”。</p><p>这时候你应该有所领悟了，原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。</p><p>你可能会不屑一顾，那么牛逼轰轰的Promise就这点能耐？我把回调函数封装一下，给runAsync传进去不也一样吗，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'执行完成'</span>);</span><br><span class="line">        callback(<span class="string">'随便什么数据'</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runAsync(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>效果也是一样的，还费劲用Promise干嘛。那么问题来了，有多层回调该怎么办？如果callback也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个callback2，然后给callback传进去吧。而Promise的优势在于，可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。</p><p> <strong>链式操作的用法</strong></p><p>所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">runAsync1()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> runAsync2();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> runAsync3();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样能够按顺序，每隔两秒输出每个异步回调中的内容，在runAsync2中传给resolve的数据，能在接下来的then方法中拿到。运行结果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004311507-221152206.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h2 id="reject的用法"><a href="#reject的用法" class="headerlink" title="reject的用法"></a><strong>reject的用法</strong></h2><p>到这里，你应该对“Promise是什么玩意”有了最基本的了解。那么我们接着来看看ES6的Promise还有哪些功能。我们光用了resolve，还没用reject呢，它是做什么的呢？事实上，我们前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function getNumber()&#123;</span><br><span class="line">    var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">        //做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            var num = Math.ceil(Math.random()*10); //生成1-10的随机数</span><br><span class="line">            if(num&lt;=5)&#123;</span><br><span class="line">                resolve(num);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                reject(&apos;数字太大了&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getNumber()</span><br><span class="line">.then(</span><br><span class="line">    function(data)&#123;</span><br><span class="line">        console.log(&apos;resolved&apos;);</span><br><span class="line">        console.log(data);</span><br><span class="line">    &#125;, </span><br><span class="line">    function(reason, data)&#123;</span><br><span class="line">        console.log(&apos;rejected&apos;);</span><br><span class="line">        console.log(reason);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。</p><p>运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004616257-1024778840.png" alt="img](https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004607960-1156803894.png)或者![img" title="">                </div>                <div class="image-caption">img](https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004607960-1156803894.png)或者![img</div>            </figure><h2 id="catch的用法"><a href="#catch的用法" class="headerlink" title="catch的用法"></a><strong>catch的用法</strong></h2><p>我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调，用法是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getNumber()</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(&apos;resolved&apos;);</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(&apos;rejected&apos;);</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。请看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getNumber()</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(&apos;resolved&apos;);</span><br><span class="line">    console.log(data);</span><br><span class="line">    console.log(somedata); //此处的somedata未定义</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(&apos;rejected&apos;);</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004747147-1508291069.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能。</p><h2 id="all的用法"><a href="#all的用法" class="headerlink" title="all的用法"></a><strong>all的用法</strong></h2><p>Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。我们仍旧使用上面定义好的runAsync1、runAsync2、runAsync3这三个函数，看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br><span class="line">.all([runAsync1(), runAsync2(), runAsync3()])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>用Promise.all来执行，all接收一个数组参数，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。所以上面代码的输出结果就是：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004843491-346782307.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</p><h2 id="race的用法"><a href="#race的用法" class="headerlink" title="race的用法"></a><strong>race的用法</strong></h2><p>all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思。race的用法与all一样，我们把上面runAsync1的延时改为1秒来看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br><span class="line">.race([runAsync1(), runAsync2(), runAsync3()])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这三个异步操作同样是并行执行的。结果你应该可以猜到，1秒后runAsync1已经执行完了，此时then里面的就执行了。结果是这样的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004946022-706413123.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>你猜对了吗？不完全，是吧。在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧再执行。于是再过1秒后，输出了他们结束的标志。</p><p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//请求某个图片资源</span><br><span class="line">function requestImg()&#123;</span><br><span class="line">    var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">        var img = new Image();</span><br><span class="line">        img.onload = function()&#123;</span><br><span class="line">            resolve(img);</span><br><span class="line">        &#125;</span><br><span class="line">        img.src = &apos;xxxxxx&apos;;</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//延时函数，用于给请求计时</span><br><span class="line">function timeout()&#123;</span><br><span class="line">    var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            reject(&apos;图片请求超时&apos;);</span><br><span class="line">        &#125;, 5000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise</span><br><span class="line">.race([requestImg(), timeout()])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>requestImg函数会异步请求一张图片，我把地址写为”xxxxxx”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。运行结果如下：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6-Promise-用法讲解&quot;&gt;&lt;a href=&quot;#ES6-Promise-用法讲解&quot; class=&quot;headerlink&quot; title=&quot;ES6 Promise 用法讲解&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/whybx
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面包屑导航</title>
    <link href="https://tianjiec.top/2018/12/19/%E9%9D%A2%E5%8C%85%E5%B1%91%E5%AF%BC%E8%88%AA/"/>
    <id>https://tianjiec.top/2018/12/19/面包屑导航/</id>
    <published>2018-12-19T11:27:56.000Z</published>
    <updated>2018-12-19T11:32:35.426Z</updated>
    
    <content type="html"><![CDATA[<p>面包屑<a href="https://baike.baidu.com/item/%E5%AF%BC%E8%88%AA" target="_blank" rel="noopener">导航</a>(BreadcrumbNavigation)这个概念来自童话故事”<a href="https://baike.baidu.com/item/%E6%B1%89%E8%B5%9B%E5%B0%94" target="_blank" rel="noopener">汉赛尔</a>和<a href="https://baike.baidu.com/item/%E6%A0%BC%E8%8E%B1%E7%89%B9" target="_blank" rel="noopener">格莱特</a>“，当汉赛尔和格莱特穿过森林时，不小心迷路了，但是他们发现在沿途走过的地方都撒下了面包屑，让这些面包屑来帮助他们找到回家的路。所以，面包屑导航的作用是告诉<a href="https://baike.baidu.com/item/%E8%AE%BF%E9%97%AE%E8%80%85/2774711" target="_blank" rel="noopener">访问者</a>他们目前在网站中的位置以及如何返回。</p><p>主页 &gt;栏目页&gt;文章页面</p><p>小型站点便于优化，可以把主页改成你的关键词，目的是关键词集权于首页。</p><p>关键词&gt;<a href="https://baike.baidu.com/item/%E6%A0%8F%E7%9B%AE%E9%A1%B5" target="_blank" rel="noopener">栏目页</a>&gt;文章页非常清晰，且不存在交叉；否则，面包屑导航的路径</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>1、让用户了解当前所处位置，以及当前页面在整个网站中的位置。</p><p>2、体现了网站的架构层级，能够帮助用户快速学习和了解网站内容和组织方式，从而形成很好的位置感。</p><p>3、提供返回各个层级的快速入口，方便用户操作。</p><p>4、<a href="https://baike.baidu.com/item/Google" target="_blank" rel="noopener">Google</a>已经将面包屑导航整合到搜索结果里面，因此优化面包屑导航每个层级的名称，多使用关键字，都可以实现SEO优化。面包屑路径，对于提高用户体验来说，是很有帮助的。</p><p>5、方便用户，面包屑主要用于为用户提供导航一个网站的次要方法，通过为一个大型多级网站的所有页面提供面包屑路径，用户可以更容易的定位到上一次目录，引导用户通行；</p><p>6、减少返回到上一级页面的点击或操作，不用使用浏览器的“返回”按钮或网站的主要导航来返回到上一级页面；</p><p>7、不用常常占用屏幕空间，因为它们通常是水平排列以及简单的样式，面包屑路径不会占用页面太多的空间。这样的好处是，从内容过载方面来说，他们几乎没有任何负面影响；</p><p>8、降低<a href="https://baike.baidu.com/item/%E8%B7%B3%E5%87%BA%E7%8E%87" target="_blank" rel="noopener">跳出率</a>，面包屑路径会是一个诱惑首次访问者在进入一个页面后去浏览这个网站的非常好的方法。比如说，一个用户通过谷歌搜索到一个页面，然后看到一个面包屑路径，这将会诱使用户点击上一级页面去浏览感兴趣的相关主题。这样，从而，可以降低网站的总体跳出率。</p><p>9、有利于百度蜘蛛对网站的抓取，蜘蛛直接沿着那个链走就可以了，很方便。</p><p>10、面包屑有利于网站<a href="https://baike.baidu.com/item/%E5%86%85%E9%93%BE" target="_blank" rel="noopener">内链</a>的建设，用面包屑大大增加了网站的内部连接，提高用户体验。</p><h3 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h3><p>虽然眼下很多网站都流行使用面包屑导航，但是并不是所有的网站都适用。符合下面两个条件的网站才适合使用面包屑导航。1、层级较深的网站，面包屑导航适合层级较深的网站，如果只有一级分类的话，通过主导航就可以起到快速定位的作用。比如“<a href="https://baike.baidu.com/item/%E8%B1%86%E7%93%A3%E7%BD%91" target="_blank" rel="noopener">豆瓣网</a>”类型扁平构架的网站就没有使用面包屑导航。2、独立不交叉的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%AB%99%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">网站结构</a>，由于面包屑网站导航路径是线性结构的，因此网站内容必须划分的非常清晰，且不存在交叉；否则，面包屑导航的路径就不是唯一的，同一分类可能出现在不同的路径中，让用户感到困惑。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>编辑</p><p>一、基于位置的面包屑导航</p><p>这种类型是最常见的。这种类型的面包屑导航可以很好的指出当前页面与整个站点的层次结构。这种面包屑导航可以显示当前页面的前一个页面或者目录的<a href="https://baike.baidu.com/item/%E9%93%BE%E6%8E%A5" target="_blank" rel="noopener">链接</a>。可以使访客了解自己的位置，以及可以更快的找到自己想要到达的页面。可以很好的提高用户的友好体验。</p><p>二、基于属性的面包屑导航</p><p>这种面包屑导航最常出现在电子商务站点。这种面包屑导航可以很好的指出当前页面内产品的其他属性或者类别。对于一个产品来说，所具有的属性往往不只有一种，而通过这种面包屑导航可以给消费者一个更加直观的了解。</p><p>三、基于路径的面包屑导航</p><p>这种面包屑导航是最不常见到的。这种面包屑导航和上文所说的童话故事类型很像。他们可以显示访客在到达页面前所访问过的<a href="https://baike.baidu.com/item/%E7%BD%91%E9%A1%B5" target="_blank" rel="noopener">网页</a>的链接。这种面包屑导航不是很受欢迎，因为他们的功能基本上是和前进和后退的按钮是一样的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面包屑&lt;a href=&quot;https://baike.baidu.com/item/%E5%AF%BC%E8%88%AA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;导航&lt;/a&gt;(BreadcrumbNavigation)这个概念来自童话故事”&lt;a hre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="https://tianjiec.top/2018/12/18/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://tianjiec.top/2018/12/18/面试题/</id>
    <published>2018-12-18T01:21:11.000Z</published>
    <updated>2018-12-21T01:51:13.222Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？"><a href="#1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？" class="headerlink" title="1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？"></a>1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？</h4><p>IE：trident内核</p><p>Firefox：gecko内核</p><p>Safari：webkit内核</p><p>Opera：以前是presto内核，现在改用Google的Chrome的blink内核</p><p>Chrome：blink（基于webkit，Google与Opera共同开发）</p><h4 id="2、每个HTML文件里开头都有一个很重要的东西，Doctype，知道这是干什么的吗？"><a href="#2、每个HTML文件里开头都有一个很重要的东西，Doctype，知道这是干什么的吗？" class="headerlink" title="2、每个HTML文件里开头都有一个很重要的东西，Doctype，知道这是干什么的吗？"></a>2、每个HTML文件里开头都有一个很重要的东西，Doctype，知道这是干什么的吗？</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE&gt;</span> 声明于文档中的最前面的位置，处于<span class="tag">&lt;<span class="name">html</span>&gt;</span> 标签之前。此标签可告知浏览器文档使用哪种HTML 或 XHTML 规范。（重点：告诉浏览器按照何种规范解析页面）</span><br></pre></td></tr></table></figure><h4 id="3、Quirks-模式-是什么？-他和Standards模式有什么区别"><a href="#3、Quirks-模式-是什么？-他和Standards模式有什么区别" class="headerlink" title="3、Quirks 模式 是什么？ 他和Standards模式有什么区别"></a>3、Quirks 模式 是什么？ 他和Standards模式有什么区别</h4><p>从IE6开始，引入了Standards模式， 标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。</p><p>在IE6之前 CSS 还不够成熟， 所以 IE5 等之前的浏览器 对 CSS 的支持很差， IE6将对CSS提供更好的支持，然而这时的问题来了，因为有很多页面是基于旧的布局方式写的，而如果IE6支持CSS则将令这些页面显示不正常，如果在既保证不破坏现有页面，有提供新的渲染机制呢？</p><p>在写程序的时候我们也会经常遇到这样的问题，如何保证原来的接口不变，有提供更强大的功能，尤其是新功能不兼容旧功能的时候。 遇到这样的问题是一个常见的做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数不为真时，就是使用旧功能，这样就能不破坏原有程序，又提供新功能。IE刘也是类似这样做的，它将DTD当成了这个参数，就意味着这个页面都将采用CSS支持更好的布局，而如果没有，则将采用兼容之前的布局方式。 这就是Quirks模式（怪癖模式，诡异模式， 怪异模式）。</p><p>区别：</p><p>总体会有布局、 样式解析和脚本执行这三方面的区别。</p><p>盒模型：</p><p>在W3C标准中，如果设置了一个元素的宽和高，指的是元素内容的宽度和高度，而在Quirks模式下。IE的宽度和高度还包含了padding和border。</p><p>设置行内元素的高度：</p><p>在Standards 模式下，给<span>等行内元素设置width和height都不会生效，而在quirks模式下，则会生效。</span></p><p>设置百分比的高度：在standards模式下， 一个元素的高度石油其包含的元素内容来决定的，如果父元素没有设置百分比高度，子元素设置一个百分比高度是无效的。</p><p>margin：0 auto设置水平居中：使用margin:0 auto 在standards模式下 可以使元素水平居中，但在quirks 模式下会失效</p><p>（还有很多，答出什么不重要，关键是看他答出的这些是不是自己经验遇到的，还是说都是看文章看的，甚至完全不知道。）</p><h4 id="4、div-css布局较table布局有什么优点？"><a href="#4、div-css布局较table布局有什么优点？" class="headerlink" title="4、div+css布局较table布局有什么优点？"></a>4、div+css布局较table布局有什么优点？</h4><p>改版的时候更方便  是要改css文件。</p><p>页面加载的速度更快、结构化清晰、页面显示简洁。</p><p>表现与结构相分离；</p><p>易于优化（seo）搜索引擎更友好，排名更靠前。</p><h4 id="5、img的alt-与-title-有何异同？-strong-与-em-的异同？"><a href="#5、img的alt-与-title-有何异同？-strong-与-em-的异同？" class="headerlink" title="5、img的alt 与 title 有何异同？ strong 与 em 的异同？"></a>5、img的alt 与 title 有何异同？ strong 与 em 的异同？</h4><p>a: alt（alt text）： 为了能显示图像、窗体或applets的用户代理（UA），alt属性用来指定替换的文字。</p><p>替换文字的语言用lang属性来决定。（在IE浏览器下会在没有title时把 alt 当成 tool tip 显示）</p><p>title（tool tip）：该属性为设置该属性的元素提供建议性的信息。</p><p>strong：粗体强调标签，强调，表示内容的重要性；</p><p>em：斜体强调标签，更强烈强调，表示内容强调点；</p><h4 id="6、你能描述一下渐进增强和优雅降级之间的不同吗？"><a href="#6、你能描述一下渐进增强和优雅降级之间的不同吗？" class="headerlink" title="6、你能描述一下渐进增强和优雅降级之间的不同吗？"></a>6、你能描述一下渐进增强和优雅降级之间的不同吗？</h4><p><strong>渐进增强</strong>： progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后在针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p><p><strong>优雅降级</strong>：graceful degradation ： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</p><p><strong>区别：</strong>优雅降级是从复杂的现状开始的，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</p><p><strong>优雅降级</strong>观点</p><p>优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为过时 或有功能缺失的浏览器下的测试安排在开发周期的最后阶段，并把测试对象限定为主流浏览器 （如IE、Mozilla等）的前一个版本。</p><p>在这种设计规范下，旧版本的浏览器被认为仅能提供“简陋却无妨（poor ，but passable）”的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于他们并非我们所关注的焦点，因此除了修复较大的错误之外，其他的差异将被直接忽略。</p><p><strong>渐进增强</strong>观点</p><p>渐进增强观点则认为应关注内容本身。</p><p>内容使我们创建网站的诱因。有的网站展示它，有的网站收集他，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p><p>那么问题来了。现在产品经理看到IE6,7,8网页效果相对高版本现代浏览器少了很多圆角，阴影（CSS3），要求兼容（使用图片背景，放弃CSS3），你会如何说服他？</p><h4 id="7、为什么利用多个域名来存储网站资源会更有效？"><a href="#7、为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="7、为什么利用多个域名来存储网站资源会更有效？"></a>7、为什么利用多个域名来存储网站资源会更有效？</h4><p>CDN缓存更方便</p><p>突破浏览器并发限制</p><p>节约cookie带宽</p><p>节约主域名的连接数，优化页面响应速度</p><p>防止不必要的安全问题</p><h4 id="8、请谈一下你对网页标准和标准定义机构重要性的理解。"><a href="#8、请谈一下你对网页标准和标准定义机构重要性的理解。" class="headerlink" title="8、请谈一下你对网页标准和标准定义机构重要性的理解。"></a>8、请谈一下你对网页标准和标准定义机构重要性的理解。</h4><p>网页标准和标准定制机构都是为了让web发展的更健康，开发者遵循统一的标准，降低开发难度，开发成本，SEO也会更好做，也不会因为滥用代码而导致各种BUG、安全问题，最终提高网站的易用性。</p><h4 id="9、请你描述一下cookies，sessionStorage和localStorage的-区别"><a href="#9、请你描述一下cookies，sessionStorage和localStorage的-区别" class="headerlink" title="9、请你描述一下cookies，sessionStorage和localStorage的    区别"></a>9、请你描述一下cookies，sessionStorage和localStorage的    区别</h4><p>sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动去删除数据，否则数据是永远不会过期的。</p><p>web storage 和 cookie 的区别</p><p>web storage 的概念和 cookie 相似，区别是它是为了更大容量存储设计的。cookie的大小是受限制的，而且没刺激你请求一个新的页面的时候cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可跨域调用。</p><p>除此之外，webstorage拥有setitem，getitem，removeitem，clear等方法， 不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在， 而Web Storage仅仅是为了本地存储数据而生的。</p><h4 id="10、简述下src和href的区别"><a href="#10、简述下src和href的区别" class="headerlink" title="10、简述下src和href的区别"></a>10、简述下src和href的区别</h4><p>src用于替换当前元素，href用于在当前文档引用资源之间确认联系。</p><p>src是 source 的缩写， 指向外部资源的位置， 指向的内容将会嵌入到文档中但钱标签所在的位置，在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src = &quot;js.js&quot;&gt; &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当浏览器解析到该元素时，会暂停其它资源的下载和处理，直到将该元素资源加载、编译、执行完毕，图片和框架等元素也是如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。</p><p>href是Hypertext的缩写 reference的缩写， 指向网络资源所在的位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href= &quot;common.css&quot; rel=&quot;stylesheet&quot; /&gt;</span><br></pre></td></tr></table></figure><p>name浏览器会识别该文档为css文件，就会并行下载资源并且不会停止当前文档的处理。这也是为什么建议用link方式加载css，而不是使用@import方式。</p><h4 id="11、知道的网页制作用到的图片格式都有哪些"><a href="#11、知道的网页制作用到的图片格式都有哪些" class="headerlink" title="11、知道的网页制作用到的图片格式都有哪些"></a>11、知道的网页制作用到的图片格式都有哪些</h4><p>png-8，png-24，jpeg，gif，svg。</p><p>Webp</p><p>Webp：Webp格式，谷歌（google）开发的一种旨在加快图片速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook、eBay等知名网站已开始测试并使用Webp格式。</p><p>在质量相同的情况下，Webp格式图像体积要比JPEG格式图像小40%。</p><h4 id="12、知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？"><a href="#12、知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？" class="headerlink" title="12、知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？"></a>12、知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？</h4><p>微格式（Microformats）是一种让机器可读的语义化XHML词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式。</p><p>优点：将智能数据添加到网页上，让网页内容在搜索引擎结果页面可以显示额外的提示。</p><h4 id="13、在css-js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理。"><a href="#13、在css-js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理。" class="headerlink" title="13、在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理。"></a>13、在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理。</h4><p>dns缓存，dcn缓存，浏览器缓存，服务器缓存。</p><h4 id="14、一个页面上有大量的图片（大型电商网站），加载很慢，有哪些方法优化这些图片的加载，给用户更好的体验。"><a href="#14、一个页面上有大量的图片（大型电商网站），加载很慢，有哪些方法优化这些图片的加载，给用户更好的体验。" class="headerlink" title="14、一个页面上有大量的图片（大型电商网站），加载很慢，有哪些方法优化这些图片的加载，给用户更好的体验。"></a>14、一个页面上有大量的图片（大型电商网站），加载很慢，有哪些方法优化这些图片的加载，给用户更好的体验。</h4><p>图片懒加载，在页面上的未可视域可添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离 ，如果前者小于后者，优先加载。</p><p>如果为幻灯片、相册等，可以使用图片预加载技术，将当前战士的前一张和后一张优先下载。</p><p>如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。</p><p>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</p><p>如果图片展示区域小于图片的真是大小，则因在服务器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？&quot;&gt;&lt;a href=&quot;#1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么？&quot; class=&quot;headerlink&quot; title=&quot;1、你做的页面在那些浏览器测试过？这些浏览器的内核分别是什么
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>夜、萤火虫和你</title>
    <link href="https://tianjiec.top/2018/12/14/%E5%A4%9C%E3%80%81%E8%90%A4%E7%81%AB%E8%99%AB%E5%92%8C%E4%BD%A0/"/>
    <id>https://tianjiec.top/2018/12/14/夜、萤火虫和你/</id>
    <published>2018-12-14T12:51:36.000Z</published>
    <updated>2018-12-14T13:06:22.092Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"音乐/夜、萤火虫和你.mp3"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>  <span class="attr">autoplay</span> <span class="attr">preload</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>18/11/7</title>
    <link href="https://tianjiec.top/2018/11/07/18-11-7/"/>
    <id>https://tianjiec.top/2018/11/07/18-11-7/</id>
    <published>2018-11-07T03:48:52.000Z</published>
    <updated>2018-11-07T04:52:38.330Z</updated>
    
    <content type="html"><![CDATA[<p>每当我想好好学习<br>总有人和我说回去睡吧别学了<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://qzonestyle.gtimg.cn/qzone/em/e295.gif" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><br>今天又是爱我熙哥的一天</p><p><img src="http://p1lzepiq0.bkt.clouddn.com/%E7%BD%97%E4%BA%91%E7%86%99.jpg" width="280px" height="400px"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每当我想好好学习&lt;br&gt;总有人和我说回去睡吧别学了&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay
      
    
    </summary>
    
    
  </entry>
  
</feed>
