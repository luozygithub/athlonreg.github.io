<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>luozy&#39;s Blog</title>
  
  <subtitle>Inflexible thinking, bad humor</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.luozy.top/"/>
  <updated>2018-11-06T03:52:11.926Z</updated>
  <id>http://www.luozy.top/</id>
  
  <author>
    <name>luozy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP、UDP</title>
    <link href="http://www.luozy.top/2018/11/06/TCP%E3%80%81UDP/"/>
    <id>http://www.luozy.top/2018/11/06/TCP、UDP/</id>
    <published>2018-11-06T03:51:58.000Z</published>
    <updated>2018-11-06T03:52:11.926Z</updated>
    
    <content type="html"><![CDATA[<h4 id="安装、阿帕奇-MySQL-后台-PHP-MySQL"><a href="#安装、阿帕奇-MySQL-后台-PHP-MySQL" class="headerlink" title="安装、阿帕奇+MySQL  后台  PHP + MySQL"></a>安装、阿帕奇+MySQL  后台  PHP + MySQL</h4><p>如果你想要磁盘的某一部分，想要被别人能访问。只有你电脑上安装的服务端程序，你的磁盘这部分才能被别人所访问。</p><h4 id="PHPnow-阿帕奇-MySQL"><a href="#PHPnow-阿帕奇-MySQL" class="headerlink" title="PHPnow = 阿帕奇+MySQL;"></a>PHPnow = 阿帕奇+MySQL;</h4><p>PHPnow/htdocs 这台电脑上运行服务器的根目录 对外开放</p><p>【注】1、大家的cookie代码，要放在这个文件夹内。</p><p>​           2、<a href="http://10.9.161.62/index.html" target="_blank" rel="noopener">http://10.9.161.62/index.html</a></p><p>127.0.0.1   本机访问当前电脑的服务器。  PHPnow/htdocs</p><p>localhost   本机访问当前电脑的服务器。  PHPnow/htdocs</p><p>10.9.161.131  </p><p>默认会去加载index开头的文件：index.html  index.jsp  index.php</p><p>PHPnow/htdocs/index.html</p><h3 id="一、TCP、UDP协议"><a href="#一、TCP、UDP协议" class="headerlink" title="一、TCP、UDP协议"></a>一、TCP、UDP协议</h3><p>1、TCP传输  面向连接传输协议</p><p>​    1）先建立连接</p><p>​    2）传输数据</p><p>​    3）断开连接</p><p>通信协议是什么？</p><p>​    我们在公路上需要遵守交通法则，同样数据在网络上进行传输我们也得遵守数据传输的规则。</p><p>​    在数据传输的规则，也就是协议中，最常见的协议就是TCP和UDP协议。其中http协议就是TCP实现的。</p><p><strong>TCP协议概念：</strong></p><p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p>1、账目密码</p><p>2、PC端网络</p><p>【注】如果需要传输，就先建立链接，开始传输数据，当数据传输结束，就直接断开链接。如果再要进行传输，重新建立链接。</p><p>好处：安全，准确性高，面向链接</p><p>坏处：TCP协议比较耗费时间，耗费资源。</p><p><img src="https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234824085-667046040.png" alt="img"></p><p><a href="https://www.cnblogs.com/qishui/p/5428938.html" target="_blank" rel="noopener">https://www.cnblogs.com/qishui/p/5428938.html</a></p><p><strong>一张图了解TCP/IP五层网络模型</strong></p><p><img src="https://img-blog.csdn.net/20170317150321773?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhzaHVsaW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p><strong>UDP概念：</strong></p><p>UDP 是User Datagram Protocol的简称，  参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p><p>1、不连接，直接传</p><p>2、不安全，容易丢。</p><p>及时性要求非常高，数据完整度要求不高：</p><p>及时的语音视频聊天软件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;安装、阿帕奇-MySQL-后台-PHP-MySQL&quot;&gt;&lt;a href=&quot;#安装、阿帕奇-MySQL-后台-PHP-MySQL&quot; class=&quot;headerlink&quot; title=&quot;安装、阿帕奇+MySQL  后台  PHP + MySQL&quot;&gt;&lt;/a&gt;安装、阿帕奇+
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ECMA5、6</title>
    <link href="http://www.luozy.top/2018/11/06/ECMA5%E3%80%816/"/>
    <id>http://www.luozy.top/2018/11/06/ECMA5、6/</id>
    <published>2018-11-06T01:20:04.000Z</published>
    <updated>2018-11-06T03:45:47.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、this关键字详解"><a href="#一、this关键字详解" class="headerlink" title="一、this关键字详解"></a>一、this关键字详解</h2><p><strong>改变this指向的方法call、apply、bind深度分析</strong></p><h3 id="1、this的使用场景"><a href="#1、this的使用场景" class="headerlink" title="1、this的使用场景"></a>1、this的使用场景</h3><h4 id="1-1-this的记忆规则"><a href="#1-1-this的记忆规则" class="headerlink" title="1.1 this的记忆规则"></a>1.1 this的记忆规则</h4><blockquote><p>​    每一个函数中，都有一个内置的变量this，这个this中存储着当前函数的主人，所以，要知道this是谁，就要通过上下文分析，当前函数的主人是谁。this永远存储的是当前函数的主人。</p></blockquote><h4 id="1-2全局函数中指向window"><a href="#1-2全局函数中指向window" class="headerlink" title="1.2全局函数中指向window"></a>1.2全局函数中指向window</h4><p>var num= 10；//num也属于window相当于window.num</p><p>function show(){</p><p>​    alert(this);//输出window，此处show相当于window.show（）</p><p>}</p><h4 id="1-3对象方法指向该对象"><a href="#1-3对象方法指向该对象" class="headerlink" title="1.3对象方法指向该对象"></a>1.3对象方法指向该对象</h4><p>var obj = {</p><p>​    showName ： function(){</p><p>​    }</p><p>}</p><h4 id="1-4事件绑定中，指向目标对象"><a href="#1-4事件绑定中，指向目标对象" class="headerlink" title="1.4事件绑定中，指向目标对象"></a>1.4事件绑定中，指向目标对象</h4><p>window.onload = function(){</p><p>​    btn.onclick = function(){<br>​    }</p><p>}</p><h3 id="2、call、apply、bind方法区别详解"><a href="#2、call、apply、bind方法区别详解" class="headerlink" title="2、call、apply、bind方法区别详解"></a>2、call、apply、bind方法区别详解</h3><p>【注】这三个方法只会改变当前方法的this对象</p><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><p>格式：函数名.call(this指向的对象，本应该传的参数);</p><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>格式：函数.apply(this指向的对象，[愿所有的参数]);</p><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>格式：函数名.bind(this指向的对象)</p><p>作用：是一个</p><p>返回值：是一个预设好this指向的原函数</p><h4 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>);</span><br><span class="line">    alert(num1, + <span class="string">','</span> +num2);</span><br><span class="line">&#125;</span><br><span class="line">show.call(<span class="string">"call"</span>, <span class="number">30</span>, <span class="number">40</span>);<span class="comment">//this为call</span></span><br><span class="line">show();<span class="comment">//this 为[object Window]</span></span><br><span class="line"></span><br><span class="line">show.apply(<span class="string">"apply"</span>, [<span class="number">50</span>, <span class="number">60</span>]);</span><br><span class="line">show();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindF = show.bind(<span class="string">"bind"</span>);</span><br><span class="line">bindF();</span><br><span class="line">show();</span><br><span class="line">show.bind(<span class="string">"bind"</span>)();</span><br></pre></td></tr></table></figure><p><strong>修改函数本身</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oBtn = <span class="built_in">document</span>.getElementById(<span class="string">"btn1"</span>);</span><br><span class="line">    <span class="comment">/*oBtn.onclick = function()&#123;</span></span><br><span class="line"><span class="comment">btnClick.call('hello');</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*oBtn.onclick = function()&#123;</span></span><br><span class="line"><span class="comment">btnClick.apply('hello');</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//给按钮赋值一个预设号this指向的函数。</span></span><br><span class="line">    oBtn.onclick = btnClick.bind(<span class="string">"bind"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h1><p>功能：就是用来声明变量的</p><p>【注】使用let关键字声明变量</p><p>​    1、不能重复声明变量</p><p>​    2、let关键字声明变量。只要遇到大括号就会形成作用域</p><p>【区分】</p><p>​    1、var声明的变量是，必须是函数的大括号才能形成作用域；</p><p>​    2、let关键字声明变量，只要遇到大括号，就会生成作用域。</p><p>​        if    for    switch</p><p>​    【注】我们吧这个范围更小的作用域称为跨块级作用域</p><p>例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aBtns = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"button"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; aBtns.length; i++)&#123;</span><br><span class="line">        aBtns[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用let就会生成多个作用域i对这个作用域里面的i不影响，这些i= 0 1 2 3 4....</span></span><br><span class="line"><span class="comment">//如果用var i最终都会变成5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、this关键字详解&quot;&gt;&lt;a href=&quot;#一、this关键字详解&quot; class=&quot;headerlink&quot; title=&quot;一、this关键字详解&quot;&gt;&lt;/a&gt;一、this关键字详解&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;改变this指向的方法call、apply、bind
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js控制style</title>
    <link href="http://www.luozy.top/2018/11/03/js%E6%8E%A7%E5%88%B6style/"/>
    <id>http://www.luozy.top/2018/11/03/js控制style/</id>
    <published>2018-11-03T06:58:42.000Z</published>
    <updated>2018-11-03T06:58:56.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js控制style样式"><a href="#js控制style样式" class="headerlink" title="js控制style样式"></a><a href="https://www.cnblogs.com/wdz1/p/7562975.html" target="_blank" rel="noopener">js控制style样式</a></h1><p>1、行内样式获取打印出来</p><p>2、内嵌和外链的获取不了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;width:200px;height:200px; background: red;&quot;&gt;&lt;/div&gt;</span><br><span class="line"> var box=document.getElementsByTagName(&quot;div&quot;)[0];</span><br><span class="line"> console.log( box.style.width)</span><br></pre></td></tr></table></figure><p>3、style属性是对象（数组对象）</p><p>4、可以索引值取值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(box.style[0]);</span><br></pre></td></tr></table></figure><p>5、值是字符串，没有设置值得是“” 空</p><p>6、cssText=”字符串形式的样式” 可以一次性添加多个样式，修改原有的内嵌样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box.style.cssText=&quot;border:5px solid black; width:400px; height:200px;&quot;</span><br></pre></td></tr></table></figure><p>7、opacity 透明度（子元素，文本都会有透明的样式）不兼容ie6-7-8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> box.style.opacity=&quot;0.2&quot; （值0-1）</span><br></pre></td></tr></table></figure><p>8、alpha(opacity=20)透明度（只有自己透明）兼容ie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box.style.filter=&quot;alpha(opacity=20)&quot; //百分数</span><br></pre></td></tr></table></figure><p>9、获取body </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var body=document.body;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;js控制style样式&quot;&gt;&lt;a href=&quot;#js控制style样式&quot; class=&quot;headerlink&quot; title=&quot;js控制style样式&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/wdz1/p/7562975.html&quot;
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://www.luozy.top/2018/11/02/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.luozy.top/2018/11/02/正则表达式/</id>
    <published>2018-11-02T12:33:11.000Z</published>
    <updated>2018-11-05T03:22:18.686Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一、正则表达式的概念"><a href="#一、正则表达式的概念" class="headerlink" title="一、正则表达式的概念"></a>一、正则表达式的概念</h3><blockquote><p>假设用户需要在HTML表单中填写姓名、地址、出生日期等。那么在将表单提交到服务器进一步处理前，JavaScript程序会检查表单以确认用户确实输入了信息并且这些信息是符合要求的</p><h3 id="正则表达式，-super-string。"><a href="#正则表达式，-super-string。" class="headerlink" title="正则表达式， super string。"></a>正则表达式， super string。</h3><p>​    正则表达式（regular expression）是一个描述字符模式的对象。</p><p>ECMAScript的RegExp类 表示正则表达式，而Sreing 和 正则表达式都定义了进行强大的【模式匹配】和【文本检索】与【替换】的函数。</p></blockquote><h3 id="二、创建正则表达式的方式"><a href="#二、创建正则表达式的方式" class="headerlink" title="二、创建正则表达式的方式"></a>二、创建正则表达式的方式</h3><blockquote><p>创建正则表达式和创建字符串类似，创建正则表达式提供了两种方法，一种是采用new运算符，另一种是采用字面量的方式。</p></blockquote><p>1、两种创建方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'box'</span>);<span class="comment">//第一个参数字符串</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'box'</span>, <span class="string">'ig'</span>);<span class="comment">//第二个参数可选模式修饰符</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="regexp">/box/</span>;<span class="comment">//直接用两个反斜杠创建</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="regexp">/box/ig</span>; <span class="comment">//在第二个反斜杠后面加上模式修饰符</span></span><br></pre></td></tr></table></figure><h4 align="center">模式修饰符的可选参数</h4><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:center">忽略大小写</td></tr><tr><td style="text-align:center">g</td><td style="text-align:center">全局匹配</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">多行匹配</td></tr></tbody></table><p>2、正则表达式对象的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用 new 运算符的 test 方法示例*/</span></span><br><span class="line"><span class="keyword">var</span> pattern= newRegExp(<span class="string">'box'</span>, <span class="string">'i'</span>); <span class="comment">//创建正则模式，不区分大小写</span></span><br><span class="line"><span class="keyword">var</span> str =<span class="string">'This is a Box!'</span>; <span class="comment">//创建要比对的字符串</span></span><br><span class="line">alert(pattern.test(str)); <span class="comment">//通过 test()方法验证是否匹配</span></span><br><span class="line"><span class="comment">/*使用字面量方式的 test 方法示例*/</span></span><br><span class="line"><span class="keyword">var</span> pattern= <span class="regexp">/box/i</span>; <span class="comment">//创建正则模式，不区分大小写</span></span><br><span class="line"><span class="keyword">var</span> str =<span class="string">'This is a Box!'</span>;</span><br><span class="line">alert(pattern.test(str));</span><br><span class="line"><span class="comment">/*使用一条语句实现正则匹配*/</span></span><br><span class="line">alert(<span class="regexp">/box/i</span>.test(<span class="string">'This is aBox!'</span>)); <span class="comment">//模式和字符串替换掉了两个变量</span></span><br><span class="line"><span class="comment">/*使用 exec 返回匹配数组*/</span></span><br><span class="line"><span class="keyword">var</span> pattern= <span class="regexp">/box/i</span>;</span><br><span class="line"><span class="keyword">var</span> str =<span class="string">'This is a Box!'</span>;</span><br><span class="line">alert(pattern.exec(str)); <span class="comment">//匹配了返回数组，否则返回 nullc 方法还</span></span><br></pre></td></tr></table></figure><h4 align="center">RegExp对象方法</h4><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">test</td><td style="text-align:center">在字符串中测试模式匹配，返回true或false</td></tr><tr><td style="text-align:center">exec</td><td style="text-align:center">在字符串中执行匹配搜索，返回结束数组</td></tr></tbody></table><p><strong>【注】正则表达式就是一个增强版的字符串</strong></p><h3 id="三、字符串中使用正则表达式的方法"><a href="#三、字符串中使用正则表达式的方法" class="headerlink" title="三、字符串中使用正则表达式的方法"></a>三、字符串中使用正则表达式的方法</h3><p>除了test() 和exec()方法，String对象也提供了4个使用正则表达式的方法。</p><h4 align="center">String对象中的正则表达式方法</h4><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">match(patten)</td><td style="text-align:center">返回pattern中的子串或null</td></tr><tr><td style="text-align:center">replace(pattern,replacement)</td><td style="text-align:center">用replacement替换pattern</td></tr><tr><td style="text-align:center">search(pattern)</td><td style="text-align:center">返回字符串中pattern开始位置</td></tr><tr><td style="text-align:center">split(pattern)</td><td style="text-align:center">返回字符串指定pattern拆分的数组</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用 match 方法获取获取匹配数组*/</span></span><br><span class="line"><span class="keyword">var</span> pattern= <span class="regexp">/box/ig</span>; <span class="comment">//全局搜索</span></span><br><span class="line"><span class="keyword">var</span> str =<span class="string">'This is a Box!，That is a Box too'</span>;</span><br><span class="line">alert(str.match(pattern)); <span class="comment">//匹配到两个 Box,Box </span></span><br><span class="line">alert(str.match(pattern).length); <span class="comment">//获取数组的长度</span></span><br><span class="line"><span class="comment">/*使用 search 来查找匹配数据*/</span></span><br><span class="line"><span class="keyword">var</span> pattern= <span class="regexp">/box/ig</span>;</span><br><span class="line"><span class="keyword">var</span> str =<span class="string">'This is a Box!，That is a Box too'</span>;</span><br><span class="line">alert(str.search(pattern)); <span class="comment">//查找到返回位置，否则返回-1</span></span><br><span class="line">PS：因为 search 方法查找到即返回，也就是说无需 g 全局。</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用 replace 替换匹配到的数据*/</span></span><br><span class="line"><span class="keyword">var</span> pattern= <span class="regexp">/box/ig</span>;</span><br><span class="line"><span class="keyword">var</span> str =<span class="string">'This is a Box!，That is a Box too'</span>; </span><br><span class="line">alert(str.replace(pattern,<span class="string">'Tom'</span>)); <span class="comment">//将 Box 替换成了 Tom</span></span><br><span class="line"><span class="comment">/*使用 split 拆分成字符串数组*/</span></span><br><span class="line"><span class="keyword">var</span> pattern= <span class="comment">//ig;</span></span><br><span class="line"><span class="keyword">var</span> str =<span class="string">'This is a Box!，That is a Box too'</span>;</span><br><span class="line">alert(str.split(pattern)); <span class="comment">//将空格拆开分组成数组</span></span><br></pre></td></tr></table></figure><h3 id="四、元字符"><a href="#四、元字符" class="headerlink" title="四、元字符"></a>四、元字符</h3><blockquote><p>正则表达式元字符包含特殊含义的字符。他们有一些特殊功能，可以控制匹配模式的方式。</p></blockquote><h4 align="center">字符类：单个字符串和数字</h4><table><thead><tr><th style="text-align:center">元字符/元符号</th><th style="text-align:center">匹配情况</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">匹配出换行字符外的任意字符</td></tr><tr><td style="text-align:center">[a-z 0-9]</td><td style="text-align:center">匹配括号中的字符集中的任意字符</td></tr><tr><td style="text-align:center">[^a-z 0-9]</td><td style="text-align:center">匹配任意不在括号中的字符集中的字符</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配数字</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:center">匹配非数字同[^0-9]</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配字母和数字及_</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:center">匹配非字母和数字及_</td></tr></tbody></table><h4 align="center">字符类：空白字符</h4><table><thead><tr><th style="text-align:center">元字符/元符号</th><th style="text-align:center">匹配情况</th></tr></thead><tbody><tr><td style="text-align:center">\0</td><td style="text-align:center">匹配null字符</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配空格字符</td></tr><tr><td style="text-align:center">\f</td><td style="text-align:center">匹配进制字符</td></tr><tr><td style="text-align:center">\n</td><td style="text-align:center">匹配换行符</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:center">匹配回车符</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:center">匹配制表符</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配空白字符、空格、制表符和换行符</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:center">匹配非空字符串</td></tr></tbody></table><h4 align="center">字符类：锚字符</h4><table><thead><tr><th style="text-align:center">元字符/元符号</th><th style="text-align:center">匹配情况</th></tr></thead><tbody><tr><td style="text-align:center">^</td><td style="text-align:center">行首匹配</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">行尾匹配</td></tr><tr><td style="text-align:center">\A</td><td style="text-align:center">只有匹配字符串开始处</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配单词边界，词在[]内时无效</td></tr><tr><td style="text-align:center">\B</td><td style="text-align:center">匹配飞单词边界</td></tr><tr><td style="text-align:center">\G</td><td style="text-align:center">匹配当前搜索的开始位置</td></tr><tr><td style="text-align:center">\Z</td><td style="text-align:center">匹配字符串</td></tr><tr><td style="text-align:center">\z</td><td style="text-align:center">只匹配字符串结束处</td></tr></tbody></table><h4 align="center">字符类：重复字符</h4><blockquote><p>x 代表单个字符或元字符</p></blockquote><table><thead><tr><th style="text-align:center">元字符/元符号</th><th style="text-align:center">匹配情况</th></tr></thead><tbody><tr><td style="text-align:center">x？</td><td style="text-align:center">匹配0个或1个x</td></tr><tr><td style="text-align:center">x*</td><td style="text-align:center">匹配0个或多个x</td></tr><tr><td style="text-align:center">x+</td><td style="text-align:center">匹配至少一个x</td></tr><tr><td style="text-align:center">(xyz)+</td><td style="text-align:center">匹配至少一个(xyz)</td></tr><tr><td style="text-align:center">x{m，n}</td><td style="text-align:center">匹配最少m个、最多n个x</td></tr></tbody></table><h4 align="center">字符类：替代字符<br></h4><table><thead><tr><th style="text-align:center">元字符/元符号</th><th style="text-align:center">匹配情况</th></tr></thead><tbody><tr><td style="text-align:center">this\</td><td style="text-align:center">where\</td><td>logo</td><td>匹配this或where或logo中的任意一个</td></tr></tbody></table><p>和元提付重意的字符 如. 要添加转义字符</p><h3 id="五、常用正则"><a href="#五、常用正则" class="headerlink" title="五、常用正则"></a>五、常用正则</h3><p>1、检查邮政编码</p><p>var pattern = /[1-9] ‘[0-9]’{5}/共六位数字，第一位不能为0</p><p>var str = ‘224000’;</p><p>alert(pattern.test(str));</p><p>2、检查文件压缩包</p><p>var pattern =/[\w] + \ .zip|rar|gz/; //\d\w表示所有数字和字母加下划线</p><p>var str = ‘123.zip’</p><p>alert(pattern.test(str));</p><p>3删除多余空格</p><p>var pattern = /\s/g;</p><p>var str = “111 222 333”;</p><p>var result = str.replace(pattern,””);</p><p>alert(result);</p><p>4、删除首位空格</p><p>var pattern = /^\s + /;</p><p>var str = ‘        goo   gle      ‘;</p><p>var result = str.replace(pattern,””)</p><p>pattern = /\s + $/;</p><p>result = result.replace(pattern, “”)</p><p>alert(‘|’ + result + “|”);;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;一、正则表达式的概念&quot;&gt;&lt;a href=&quot;#一、正则表达式的概念&quot; class=&quot;headerlink&quot; title=&quot;一、正则表达式的概念&quot;&gt;&lt;/a&gt;一、正则表达式的概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;假设用户需要在HTML表
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>cookie会话跟踪技术</title>
    <link href="http://www.luozy.top/2018/11/02/cookie%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E6%8A%80%E6%9C%AF/"/>
    <id>http://www.luozy.top/2018/11/02/cookie会话跟踪技术/</id>
    <published>2018-11-02T02:31:12.000Z</published>
    <updated>2018-11-06T04:40:19.284Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p>Cookie，有时也用其复数形式 <a href="https://baike.baidu.com/item/Cookies/187064" target="_blank" rel="noopener">Cookies</a>，指某些网站为了辨别用户身份、进行session跟踪而存储在用户本地终端上的数据（通常经过加密）。</p><h2 id="cookie会话跟踪技术"><a href="#cookie会话跟踪技术" class="headerlink" title="cookie会话跟踪技术"></a>cookie会话跟踪技术</h2><p><strong>什么是会话</strong></p><p>会话指一个终端用户（客户端）与交互系统（服务器）进行通讯的过程</p><p><strong>会话跟踪</strong></p><p>对同一个用户对服务器连接请求和接受响应的监视</p><p><strong>cookie</strong> <strong>会话跟踪技术</strong></p><p>​    打开一个窗口（会话开始），关闭这个窗口会话结束。对同一个用户对服务器的连续的请求和接受响应的监视。</p><h4 id="cookie使用方式"><a href="#cookie使用方式" class="headerlink" title="cookie使用方式"></a>cookie使用方式</h4><p>document.cookie = “字符串”;</p><p>name = value;[expires = date];[path = path];[domain = somewhere.com];[secure]</p><p>name 和 value用户自定义 []内元素为用户自己选用</p><p><strong>为了防止乱码问题：</strong></p><p>可对中文先进行编码在进行存储</p><p>在读中文的时候再解码去读。</p><p>中文 —&gt; 字符 encodeURIComponent()</p><p>字符 —-&gt; 中文 decodeURIComponent();</p><p>utf-8编码：</p><p>一个汉字 相当于三个字符</p><h4 id="1、expires-日期对象"><a href="#1、expires-日期对象" class="headerlink" title="1、expires = 日期对象"></a>1、expires = 日期对象</h4><p>用法：</p><p>设置当前这条cookie过期时间</p><p>如果不去设置的话expires这个键的话，默认为关闭浏览器过期</p><p>获取n天后的某一天</p><p>function numOfDate（num）{</p><p>​    var d = new Date();</p><p>​    var day = d.getDate();</p><p>​     d.setDate(dat + num)</p><p>​    return d;</p><p>}</p><p>ps:</p><p>var d = new Date(0);//1970年. . . . . </p><h4 id="2、path-限制访问路径"><a href="#2、path-限制访问路径" class="headerlink" title="2、path 限制访问路径"></a>2、path 限制访问路径</h4><p>如果不去设置path，默认是当前加载文件路径</p><p>如果存储的cookie路径和访问的cookie路径不一样的话，禁止访问这个cookie</p><h4 id="3、domain-限制访问域名"><a href="#3、domain-限制访问域名" class="headerlink" title="3、domain 限制访问域名"></a>3、domain 限制访问域名</h4><p>document.cookie = “username = 123 ;domain = ” + “localhost”；</p><p>设置cookie的时候，加载文件的域名和域名不一致，设置域名不一致，设置失败</p><h4 id="4、source-安全设置"><a href="#4、source-安全设置" class="headerlink" title="4、source 安全设置"></a>4、source 安全设置</h4><p>如果不设置，任何协议都可以访问cookie</p><p>如果设置，必须是https才能访问cookie</p><h4 id="封装cookie"><a href="#封装cookie" class="headerlink" title="封装cookie"></a>封装cookie</h4><p>//设置cookie</p><p>setCookie()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//name=value;[expires=date];[path=path];[domain=somewhere.com];[secure]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">中文 -&gt; 字符 encodeURIComponent()</span></span><br><span class="line"><span class="comment">字符 -&gt; 中文 decodeURIComponent()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置cookie</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, expires, path, domain, secure</span>)</span>&#123;</span><br><span class="line"><span class="comment">//将name和value转成字符</span></span><br><span class="line"><span class="keyword">var</span> cookieStr = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">"="</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line"><span class="keyword">if</span>(expires)&#123;</span><br><span class="line"><span class="comment">//传入数字，将数字转成对应日期</span></span><br><span class="line">cookieStr += <span class="string">";expires="</span> + numOfDate(expires); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(path)&#123;</span><br><span class="line">cookieStr += <span class="string">";path="</span> + path;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(domain)&#123;</span><br><span class="line">cookieStr += <span class="string">";domain="</span> + domain;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(secure)&#123;</span><br><span class="line">cookieStr += <span class="string">";secure"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.cookie = cookieStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numOfDate</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> day = d.getDate();</span><br><span class="line">d.setDate(day + num);</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setCookie(<span class="string">"漫威英雄"</span>, <span class="string">"钢铁侠"</span>, <span class="number">7</span>);</span><br><span class="line">setCookie(<span class="string">"DC英雄"</span>, <span class="string">"绿灯侠"</span>, <span class="number">30</span>);</span><br><span class="line">setCookie(<span class="string">"变种人"</span>, <span class="string">"凤凰之力"</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// alert(decodeURIComponent(document.cookie));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装传入键name获取对应值value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//漫威英雄=钢铁侠; DC英雄=绿灯侠; 变种人=凤凰之力</span></span><br></pre></td></tr></table></figure><p>//获取cookie</p><p>getCookie()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> cookieStr = <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie);</span><br><span class="line"><span class="comment">//1、先找name开始的下标</span></span><br><span class="line"><span class="keyword">var</span> start = cookieStr.indexOf(name);</span><br><span class="line"><span class="keyword">if</span>(start == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//2、键肯定存在，找出结束的位置</span></span><br><span class="line"><span class="keyword">var</span> end = cookieStr.indexOf(<span class="string">";"</span>, start);</span><br><span class="line"><span class="keyword">if</span>(end == <span class="number">-1</span>)&#123;</span><br><span class="line">end = cookieStr.length;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、通过start和end，将键值对提取出来</span></span><br><span class="line"><span class="keyword">var</span> subStr = cookieStr.substring(start, end);</span><br><span class="line"><span class="comment">//4、用等号进行字符串分割</span></span><br><span class="line"><span class="keyword">var</span> arr = subStr.split(<span class="string">"="</span>);</span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//封装传入键，来获取对应的值</p><p>//删除cookie</p><p>removeCookie()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeCookie</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.cookie = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">"=;expires="</span> + <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">alert(getCookie(<span class="string">"DC英雄"</span>));</span><br><span class="line">removeCookie(<span class="string">"DC英雄"</span>);</span><br><span class="line">alert(getCookie(<span class="string">"DC英雄"</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;cookie&quot;&gt;&lt;a href=&quot;#cookie&quot; class=&quot;headerlink&quot; title=&quot;cookie&quot;&gt;&lt;/a&gt;cookie&lt;/h1&gt;&lt;p&gt;Cookie，有时也用其复数形式 &lt;a href=&quot;https://baike.b
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js兼容写法</title>
    <link href="http://www.luozy.top/2018/11/01/js%E5%85%BC%E5%AE%B9%E5%86%99%E6%B3%95/"/>
    <id>http://www.luozy.top/2018/11/01/js兼容写法/</id>
    <published>2018-11-01T07:50:29.000Z</published>
    <updated>2018-11-01T11:59:31.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、关于获取行外样式"><a href="#1、关于获取行外样式" class="headerlink" title="1、关于获取行外样式"></a>1、关于获取行外样式</h2><h2 id="currentStyle-和-getComputedStyle出现的兼容性问题"><a href="#currentStyle-和-getComputedStyle出现的兼容性问题" class="headerlink" title="currentStyle 和 getComputedStyle出现的兼容性问题"></a>currentStyle 和 getComputedStyle出现的兼容性问题</h2><p>我们都知道通过style不能获取行外样式，当我们需要获取行外样式时：</p><p>我们一般通过这两个方法获取行外样式：</p><p>IE下：</p><p>currentStyle</p><p>Chrome，FireFox：</p><p>getComputedStyle（oDiv，false）；</p><p>兼容两个浏览器的写法：(包含低版本IE6，7)</p><p>function  getStyle(node.styleStr){</p><p>Return node.currentStyle ? Node.currentStyle[styleStr] : getComputedStyle(node)[styleStr];</p><p>}</p><p>调用：</p><p>getStyle（oDiv，’width’）；</p><h2 id="2、关于用“索引”获取字符串每一项-出现的兼容问题："><a href="#2、关于用“索引”获取字符串每一项-出现的兼容问题：" class="headerlink" title="2、关于用“索引”获取字符串每一项 出现的兼容问题："></a>2、关于用“索引”获取字符串每一项 出现的兼容问题：</h2><p>对于字符串也有类似 数组 这样的通过下标索引 获取每一项的值，</p><p>var  str = “abscd;</p><p>alert(str[1]);</p><p>但是低版本的IE不兼容</p><p>兼容方法：str.charAt(i);//全部浏览器兼容</p><h2 id="3、关于DOM中childNodes获取子节点出现的兼容问题"><a href="#3、关于DOM中childNodes获取子节点出现的兼容问题" class="headerlink" title="3、关于DOM中childNodes获取子节点出现的兼容问题"></a>3、关于DOM中childNodes获取子节点出现的兼容问题</h2><p>childNodes:获取子节点</p><p>–IE~8：获取的是元素节点，正常</p><p>–高版本的浏览器：会获取包含空白文本节点以及元素节点</p><p>解决方法：</p><p>上面的childNodes为我们带了的困扰可以由children属性来代替。</p><p>children属性：</p><p>只获取元素节点，不获取文本节点，兼容所有浏览器，</p><p>所以我们在获取子节点时，可用children；</p><p>children获取元素节点</p><p>firstElementChild</p><p>lastElementChild</p><p>nextElementSibling()获取兄弟节点的下一个节点</p><p>.innerHTML与.outerHTML</p><p>区别：一个是内部内容不包含自身标签，outer包含本标签</p><h3 id="childNodes去空白节点"><a href="#childNodes去空白节点" class="headerlink" title="childNodes去空白节点"></a>childNodes去空白节点</h3><p>//方法一：返回一个新数组</p><p>Function removeSpaceNodes(nodes){</p><p>var arr = [];</p><p>for(var i = 0; i &lt; nodes.length; i++){</p><p>if(node[i].nodeType == 3 &amp;&amp;( /^\s+$/).test(nodes[i])){</p><p>continue;</p><p>arr.push(nodes[i]);</p><p>}</p><p>}</p><p>return arr;</p><p>}</p><p>ps: 上面的方法，采用的忽略空白节点的方法，把得到的元素节点累加到数组里返回，还有一种做法就是，直接删除空白文本节点即可</p><p>//修改原数组</p><p>function filterSpaceNode(nodes){</p><p>for(var I = 0; I &lt; nodes.length; I ++){</p><p>//得到空白节点之后，移动到父节点上，删除子节点；</p><p>if(node[i].nodeType = 3 &amp;&amp; /^\s + $/.test(nodes[i].nodeValue)){</p><p>nodes[i].parentNode.removeChild(nodes[i]);</p><p>}</p><p>}</p><p>}</p><h2 id="4、使用event对象出现的兼容问题"><a href="#4、使用event对象出现的兼容问题" class="headerlink" title="4、使用event对象出现的兼容问题"></a>4、使用event对象出现的兼容问题</h2><p>解决方法：</p><p> btn.onclick = function(event){</p><p>​         var e = event || window.event;</p><p> }</p><h2 id="5-、target兼容问题"><a href="#5-、target兼容问题" class="headerlink" title="5 、target兼容问题"></a>5 、target兼容问题</h2><p>解决方法：</p><p>btn.onclick = function(event){</p><p>var e = event || window.event;</p><p>var target = e.target || e.srcElement;</p><p>}</p><p><strong>6.关于为一个元素绑定两个相同事件：attachEvent/attachEventLister 出现的兼容问题</strong><br>​    事件绑定:(不兼容需要两个结合做兼容if..else..)<br>​    IE8以下用: attachEvent(‘事件名’,fn);<br>​    FF,Chrome,IE9-10用: attachEventLister(‘事件名’,fn,false);<br>​    多事件绑定封装成一个兼容函数:<br>​    function myAddEvent(obj,ev,fn){<br>​      if(obj.attachEvent){<br>​        //IE8以下<br>​        obj.attachEvent(‘on’+ev,fn);<br>​      }else{<br>​        //FF,Chrome,IE9-10<br>​        obj.attachEventLister(ev,fn,false);<br>​      }<br>​    }<br>​    myAddEvent(oBtn,’click’,function(){<br>​      alert(a);<br>​    });<br>​    myAddEvent(oBtn,’click’,function(){<br>​      alert(b);<br>​    });</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、关于获取行外样式&quot;&gt;&lt;a href=&quot;#1、关于获取行外样式&quot; class=&quot;headerlink&quot; title=&quot;1、关于获取行外样式&quot;&gt;&lt;/a&gt;1、关于获取行外样式&lt;/h2&gt;&lt;h2 id=&quot;currentStyle-和-getComputedStyle出现
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>事件</title>
    <link href="http://www.luozy.top/2018/10/31/%E4%BA%8B%E4%BB%B6/"/>
    <id>http://www.luozy.top/2018/10/31/事件/</id>
    <published>2018-10-31T01:57:14.000Z</published>
    <updated>2018-11-01T07:48:11.313Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内联模式"><a href="#内联模式" class="headerlink" title="内联模式"></a>内联模式</h3><p>​    这种模型是最传统接单的一种处理事件的方法。在内联模型中，事件处理函数是 HTML 标签的一个属性，用于处理指定事件。虽然内联在早期使用较多，但它是和 HTML 混写的， 并没有与 HTML 分离。</p><p>//在 HTML 中把事件处理函数作为属性执行 JS 代码</p><p>&lt;input type=”button”value=”按钮”onclick=”alert(‘Lee’);” /&gt;</p><p>//注意单双引号</p><p>//在 HTML 中把事件处理函数作为属性执行 JS 函数</p><p>&lt;input type=”button”value=”按钮”onclick=”box();” /&gt;</p><p>//执行 JS 的函数 </p><p>PS：函数不得放到 window.onload 里面，这样就看不见了。</p><h3 id="脚本模式"><a href="#脚本模式" class="headerlink" title="脚本模式"></a>脚本模式</h3><p>   由于内联模型违反了 HTML 与 JavaScript 代码层次分离的原则。为了解决这个问题，我们可以在 JavaScript 中处理事件。这种处理方式就是脚本模型。</p><p>var input=document.getElementsByTagName(‘input’)[0];</p><p>//得到 input 对象</p><p>input.onclick=function(){</p><p>//匿名函数执行</p><p>​         alert(‘Lee’);</p><p>};</p><p>PS：通过匿名函数，可以直接触发对应的代码。也可以通过指定的函数名赋值的方式 来执行函数(赋值的函数名不要跟着括号)。</p><p>input.onclick=box;   //把函数名赋值给事件处理函数</p><h4 id="3、事件处理函数"><a href="#3、事件处理函数" class="headerlink" title="3、事件处理函数"></a>3、事件处理函数</h4><p>JavaScript 可以处理的事件类型为：鼠标事件、键盘事件、HTML 事件。</p><p>PS：所有的事件处理函数都会都有两个部分组成，on+ 事件名称，例如 click 事件的事件处理函数就是：onclick。在这里，我们主要谈论脚本模型的方式来构建事件，违反分离原 则的内联模式，我们忽略掉。</p><h5 id="3-1-鼠标事件，页面所有元素都可触发"><a href="#3-1-鼠标事件，页面所有元素都可触发" class="headerlink" title="3.1.鼠标事件，页面所有元素都可触发"></a>3.1.鼠标事件，页面所有元素都可触发</h5><table><thead><tr><th>click：</th><th>当用户单击鼠标按钮或按下回车键时触发</th></tr></thead><tbody><tr><td>dblclick：</td><td>当用户双击主鼠标按钮时触发。</td></tr><tr><td>mousedown：</td><td>当用户按下了鼠标还未弹起时触发。</td></tr><tr><td>mouseup：</td><td>当用户释放鼠标按钮时触发。</td></tr><tr><td>mouseover：</td><td>当鼠标移到某个元素上方时触发。</td></tr><tr><td>mouseout：</td><td>当鼠标移出某个元素上方时触发。</td></tr><tr><td>mousemove：</td><td>当鼠标指针在元素上移动时触发。</td></tr></tbody></table><h5 id="3-2-键盘事件（1、快捷键2、输入文本）"><a href="#3-2-键盘事件（1、快捷键2、输入文本）" class="headerlink" title="3.2.键盘事件（1、快捷键2、输入文本）"></a>3.2.键盘事件（1、快捷键2、输入文本）</h5><blockquote><p>添加在1、全局（window）2、输入框</p><p>keyup keydown keypress</p></blockquote><p>keydown：当用户按下键盘上任意键触发，如果按住不放，会重复触发。</p><p>onkeydown=function(){</p><p>​        alert(‘Lee’);</p><p>};</p><p>keypress：当用户按下键盘上的字符键触发，如果按住不放，会重复触发</p><p>onkeypress= function(){</p><p>​        alert(‘Lee’);</p><p>};</p><p>keyup：当用户释放键盘上的键触发。</p><p>onkeyup=function() {</p><p>​        alert(‘Lee’);</p><p>};</p><h5 id="3-3HTML事件"><a href="#3-3HTML事件" class="headerlink" title="3.3HTML事件"></a>3.3HTML事件</h5><p>window事件</p><table><thead><tr><th>Scroll</th><th>页面滚动的时候触发</th></tr></thead><tbody><tr><td>Resize</td><td>当窗口大小发生变化触发</td></tr><tr><td>load</td><td>页面加载完成的时候触发</td></tr><tr><td>unload</td><td>页面解构的时候执行</td></tr></tbody></table><p>window.onscroll=function() { alert(‘Lee’); };</p><p>window.onresize=function(){ alert(‘Lee’); };</p><p>window.onload=function() { alert(‘Lee’); };</p><p>window.onunload= function(){ alert(‘Lee’); };</p><h5 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h5><table><thead><tr><th>blur</th><th>当文本失去焦点的时候触发</th></tr></thead><tbody><tr><td>focus</td><td>当获取焦点的时候触发</td></tr><tr><td>select</td><td>当用户选择文本框(input 或 textarea)中的一个或多个字符触发。</td></tr><tr><td>change</td><td>当文本框(input 或 textarea)内容改变且失去焦点后触发。</td></tr><tr><td>submit</td><td>当用户点击提交按钮在<form>元素上触发。//只有在form控件里触发</form></td></tr><tr><td>reset</td><td>当用户点击重置按钮在<form>元素上触发。//</form></td></tr></tbody></table><p>input.onblur=function(){ alert(‘Lee’); };</p><p>input.onfocus= function(){ alert(‘Lee’); };</p><p>input.onselect=function(){ alert(‘Lee’); };</p><p>input.onchange=function(){ alert(‘Lee’); };</p><p>form.onsubmit=function(){ alert(‘Lee’); };</p><p>form.onreset=function(){ alert(‘Lee’); };</p><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p><strong>事件绑定格式：</strong></p><p><strong>元素节点.on+事件类型 = function（）{</strong></p><p>​    </p><p><strong>}</strong></p><p><strong>组成部分：</strong></p><blockquote><p>元素节点</p><p>事件类型</p><p>用于赋值的函数</p></blockquote><p> 【注】如果事件绑定成立，说明契约已成，系统会自动生成一个对象，这个对象叫做事件对象。</p><p>事件绑定中的函数，是系统调用的。</p><p>事件对象，会在我们触发事件，系统调用对应的时间处理函数的时候，将这个事件对象当做参数传入到我们的事件处理函数中。</p><p>这个对象可以通过argument【0】获取</p><p>btn.onclick = function(event){</p><p>​    //短路操作</p><p>​    var e = event || window.event;</p><p>}</p><h3 id="事件对象属性"><a href="#事件对象属性" class="headerlink" title="事件对象属性"></a>事件对象属性</h3><p>1、</p><p>button</p><p>oDiv.onmousedown = function(event){</p><p>​    var e = event || window.event;//当前事件的触发对象，谁触发的event就是谁。</p><p>​    alert(e.button);//右键0，滚轮1，左键2</p><p>}；</p><p>2、</p><p>clientX     clientY    原点为止当前浏览器可视内容屏幕左上角；</p><p>pageX     pageY    原点为页面的左上角；</p><p>screenX     screenY    原点为电脑屏幕的左上角；</p><h5 id="鼠标事件（修改键）"><a href="#鼠标事件（修改键）" class="headerlink" title="鼠标事件（修改键）"></a>鼠标事件（修改键）</h5><blockquote><p>有时，我们需要通过键盘上的某些键来配合鼠标来触发一些特殊的事件。这些键为： Shfit、Ctrl、Alt 和 Meat(Windows 中就是 Windows 键，苹果机中是 Cmd 键)，它们经常被用 来修改鼠标事件和行为，所以叫修改键。</p></blockquote><p><img src="C:\Users\罗中运\AppData\Local\Temp\chrome_drag12552_27359\Image.png" alt="Image"></p><h4 id="键盘事件属性"><a href="#键盘事件属性" class="headerlink" title="键盘事件属性"></a>键盘事件属性</h4><h5 id="1、keyCode建码"><a href="#1、keyCode建码" class="headerlink" title="1、keyCode建码"></a>1、keyCode建码</h5><p><strong>keydown</strong> 和 <strong>keyup</strong></p><blockquote><p>在发生 <strong>keydown</strong> 和 <strong>keyup</strong> 事件时，event 对象的 keyCode 属性中会包含一个代码，与键盘上一个特定的键对应。对数字字母字符集，<strong>keyCode</strong> 属性的值与 <strong>ASCII 码</strong>中对应<strong>大写字母</strong>或数字的编码相同。字母中大小写不影响。</p><p>document.onkeydown=function(evt) {</p><p>​      alert(evt.keyCode); //按任意键，得到相应的 keyCode</p><p>};</p></blockquote><h5 id="2、charCode字符编码-只支持字符不支持功能键"><a href="#2、charCode字符编码-只支持字符不支持功能键" class="headerlink" title="2、charCode字符编码(只支持字符不支持功能键)"></a>2、charCode字符编码(只支持字符不支持功能键)</h5><p><strong>keypress</strong> </p><blockquote><p> Firefox、Chrome 和 Safari 的 event 对象都支持一个 <strong>charCode</strong> 属性，这个属性只有在发 生 <strong>keypress</strong> 事件时才包含值，而且这个值是按下的那个键所代表字符的 <strong>ASCII 编码</strong>。此时 的 keyCode 通常等于 0 或者也可能等于所按键的编码。</p><p>function getCharCode(evt) {</p><p>​     if(typeof evt.charCode== ‘number’) {</p><p>​         return evt.charCode; </p><p>​     }else{</p><p>​         return evt.keyCode;</p><p>​     }</p><p>}</p><p>PS：可以使用 String.fromCharCode()将 ASCII 编码转换成实际的字符。</p></blockquote><h4 id="event"><a href="#event" class="headerlink" title="event"></a>event</h4><p>​    var e = event || window.event;//当前事件的触发对象，谁触发的event就是谁。</p><p>e.target//就是这个对象</p><p>e.srcElement//IE</p><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>任何函数内部都有一个内置的对象this，this就是当前函数主任</p><p>function show(){</p><p>​    this.name;//没有指向的属于全局即window</p><p>}</p><p>btn.onclick = fuction(event){</p><p>​    var e = event || window.event;</p><p>​    var target = e..target || window.event.srcElement;</p><p>​    //这时的触发对象为btn 和this作用一样。    </p><p>}</p><h5 id="浏览器特点："><a href="#浏览器特点：" class="headerlink" title="浏览器特点："></a>浏览器特点：</h5><p>当我们触发某个控件的事件的时候，这个事件会逐里向外逐个触发（当有多个事件的时候）</p><p>一定是从点击控件开始的；</p><p><strong>事件冒泡</strong>：从里向外逐个触发事件；</p><p><strong>事件捕获</strong>：从外向里逐个捕获；</p><h5 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h5><p>e.cancelBubble = true;</p><p>e.stopPropagation();</p><p>function stopBubble(){</p><p>​    e.cancelBubble ? e.cancelBubble = true : e.stopPropagation();</p><p>}</p><h4 id="阻止右键点击显示菜单-的默认浏览器行为："><a href="#阻止右键点击显示菜单-的默认浏览器行为：" class="headerlink" title="阻止右键点击显示菜单 的默认浏览器行为："></a>阻止右键点击显示菜单 的默认浏览器行为：</h4><p>document.oncontextmenu</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.oncontextmenu = function (event) &#123;</span><br><span class="line">//event.preventDefault();</span><br><span class="line">return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h4><p>分析步骤</p><p>1、鼠标按下 onmousedown</p><p>​    相对位置确定</p><p>​    offsetX = e.clientX - node.offsetX;</p><p>​    offsetY = e.clientY - node.offsetY</p><p>2、鼠标按下的同时并移动鼠标，完成拖拽</p><p>3、鼠标抬起取消拖拽</p><h4 id="阻止默认行为浏览器兼容写法"><a href="#阻止默认行为浏览器兼容写法" class="headerlink" title="阻止默认行为浏览器兼容写法"></a>阻止默认行为浏览器兼容写法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preDef</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e.preventDefault)&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>可解决问题：</p><p>1、重复代码浪费资源</p><p>2、后添加的要用相同功能的没法享有之前写的方法</p><p><strong>实现方式</strong>：</p><p>1、找到当前要添加方法的父节点，或祖先节点；</p><p>2、事件绑定到找到的父节点或祖先节点上；</p><p>3、获取target触发对象，如果判断是符合条件的触发对象，若符合则把事件添加到触发对象上；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>weituo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> oUL = <span class="built_in">document</span>.getElementById(<span class="string">'ul1'</span>);</span></span><br><span class="line"><span class="javascript">            oUL.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> e = event || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> target = e.target || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(target.tagName.toLowerCase() == <span class="string">'li'</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    target.style.background = <span class="string">'red'</span>;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> oBtn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> i = <span class="number">6</span>;</span></span><br><span class="line"><span class="javascript">            oBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">                </span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> newLi = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span></span><br><span class="line"><span class="undefined">                newLi.innerHTML = 1111 * i++;</span></span><br><span class="line"><span class="undefined">                oUL.appendChild(newLi);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">'ul1'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>2222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>3333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>555<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>4444<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">'btn'</span>&gt;</span></span><br><span class="line">        添加</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="事件监听器addEventListener"><a href="#事件监听器addEventListener" class="headerlink" title="事件监听器addEventListener()"></a>事件监听器addEventListener()</h3><h5 id="传统事件绑定"><a href="#传统事件绑定" class="headerlink" title="传统事件绑定"></a>传统事件绑定</h5><p>元素节点.on+事件类型 = function（）{</p><p>}</p><p>1、传统的事件绑定，不能后续新增某一个函数</p><p>​    后添加的事件，会把前面添加的事件覆盖掉；</p><p>最新的事件绑定（事件监听器）</p><p>target.addEventListener(“click”, fun, false);</p><p>第一个参数：要绑定的事件类型</p><p>第二个参数：函数</p><p>第三个参数：是否冒泡 默认为false（冒泡），true（捕获）</p><p>removeEventListener() 方法移除由 addEventListener() 方法添加的事件函数:</p><p>如： document.getElementById(“myBtn1”).removeEventListener(“click”,myfun1);</p><h3 id="事件流："><a href="#事件流：" class="headerlink" title="事件流："></a>事件流：</h3><p><strong>事件流描述的是从页面中接收事件的顺序。</strong></p><p>事件冒泡：从里向外逐个触发</p><p>事件捕获：从外向里逐个触发</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;内联模式&quot;&gt;&lt;a href=&quot;#内联模式&quot; class=&quot;headerlink&quot; title=&quot;内联模式&quot;&gt;&lt;/a&gt;内联模式&lt;/h3&gt;&lt;p&gt;​    这种模型是最传统接单的一种处理事件的方法。在内联模型中，事件处理函数是 HTML 标签的一个属性，用于处理指定事件
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Brower对象</title>
    <link href="http://www.luozy.top/2018/10/26/Brower%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.luozy.top/2018/10/26/Brower对象/</id>
    <published>2018-10-26T11:25:05.000Z</published>
    <updated>2018-10-26T11:53:25.418Z</updated>
    
    <content type="html"><![CDATA[<p>## </p><h2 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h2><p>Window 对象表示浏览器中打开的窗口。</p><p>如果文档包含框架（&lt;.frame &gt; 或 &lt;.iframe&gt; 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。</p><p><img src="http://www.runoob.com/images/lamp.gif" alt="Note"><strong>注意：</strong> 没有应用于 window 对象的公开标准，不过所有浏览器都支持该对象。</p><h2 id="Window-对象属性"><a href="#Window-对象属性" class="headerlink" title="Window 对象属性"></a>Window 对象属性</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/jsref/prop-win-closed.html" target="_blank" rel="noopener">closed</a></td><td>返回窗口是否已被关闭。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-defaultstatus.html" target="_blank" rel="noopener">defaultStatus</a></td><td>设置或返回窗口状态栏中的默认文本。</td></tr><tr><td><a href="http://www.runoob.com/jsref/dom-obj-document.html" target="_blank" rel="noopener">document</a></td><td>对 Document 对象的只读引用。(请参阅<a href="http://www.runoob.com/jsref/dom-obj-document.html" target="_blank" rel="noopener">对象</a>)</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-frames.html" target="_blank" rel="noopener">frames</a></td><td>返回窗口中所有命名的框架。该集合是 Window 对象的数组，每个 Window 对象在窗口中含有一个框架。</td></tr><tr><td><a href="http://www.runoob.com/jsref/obj-history.html" target="_blank" rel="noopener">history</a></td><td>对 History 对象的只读引用。请参数 <a href="http://www.runoob.com/jsref/obj-history.html" target="_blank" rel="noopener">History 对象</a>。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-innerheight.html" target="_blank" rel="noopener">innerHeight</a></td><td>返回窗口的文档显示区的高度。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-innerheight.html" target="_blank" rel="noopener">innerWidth</a></td><td>返回窗口的文档显示区的宽度。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-localstorage.html" target="_blank" rel="noopener">localStorage</a></td><td>在浏览器中存储 key/value 对。没有过期时间。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-length.html" target="_blank" rel="noopener">length</a></td><td>设置或返回窗口中的框架数量。</td></tr><tr><td><a href="http://www.runoob.com/jsref/obj-location.html" target="_blank" rel="noopener">location</a></td><td>用于窗口或框架的 Location 对象。请参阅 <a href="http://www.runoob.com/jsref/obj-location.html" target="_blank" rel="noopener">Location 对象</a>。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-name.html" target="_blank" rel="noopener">name</a></td><td>设置或返回窗口的名称。</td></tr><tr><td><a href="http://www.runoob.com/jsref/obj-navigator.html" target="_blank" rel="noopener">navigator</a></td><td>对 Navigator 对象的只读引用。请参数 <a href="http://www.runoob.com/jsref/obj-navigator.html" target="_blank" rel="noopener">Navigator 对象</a>。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-opener.html" target="_blank" rel="noopener">opener</a></td><td>返回对创建此窗口的窗口的引用。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-outerheight.html" target="_blank" rel="noopener">outerHeight</a></td><td>返回窗口的外部高度，包含工具条与滚动条。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-outerheight.html" target="_blank" rel="noopener">outerWidth</a></td><td>返回窗口的外部宽度，包含工具条与滚动条。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-pagexoffset.html" target="_blank" rel="noopener">pageXOffset</a></td><td>设置或返回当前页面相对于窗口显示区左上角的 X 位置。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-pagexoffset.html" target="_blank" rel="noopener">pageYOffset</a></td><td>设置或返回当前页面相对于窗口显示区左上角的 Y 位置。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-parent.html" target="_blank" rel="noopener">parent</a></td><td>返回父窗口。</td></tr><tr><td><a href="http://www.runoob.com/jsref/obj-screen.html" target="_blank" rel="noopener">screen</a></td><td>对 Screen 对象的只读引用。请参数 <a href="http://www.runoob.com/jsref/obj-screen.html" target="_blank" rel="noopener">Screen 对象</a>。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-screenleft.html" target="_blank" rel="noopener">screenLeft</a></td><td>返回相对于屏幕窗口的x坐标</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-screenleft.html" target="_blank" rel="noopener">screenTop</a></td><td>返回相对于屏幕窗口的y坐标</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-screenx.html" target="_blank" rel="noopener">screenX</a></td><td>返回相对于屏幕窗口的x坐标</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-sessionstorage.html" target="_blank" rel="noopener">sessionStorage</a></td><td>在浏览器中存储 key/value 对。 在关闭窗口或标签页之后将会删除这些数据。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-screenx.html" target="_blank" rel="noopener">screenY</a></td><td>返回相对于屏幕窗口的y坐标</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-self.html" target="_blank" rel="noopener">self</a></td><td>返回对当前窗口的引用。等价于 Window 属性。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-status.html" target="_blank" rel="noopener">status</a></td><td>设置窗口状态栏的文本。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-top.html" target="_blank" rel="noopener">top</a></td><td>返回最顶层的父窗口。</td></tr></tbody></table><h2 id="Window-对象方法"><a href="#Window-对象方法" class="headerlink" title="Window 对象方法"></a>Window 对象方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/jsref/met-win-alert.html" target="_blank" rel="noopener">alert()</a></td><td>显示带有一段消息和一个确认按钮的警告框。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-atob.html" target="_blank" rel="noopener">atob()</a></td><td>解码一个 base-64 编码的字符串。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-btoa.html" target="_blank" rel="noopener">btoa()</a></td><td>创建一个 base-64 编码的字符串。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-blur.html" target="_blank" rel="noopener">blur()</a></td><td>把键盘焦点从顶层窗口移开。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-clearinterval.html" target="_blank" rel="noopener">clearInterval()</a></td><td>取消由 setInterval() 设置的 timeout。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-cleartimeout.html" target="_blank" rel="noopener">clearTimeout()</a></td><td>取消由 setTimeout() 方法设置的 timeout。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-close.html" target="_blank" rel="noopener">close()</a></td><td>关闭浏览器窗口。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-confirm.html" target="_blank" rel="noopener">confirm()</a></td><td>显示带有一段消息以及确认按钮和取消按钮的对话框。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-createpopup.html" target="_blank" rel="noopener">createPopup()</a></td><td>创建一个 pop-up 窗口。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-focus.html" target="_blank" rel="noopener">focus()</a></td><td>把键盘焦点给予一个窗口。</td></tr><tr><td>getSelection()</td><td>返回一个 Selection 对象，表示用户选择的文本范围或光标的当前位置。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-getcomputedstyle.html" target="_blank" rel="noopener">getComputedStyle()</a></td><td>获取指定元素的 CSS 样式。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-matchmedia.html" target="_blank" rel="noopener">matchMedia()</a></td><td>该方法用来检查 media query 语句，它返回一个 MediaQueryList对象。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-moveby.html" target="_blank" rel="noopener">moveBy()</a></td><td>可相对窗口的当前坐标把它移动指定的像素。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-moveto.html" target="_blank" rel="noopener">moveTo()</a></td><td>把窗口的左上角移动到一个指定的坐标。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-open.html" target="_blank" rel="noopener">open()</a></td><td>打开一个新的浏览器窗口或查找一个已命名的窗口。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-print.html" target="_blank" rel="noopener">print()</a></td><td>打印当前窗口的内容。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-prompt.html" target="_blank" rel="noopener">prompt()</a></td><td>显示可提示用户输入的对话框。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-resizeby.html" target="_blank" rel="noopener">resizeBy()</a></td><td>按照指定的像素调整窗口的大小。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-resizeto.html" target="_blank" rel="noopener">resizeTo()</a></td><td>把窗口的大小调整到指定的宽度和高度。</td></tr><tr><td>scroll()</td><td>已废弃。 该方法已经使用了 <a href="http://www.runoob.com/jsref/met-win-scrollto.html" target="_blank" rel="noopener">scrollTo()</a> 方法来替代。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-scrollby.html" target="_blank" rel="noopener">scrollBy()</a></td><td>按照指定的像素值来滚动内容。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-scrollto.html" target="_blank" rel="noopener">scrollTo()</a></td><td>把内容滚动到指定的坐标。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-setinterval.html" target="_blank" rel="noopener">setInterval()</a></td><td>按照指定的周期（以毫秒计）来调用函数或计算表达式。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-settimeout.html" target="_blank" rel="noopener">setTimeout()</a></td><td>在指定的毫秒数后调用函数或计算表达式。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-stop.html" target="_blank" rel="noopener">stop()</a></td><td>停止页面载入。</td></tr></tbody></table><h2 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h2><p>History 对象包含用户（在浏览器窗口中）访问过的 URL。</p><p>History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。</p><p><img src="http://www.runoob.com/images/lamp.gif" alt="Note"><strong>注意：</strong> 没有应用于History对象的公开标准，不过所有浏览器都支持该对象。</p><h2 id="History-对象属性"><a href="#History-对象属性" class="headerlink" title="History 对象属性"></a>History 对象属性</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/jsref/prop-his-length.html" target="_blank" rel="noopener">length</a></td><td>返回历史列表中的网址数</td></tr></tbody></table><h2 id="History-对象方法"><a href="#History-对象方法" class="headerlink" title="History 对象方法"></a>History 对象方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/jsref/met-his-back.html" target="_blank" rel="noopener">back()</a></td><td>加载 history 列表中的前一个 URL</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-his-forward.html" target="_blank" rel="noopener">forward()</a></td><td>加载 history 列表中的下一个 URL</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-his-go.html" target="_blank" rel="noopener">go()</a></td><td>加载 history 列表中的某个具体页面</td></tr></tbody></table><h2 id="Location-对象"><a href="#Location-对象" class="headerlink" title="Location 对象"></a>Location 对象</h2><p>Location 对象包含有关当前 URL 的信息。</p><p>Location 对象是 window 对象的一部分，可通过 window.Location 属性对其进行访问。</p><p><img src="http://www.runoob.com/images/lamp.gif" alt="Note"><strong>注意：</strong> 没有应用于Location对象的公开标准，不过所有浏览器都支持该对象。</p><hr><h2 id="Location-对象属性"><a href="#Location-对象属性" class="headerlink" title="Location 对象属性"></a>Location 对象属性</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/jsref/prop-loc-hash.html" target="_blank" rel="noopener">hash</a></td><td>返回一个URL的锚部分</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-loc-host.html" target="_blank" rel="noopener">host</a></td><td>返回一个URL的主机名和端口</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-loc-hostname.html" target="_blank" rel="noopener">hostname</a></td><td>返回URL的主机名</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-loc-href.html" target="_blank" rel="noopener">href</a></td><td>返回完整的URL</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-loc-pathname.html" target="_blank" rel="noopener">pathname</a></td><td>返回的URL路径名。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-loc-port.html" target="_blank" rel="noopener">port</a></td><td>返回一个URL服务器使用的端口号</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-loc-protocol.html" target="_blank" rel="noopener">protocol</a></td><td>返回一个URL协议</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-loc-search.html" target="_blank" rel="noopener">search</a></td><td>返回一个URL的查询部分</td></tr></tbody></table><h2 id="Location-对象方法"><a href="#Location-对象方法" class="headerlink" title="Location 对象方法"></a>Location 对象方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/jsref/met-loc-assign.html" target="_blank" rel="noopener">assign()</a></td><td>载入一个新的文档</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-loc-reload.html" target="_blank" rel="noopener">reload()</a></td><td>重新载入当前文档</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-loc-replace.html" target="_blank" rel="noopener">replace()</a></td><td>用新的文档替换当前文档</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;## &lt;/p&gt;
&lt;h2 id=&quot;Window对象&quot;&gt;&lt;a href=&quot;#Window对象&quot; class=&quot;headerlink&quot; title=&quot;Window对象&quot;&gt;&lt;/a&gt;Window对象&lt;/h2&gt;&lt;p&gt;Window 对象表示浏览器中打开的窗口。&lt;/p&gt;
&lt;p&gt;如果文档包含
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>DOM</title>
    <link href="http://www.luozy.top/2018/10/26/DOM/"/>
    <id>http://www.luozy.top/2018/10/26/DOM/</id>
    <published>2018-10-26T06:28:51.000Z</published>
    <updated>2018-11-01T11:44:09.365Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="文档对象模型DOM（document-Object-Model）"><a href="#文档对象模型DOM（document-Object-Model）" class="headerlink" title="文档对象模型DOM（document Object Model）"></a>文档对象模型DOM（document Object Model）</h1><blockquote><p>DOM 中的三个字母，D（文档）可以理解为整个 Web 加载的网页文档；O（对象）可 以理解为类似 window 对象之类的东西，可以调用属性和方法，这里我们说的是 document 对象；M（模型）可以理解为网页文档的树型结构。</p></blockquote><p>所谓DOM就是以家族的形式描述HTML       节点有 父子 兄弟 </p><p>注：在JavaScript里真的这么叫！！！只不过加上了节点两个字称作父子节点，兄弟节点。<img src="C:\Users\罗中运\AppData\Local\Temp\chrome_drag17544_7625\Image.png" alt="Image"></p><h4 id="加载-HTML-页面时，Web-浏览器生成一个树型结构，用来表示页面内部结构。DOM-将-这种树型结构称为节点组成的节点树。"><a href="#加载-HTML-页面时，Web-浏览器生成一个树型结构，用来表示页面内部结构。DOM-将-这种树型结构称为节点组成的节点树。" class="headerlink" title="加载 HTML 页面时，Web 浏览器生成一个树型结构，用来表示页面内部结构。DOM 将 这种树型结构称为节点组成的节点树。"></a>加载 HTML 页面时，Web 浏览器生成一个树型结构，用来表示页面内部结构。DOM 将 这种树型结构称为节点组成的节点树。</h4><h2 id="DOM中所有节点的种类"><a href="#DOM中所有节点的种类" class="headerlink" title="DOM中所有节点的种类"></a>DOM中所有节点的种类</h2><p>元素节点  <div></div></p><p>属性节点 id =‘div1’</p><p>文本节点 div文本</p><p><img src="C:\Users\罗中运\AppData\Local\Temp\chrome_drag17544_26641\Image.png" alt="Image">  W3C 提供了比较方便简单的定位节点的方法和属性，以便我们快速的对节点进行操作。 分别为：getElementById()、getElementsByTagName()、getElementsByName()、getElementsClassName()、getAttribute()、 setAttribute()和 removeAttribute()。<img src="C:\Users\罗中运\AppData\Local\Temp\chrome_drag17544_20962\Image.png" alt="Image"></p><h3 id="获取元素节点"><a href="#获取元素节点" class="headerlink" title="获取元素节点"></a>获取元素节点</h3><blockquote><p>W3C 提供了比较方便简单的定位节点的方法和属性，以便我们快速的对节点进行操作。 分别为：getElementById()、getElementsByTagName()、getElementsByName()、getElementsClassName()、getAttribute()、 setAttribute()和 removeAttribute()。</p></blockquote><p>ps:代码由上而下执行，script在头部的时候，先执行script的内容，在执行body里面的。</p><p>所以要用到 window.onload</p><h4 id="window-onload-function"><a href="#window-onload-function" class="headerlink" title="window.onload = function(){"></a>window.onload = function(){</h4><h4 id=""><a href="#" class="headerlink" title="}"></a>}</h4><p><strong>方法在页面加载完毕后才会执行。</strong></p><p>这样就可以先加载完body，再执行script里面的内容。</p><h4 id="1、document-getElementById（）通过id获取元素节点"><a href="#1、document-getElementById（）通过id获取元素节点" class="headerlink" title="1、document.getElementById（）通过id获取元素节点"></a>1、document.getElementById（）通过id获取元素节点</h4><h4 id="2、node-getElementsByTagName-获取相同元素的节点列表"><a href="#2、node-getElementsByTagName-获取相同元素的节点列表" class="headerlink" title="2、node.getElementsByTagName()    获取相同元素的节点列表"></a>2、node.getElementsByTagName()    获取相同元素的节点列表</h4><p>​    参数：小写的标签名</p><p>​    返回值：获取所有符合条件的元素节点，使用起来和数组差不多</p><p>​    </p><p>​    可以指定在哪个节点开始找元素</p><p>​    var op = ducument.getElementById(“h1”);</p><p>​    var nodes = op.getElementsByTagName(“div”);</p><p>​    //作用： 获取到h1下的所有div</p><h4 id="3、document-getElementsByName-获取相同元素名称（name）的节点列表"><a href="#3、document-getElementsByName-获取相同元素名称（name）的节点列表" class="headerlink" title="3、document.getElementsByName()获取相同元素名称（name）的节点列表"></a>3、document.getElementsByName()获取相同元素名称（name）的节点列表</h4><h4 id="4、node-getElementsByClassName-获取相同ClassName的节点-IE8以上才兼容"><a href="#4、node-getElementsByClassName-获取相同ClassName的节点-IE8以上才兼容" class="headerlink" title="4、node.getElementsByClassName() 获取相同ClassName的节点(IE8以上才兼容)"></a>4、node.getElementsByClassName() 获取相同ClassName的节点(IE8以上才兼容)</h4><p>​    也可以指定在哪个节点开始找元素</p><p>​    封装getElementsByClassName():</p><p>​    function elementByClassName(node, className){</p><p>​        var nodes =    node.getElementsByTagName(“*”);</p><p>​        var arr = [];        </p><p>​        for(var i = 0; i &lt; nodes.length; i++){</p><p>​            if(nodes[i].className == className){</p><p>​                arr.push(nodes[i]);</p><p>​            }</p><p>​        }</p><p>​        return arr;</p><p>​    }</p><h4 id="5、getAttribute-获取特定元素节点属性的值"><a href="#5、getAttribute-获取特定元素节点属性的值" class="headerlink" title="5、getAttribute()获取特定元素节点属性的值"></a>5、getAttribute()获取特定元素节点属性的值</h4><h4 id="6、setAttribute-设置特点元素特点属性的值"><a href="#6、setAttribute-设置特点元素特点属性的值" class="headerlink" title="6、setAttribute()设置特点元素特点属性的值"></a>6、setAttribute()设置特点元素特点属性的值</h4><h4 id="7、removeAttribute-移除特定元素节点属性"><a href="#7、removeAttribute-移除特定元素节点属性" class="headerlink" title="7、removeAttribute()移除特定元素节点属性"></a>7、removeAttribute()移除特定元素节点属性</h4><h4 id="document-querySelector-IE8以下不兼容"><a href="#document-querySelector-IE8以下不兼容" class="headerlink" title="document.querySelector() //IE8以下不兼容"></a>document.querySelector() //IE8以下不兼容</h4><p>返回值：只返回符合条件的第一个节点。</p><h4 id="document-querySelectorAll"><a href="#document-querySelectorAll" class="headerlink" title="document.querySelectorAll()"></a>document.querySelectorAll()</h4><p>必须是document开头，返回一个数组</p><p>参数:都是css选择器的格式去写的字符串。</p><p>如：</p><p>​    var node = document.querySelector(“.box”);//获取class等于box的第一个节点</p><p>​    var node = document.querySelector(“ol .box”);//ol下class==box的第一个节点</p><p>​    var nodes = document.querySelector(“className”)；//返回的是数组，即使是获取id</p><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><p>只要是元素节点，都有以下两个属性</p><p>​    tagName    输出当前元素节点的标签类型</p><p>​    innerHTML（双标签）    获取标签建内容（元素节点也是text格式显示）</p><p>​    设置的时候标签会以样式输出</p><h4 id="通过属性名访问属性的值"><a href="#通过属性名访问属性的值" class="headerlink" title="通过属性名访问属性的值"></a>通过属性名访问属性的值</h4><p>​    .id，.title，.className，.width ，.style.width,.style.backgroundColor  …</p><p>​    ps: 样式里面的-换成首字母大写，即烤串式写法换为驼峰式写法</p><p>​    获取样式只能获取行间样式</p><h5 id="获取style标签内样式-：-跨浏览器获取当前有效样式的方法"><a href="#获取style标签内样式-：-跨浏览器获取当前有效样式的方法" class="headerlink" title="获取style标签内样式 ：//    跨浏览器获取当前有效样式的方法"></a>获取style标签内样式 ：//    跨浏览器获取当前有效样式的方法</h5><p>Div.currentStyle[‘height’];//IE</p><p>getCompitedStyle(oDiv)[‘height’];//谷歌火狐等</p><p>自定义兼容写法</p><p>​    function getStyle(node , styleStr){</p><p>​            return node.currentStyle ? node.currentStyle[styleStr] : getComputedStyle(node)[styleStr];</p><p>​     }</p><h4 id="通过getAttribute属性获取"><a href="#通过getAttribute属性获取" class="headerlink" title="通过getAttribute属性获取"></a>通过getAttribute属性获取</h4><p>ele.getAttribute();</p><p>ele.setAttribute();</p><p>removeAttribute();</p><h3 id="属性设置和方法设置区别"><a href="#属性设置和方法设置区别" class="headerlink" title="属性设置和方法设置区别"></a>属性设置和方法设置区别</h3><p>​            //1、区别<br>​            // alert(oDiv.className);<br>​            // alert(oDiv.getAttribute(“class”));</p><p>​            // oDiv.className = ‘xxx’;<br>​            // oDiv.setAttribute(“class”, “xxx”);</p><p>​            //2、自定义属性<br>​            // alert(oDiv.xxx);<br>​            // alert(oDiv.getAttribute(“xxx”));</p><p>​            //设置自定义属性<br>​            /<em>oDiv.zzz = ‘mmm’;<br>​            alert(oDiv.zzz);</em>/</p><p>​            //如果你想添加一个属性，并且将这个属性显示在行间<br>​            // oDiv.setAttribute(‘zzz’, ‘mmm’);</p><p>​            /<em><br>​                removeAttribute();<br>​            </em>/</p><p>​            // oDiv.className = “”;<br>​            oDiv.removeAttribute(“class”);</p><h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3><p>childNodes</p><p>DOM节点</p><p><strong>1、元素节点</strong></p><p><strong>2、属性节点</strong></p><p><strong>3、文本节点</strong></p><p>上述文本通用属性</p><p>​        nodeName    nodeType    nodevalue</p><p>元素    标签名        1            </p><p>属性    属性名        2            属性值</p><p>文本    #text        3            文本内容</p><p>【注】文本节点只能通过标签（元素节点）的子节点获取；</p><p>【注】 空格回车也会当做文本节点；！！！会导致节点变多</p><p>firstChild    子节点中的第一个节点</p><p>lastChild        子节点中的最后一个节点</p><p><strong>children获取元素节点</strong></p><p>firstElementChild</p><p>lastElementChild</p><p>nextElementSibling()获取兄弟节点的下一个节点</p><p>.innerHTML与.outerHTML</p><p>区别：一个是内部内容不包含自身标签，outer包含本标签</p><h4 id="attribute属性节点"><a href="#attribute属性节点" class="headerlink" title="attribute属性节点"></a>attribute属性节点</h4><p>attributes是一个集合</p><p>集合：特点  1、无序，2、不重复</p><p>不可以通过序列下标获取，可以通过具体索引获取</p><p>box.attributes                //NamedNodeMap</p><p>box.attributes.length;        //返回属性节点个数</p><p>box.attributes[0];            //Attr，返回最后一个属性节点</p><p>box.attributes[0].nodeType;   //2，节点类型</p><p>box.attributes[0].nodeValue;  //属性值</p><p>box.attributes[‘id’];         //Attr，返回属性为 id 的节点</p><p>box.attributes.getNamedItem(‘id’); //Attr</p><h3 id="去空白节点"><a href="#去空白节点" class="headerlink" title="去空白节点"></a>去空白节点</h3><p>//返回一个新数组</p><p>function removeSpaceNodes(nodes){</p><p>​    var arr = [];</p><p>​    for(var i = 0; i &lt; nodes.length; i++){</p><p>​        if(node[i].nodeType == 3 &amp;&amp; （/^\s+$/).test(nodes[i])){</p><p>​            continue;</p><p>​            arr.push(nodes[i]);</p><p>​        }</p><p>​    }</p><p>​    return arr;</p><p>}</p><p>PS：上面的方法，采用的忽略空白文件节点的方法，把得到元素节点累加到数组里返 回。那么还有一种做法是，直接删除空位文件节点即可</p><p>//修改原数组</p><p>function filterSpaceNode(nodes){</p><p>​    for(vari=0;i&lt;nodes.length;i++) {</p><p>​          if(nodes[i].nodeType== 3&amp;&amp;/^\s+$/.test(nodes[i].nodeValue)){</p><p>​          //得到空白节点之后，移到父节点上，删除子节点           </p><p>​            nodes[i].parentNode.removeChild(nodes[i]);</p><p>​         }</p><p>​    }</p><p>​    return nodes;</p><p>}</p><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作**"></a>节点操作**</h2><p><strong>document.write();</strong></p><p>会覆盖页面上原有的内容；所以一般不会用在节点操作上</p><p><strong>document.createElement(标签名);</strong></p><p>功能：生成一个标签</p><p>返回值：新创建的这个元素节点</p><p><strong>node1.appendChild(node2);</strong></p><p>功能：将node2插入到node1的子节点末尾。</p><p><strong>document.createTextNode()</strong>；</p><p>功能：创建文本节点</p><p>node.appendChild(tNode);</p><p>相同功能：node.innerHTML</p><p><strong>.insertBefore</strong>()</p><p>格式： node1.parentNode.insertBefore(node2,nide1)</p><p>功能：将node2插入到node1之前</p><p><strong>replaceChild()</strong></p><p>格式：node1.parentNode.replace(node2, node1)</p><p>功能：用node2将node1替换掉</p><p><strong>cloneNode()</strong></p><p>格式：node.cloneNode();</p><p>参数：true：即克隆标签也克隆文本 ，默认false</p><p><strong>removeChild()</strong></p><p>格式：node.parentNode.removeChild();</p><h2 id="事件驱动方法-两种写法"><a href="#事件驱动方法-两种写法" class="headerlink" title="事件驱动方法 两种写法"></a>事件驱动方法 两种写法</h2><p>行间</p><p>onclick = “func();”</p><p>写在script里面</p><p>先通过id获取元素</p><p>ele.onclick = function(){</p><p>}</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>每一个函数，系统都会提供一个内置的变量，这个变量就是this.this存储的都是当前函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;文档对象模型DOM（document-Object-Model）&quot;&gt;&lt;a href=&quot;#文档对象模型DOM（document-Object-Model）&quot; class=&quot;headerlink&quot; title=&quot;文档对象模型DOM（docum
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>BOM</title>
    <link href="http://www.luozy.top/2018/10/26/BOM/"/>
    <id>http://www.luozy.top/2018/10/26/BOM/</id>
    <published>2018-10-26T01:26:49.000Z</published>
    <updated>2018-10-26T09:17:56.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BOM-Browser-object-model-浏览器对象模型"><a href="#BOM-Browser-object-model-浏览器对象模型" class="headerlink" title="BOM(Browser object model)浏览器对象模型"></a>BOM(Browser object model)浏览器对象模型</h1><blockquote><p> 一个浏览器窗口就是一个bom（浏览器对象）</p></blockquote><p><img src="C:\Users\罗中运\AppData\Roaming\Typora\typora-user-images\1540517515858.png" alt="1540517515858"></p><h5 id="window下的方法，通常情况下window开头的方法函数都可以省略window使用"><a href="#window下的方法，通常情况下window开头的方法函数都可以省略window使用" class="headerlink" title="window下的方法，通常情况下window开头的方法函数都可以省略window使用"></a>window下的方法，通常情况下window开头的方法函数都可以省略window使用</h5><h4 id="confirm（）方法"><a href="#confirm（）方法" class="headerlink" title="confirm（）方法"></a>confirm（）方法</h4><blockquote><p>confirm() 方法用于显示一个带有指定消息和 OK 及取消按钮的对话框。</p></blockquote><p>返回值：点击确定，返回true</p><p>​        点击取消，返回false </p><h4 id="prompt"><a href="#prompt" class="headerlink" title="prompt()"></a>prompt()</h4><blockquote><p>prompt()方法用于显示可提示用户进行输入的对话框。</p><p>这个方法返回用户输入的字符串。</p></blockquote><p>参数： 第一个参数 提示面板上显示的内容</p><p>​          第二个参数 输入框上显示的内容（可以不填）</p><p>返回值：输入框的内容    </p><h4 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h4><blockquote><p>open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口。</p></blockquote><p>第一个参数： 加载的url</p><p>第二个参数：指定target属性窗口的名称，（）</p><p>第三个参数：一串特殊意义的字符串，配置我们打开窗口的大小坐标</p><h5 id="url完整组成"><a href="#url完整组成" class="headerlink" title="url完整组成"></a>url完整组成</h5><h5 id="协议：-主机名：端口号-路径-？查询字符串-锚点"><a href="#协议：-主机名：端口号-路径-？查询字符串-锚点" class="headerlink" title="协议：//主机名：端口号/路径/？查询字符串#锚点"></a>协议：//主机名：端口号/路径/？查询字符串#锚点</h5><h5 id="protocol-hostname-port-pathname-search-hash"><a href="#protocol-hostname-port-pathname-search-hash" class="headerlink" title="protocol://hostname:port/pathname/?search#hash"></a>protocol://hostname:port/pathname/?search#hash</h5><h4 id="opener打开当前窗口的父窗口的对象（只有火狐浏览器兼容）"><a href="#opener打开当前窗口的父窗口的对象（只有火狐浏览器兼容）" class="headerlink" title="opener打开当前窗口的父窗口的对象（只有火狐浏览器兼容）"></a>opener打开当前窗口的父窗口的对象（只有火狐浏览器兼容）</h4><p>opener.document.write(“father”);//父窗口输出</p><h4 id="setTimeout-延时器"><a href="#setTimeout-延时器" class="headerlink" title="setTimeout()延时器"></a>setTimeout()延时器</h4><p>格式：</p><p>var timer = setTimerout(函数，毫秒数);</p><p>功能： 延迟对应毫秒数，去执行函数，有且仅执行一次；</p><p>取消延时器</p><p>clearTImeout(timer);</p><h4 id="history-历史对象"><a href="#history-历史对象" class="headerlink" title="history 历史对象"></a>history 历史对象</h4><p>window.history</p><p>属性</p><p>history.length    历史纪录长度</p><p>方法：</p><p>​    history.back();//后退</p><p>​    history.forward();//前进</p><p>​    history.go();//到指定历史界面</p><p>​        参数：正整数，负整数，0 前进/后退n条记录；0重新加载</p><h4 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h4><blockquote><p>地址栏部分</p><p>url：统一资源定位符</p><p>组成一个完整的url，必须按格式进行填写。</p></blockquote><h5 id="第一部分：location-protocol-协议"><a href="#第一部分：location-protocol-协议" class="headerlink" title="第一部分：location.protocol 协议"></a>第一部分：location.protocol 协议</h5><p>http://</p><p>https://</p><p>传输方式</p><h5 id="第二部分：主机名-location-hostname"><a href="#第二部分：主机名-location-hostname" class="headerlink" title="第二部分：主机名 location.hostname"></a>第二部分：主机名 location.hostname</h5><p><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 域名IP的昵称</p><p>61.135.169.125 IP 全网唯一</p><h5 id="location-port-端口号"><a href="#location-port-端口号" class="headerlink" title="location.port 端口号"></a>location.port 端口号</h5><p>系统会给当前使用网络的app，分配一个号码，这个号码就是端口号</p><p>当前电脑内唯一识别正在使用网络的软件；</p><p>ip：port 在全球范围内定位当前使用网络的软件</p><h5 id="pathname路径"><a href="#pathname路径" class="headerlink" title="pathname路径"></a>pathname路径</h5><p>location.pathname</p><h5 id="search向服务器提交数据部分（查询字符串）"><a href="#search向服务器提交数据部分（查询字符串）" class="headerlink" title="search向服务器提交数据部分（查询字符串）"></a>search向服务器提交数据部分（查询字符串）</h5><p>location.search </p><p>查询字符串</p><p>？name1 =value&amp; name2 = value</p><h5 id="hash锚点"><a href="#hash锚点" class="headerlink" title="hash锚点"></a>hash锚点</h5><p>location.hash</p><h3 id="location方法"><a href="#location方法" class="headerlink" title="location方法"></a>location方法</h3><p>location.assign（） 跳转到某一个url</p><p>location.replace（） 在当前窗口替换url</p><p>assign和replace区别assign有历史记录，replace没有</p><p>location.reload（） 刷新网页 参数location.reload（true）：不经过缓存直接刷新页面</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BOM-Browser-object-model-浏览器对象模型&quot;&gt;&lt;a href=&quot;#BOM-Browser-object-model-浏览器对象模型&quot; class=&quot;headerlink&quot; title=&quot;BOM(Browser object model)浏览器
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面向对象和面向过程</title>
    <link href="http://www.luozy.top/2018/10/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.luozy.top/2018/10/25/面向对象和面向过程/</id>
    <published>2018-10-25T01:39:02.000Z</published>
    <updated>2018-10-25T01:42:22.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象与面向过程的本质的区别"><a href="#面向对象与面向过程的本质的区别" class="headerlink" title="面向对象与面向过程的本质的区别"></a>面向对象与面向过程的本质的区别</h1><h3 id="一、面向对象与面向过程的区别"><a href="#一、面向对象与面向过程的区别" class="headerlink" title="一、面向对象与面向过程的区别"></a>一、面向对象与面向过程的区别</h3><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p><p>可以拿生活中的实例来理解面向过程与面向对象，例如五子棋，面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。</p><p>如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。</p><p>可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。</p><p>上述的内容是从网上查到的，觉得这个例子非常的生动形象，我就写了下来，现在就应该理解了他俩的区别了吧，其实就是两句话，面向对象就是高度实物抽象化、面向过程就是自顶向下的编程！</p><h3 id="二、面向对象的特点"><a href="#二、面向对象的特点" class="headerlink" title="二、面向对象的特点"></a>二、面向对象的特点</h3><p>​    在了解其特点之前，咱们先谈谈对象，对象就是现实世界存在的任何事务都可以称之为对象，有着自己独特的个性</p><p>​    属性用来描述具体某个对象的特征。比如小志身高180M，体重70KG，这里身高、体重都是属性。<br>面向对象的思想就是把一切都看成对象，而对象一般都由属性+方法组成！</p><p>​    属性属于对象静态的一面，用来形容对象的一些特性，方法属于对象动态的一面，咱们举一个例子，小明会跑，会说话，跑、说话这些行为就是对象的方法！所以为动态的一面， 我们把属性和方法称为这个对象的成员！</p><p>​    <strong>类</strong>：具有同种属性的对象称为类，是个抽象的概念。比如“人”就是一类，期中有一些人名，比如小明、小红、小玲等等这些都是对象，类就相当于一个模具，他定义了它所包含的全体对象的公共特征和功能，对象就是类的一个实例化，小明就是人的一个实例化！我们在做程序的时候，经常要将一个变量实例化，就是这个原理！我们一般在做程序的时候一般都不用类名的，比如我们在叫小明的时候，不会喊“人，你干嘛呢！”而是说的是“小明，你在干嘛呢！”</p><p>​    面向对象有三大特性，分别是封装性、继承性和多态性，这里小编不给予太多的解释，因为在后边的博客会专门总结的！</p><h3 id="三、面向过程与面向对象的优缺点"><a href="#三、面向过程与面向对象的优缺点" class="headerlink" title="三、面向过程与面向对象的优缺点"></a>三、面向过程与面向对象的优缺点</h3><p>​    很多资料上全都是一群很难理解的理论知识，整的小编头都大了，后来发现了一个比较好的文章，写的真是太棒了，通俗易懂，想要不明白都难!</p><p>​    用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭。所谓盖浇饭，北京叫盖饭，东北叫烩饭，广东叫碟头饭，就是在一碗白米饭上面浇上一份盖菜，你喜欢什么菜，你就浇上什么菜。我觉得这个比喻还是比较贴切的。</p><p>​    蛋炒饭制作的细节，我不太清楚，因为我没当过厨师，也不会做饭，但最后的一道工序肯定是把米饭和鸡蛋混在一起炒匀。盖浇饭呢，则是把米饭和盖菜分别做好，你如果要一份红烧肉盖饭呢，就给你浇一份红烧肉；如果要一份青椒土豆盖浇饭，就给浇一份青椒土豆丝。</p><p>​    蛋炒饭的好处就是入味均匀，吃起来香。如果恰巧你不爱吃鸡蛋，只爱吃青菜的话，那么唯一的办法就是全部倒掉，重新做一份青菜炒饭了。盖浇饭就没这么多麻烦，你只需要把上面的盖菜拨掉，更换一份盖菜就可以了。盖浇饭的缺点是入味不均，可能没有蛋炒饭那么香。</p><p>​    到底是蛋炒饭好还是盖浇饭好呢？其实这类问题都很难回答，非要比个上下高低的话，就必须设定一个场景，否则只能说是各有所长。如果大家都不是美食家，没那么多讲究，那么从饭馆角度来讲的话，做盖浇饭显然比蛋炒饭更有优势，他可以组合出来任意多的组合，而且不会浪费。</p><p>​    盖浇饭的好处就是”菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是”可维护性“比较好，”饭” 和”菜”的耦合度比较低。蛋炒饭将”蛋”“饭”搅和在一起，想换”蛋”“饭”中任何一种都很困难，耦合度很高，以至于”可维护性”比较差。软件工程追求的目标之一就是可维护性，可维护性主要表现在3个方面：可理解性、可测试性和可修改性。面向对象的好处之一就是显著的改善了软件系统的可维护性。 　　 </p><h4 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h4><blockquote><p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。<br>缺点：没有面向对象易维护、易复用、易扩展</p></blockquote><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><blockquote><p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 </p><p>缺点：性能比面向过程低</p></blockquote><hr><p>作者：十四期_李光<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/jerry11112/article/details/79027834" target="_blank" rel="noopener">https://blog.csdn.net/jerry11112/article/details/79027834</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向对象与面向过程的本质的区别&quot;&gt;&lt;a href=&quot;#面向对象与面向过程的本质的区别&quot; class=&quot;headerlink&quot; title=&quot;面向对象与面向过程的本质的区别&quot;&gt;&lt;/a&gt;面向对象与面向过程的本质的区别&lt;/h1&gt;&lt;h3 id=&quot;一、面向对象与面向过程的区
      
    
    </summary>
    
    
      <category term="对象" scheme="http://www.luozy.top/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Math对象和日期对象</title>
    <link href="http://www.luozy.top/2018/10/25/Math%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.luozy.top/2018/10/25/Math对象和日期对象/</id>
    <published>2018-10-25T01:07:48.000Z</published>
    <updated>2018-10-26T09:31:01.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、Math对象"><a href="#1、Math对象" class="headerlink" title="1、Math对象"></a>1、Math对象</h2><h4 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h4><p>[0,1)返回随机数</p><h4 id="Math-max-num1-num2-Math-min-num1-num2"><a href="#Math-max-num1-num2-Math-min-num1-num2" class="headerlink" title="Math.max(num1,num2),Math.min(num1,num2);"></a>Math.max(num1,num2),Math.min(num1,num2);</h4><p>取较大，较小值</p><h4 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round()"></a>Math.round()</h4><p>四舍五入，变成整数</p><h4 id="Math-floor-Math-ceil"><a href="#Math-floor-Math-ceil" class="headerlink" title="Math.floor(), Math.ceil()"></a>Math.floor(), Math.ceil()</h4><p>向下，上取整</p><h4 id="Math-sqrt"><a href="#Math-sqrt" class="headerlink" title="Math.sqrt()"></a>Math.sqrt()</h4><p>开平方</p><h4 id="Math-abs"><a href="#Math-abs" class="headerlink" title="Math.abs()"></a>Math.abs()</h4><p>取绝对值</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p><img src="C:\Users\罗中运\Pictures\Saved Pictures\对象.png" alt="对象"></p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>1、抽象：抽指把核心的东西抽出来，把与我们要解决的问题有关的东西拿出来摆在面前 </p><p>2、封装：让使用对象的人不考虑内部实现，只考虑功能使用  把内部的代码保护起来，只留出一些个api接口供用户使用</p><p>3、继承：就是为了代码的复用，从父类上继承出一些方法和属性，子类也有自己的一些属性 </p><p>4、多态：实际上是不同对象作用与同一操作产生不同的效果。多态的思想实际上是把“想做什么”和“谁去做“分开</p><h5 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h5><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p><p>可以拿生活中的实例来理解面向过程与面向对象，例如五子棋，面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。</p><h6 id="如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。"><a href="#如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。" class="headerlink" title="如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。"></a>如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。</h6><h6 id="可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。"><a href="#可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。" class="headerlink" title="可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。"></a>可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。</h6><p>###### </p><h4 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a>对象的组成</h4><p>1、方法   函数：过程、动态的</p><p>2、属性   变量：状态、静态的，</p><h4 id="this当前的方法属于谁就是谁"><a href="#this当前的方法属于谁就是谁" class="headerlink" title="this当前的方法属于谁就是谁"></a>this<strong>当前的方法属于谁就是谁</strong></h4><p>例如点击事件里的this，其实就是触发事件的那个dom对象的onclick方法里的this，当然是人家自己咯</p><p> 再比如说一个函数里的this，这个函数都属于window的一个方法，当然里面的this也是window咯</p><p>  还有哦，不要在系统对象上面添加属性和方法，这样不太好</p><p> 那么在谁身上加呢？在object这个对象身上，别的date呀array呀，这些对象都是有一些个好玩的功能的，</p><p>  object也就自己最强大的一个功能就是，没有功能~~~~ 这样咱们就可以随意给他加属性和方法而不用去想会不会覆盖了</p><p>1、通过历史</p><p>​    面向过程语言：汇编、c语言</p><p>​    面向对象语言：c++，java</p><p>2、编程思想</p><p>​    面向过程：只关心数字逻辑</p><p>​    面向过程：具体某一个是提来的，唯一的实体。</p><p>3、语法：<br>​    在JS中需要通过两个语法实现面向对象程序。<br>​    类   在JS没有类这个概念。<br>​    对象 </p><p>​    类：将具有同一类特征的事物总结，抽象的概念。<br>​    对象：唯一的某一个个体。</p><p>​    类           对象<br>​    人          你、我、他<br>​    复仇者联盟  钢铁侠    </p><p>4、代码<br>​    数据类型：<br>​            基本数据类型：<br>​            特殊数据类型：null undefined NaN<br>​            复合数据类型：数组、字符串、对象</p><p>5、数据结构：<br>​    基本数据类型(只能存储单个的值)  -&gt;  数组(可以处理批量的数据)  -&gt;  对象(既能存储数据，又能存储函数)</p><h4 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h4><p>1、最基础的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、通过new声明对象</span></span><br><span class="line"><span class="comment">// var obj = new Object();</span></span><br><span class="line"><span class="comment">//2、省略new声明对象</span></span><br><span class="line"><span class="comment">// var obj = Object();</span></span><br><span class="line"><span class="comment">//3、直接通过对象常量赋值</span></span><br><span class="line"><span class="comment">/*var obj = &#123;&#125;;</span></span><br><span class="line"><span class="comment">添加对象的属性  和普通的变量是一样的</span></span><br><span class="line"><span class="comment">obj.name = '小明';</span></span><br><span class="line"><span class="comment">obj.age = 18;</span></span><br><span class="line"><span class="comment">//添加对象的方法/函数</span></span><br><span class="line"><span class="comment">obj.run = function()&#123;</span></span><br><span class="line"><span class="comment">alert("会跑")</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">alert(obj.name);</span></span><br><span class="line"><span class="comment">obj.run();*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*var obj = &#123;</span></span><br><span class="line"><span class="comment">name: "小明",</span></span><br><span class="line"><span class="comment">age: 18,</span></span><br><span class="line"><span class="comment">run: function()&#123;</span></span><br><span class="line"><span class="comment">alert("会跑");</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">alert(obj.name);</span></span><br><span class="line"><span class="comment">obj.run();*/</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加对象的属性  和普通的变量是一样的</span></span><br><span class="line">obj.name = <span class="string">'小明'</span>;</span><br><span class="line">obj[<span class="string">'age'</span>] = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加对象的方法/函数</span></span><br><span class="line">obj.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"会跑"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(obj[<span class="string">'name'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除对象的属性和方法的关键字 delete</span></span><br><span class="line"><span class="comment">// delete删除对象属性，delete删除不了变量及原型链中的变量</span></span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line">alert(obj.name);</span><br><span class="line"></span><br><span class="line">obj.run();</span><br></pre></td></tr></table></figure><p>但是这样太麻烦，我要写100个人，那得写100次。有别的方法吗？有</p><p>2、工厂方式 通过构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//原料</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">//加工</span></span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age=age;</span><br><span class="line">    obj.showAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         alert(<span class="keyword">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出厂</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1=createPerson(<span class="string">"shizhikai"</span>,<span class="string">'3岁'</span>)</span><br><span class="line"><span class="keyword">var</span> obj2=createPerson(<span class="string">"ni"</span>,<span class="string">'18岁'</span>);</span><br><span class="line"></span><br><span class="line">alert(obj1.showName)<span class="comment">//function()&#123;alert(this.name)&#125;</span></span><br><span class="line">alert(obj2.showName)<span class="comment">//function()&#123;alert(this.name)&#125;</span></span><br></pre></td></tr></table></figure><h2 id="日起对象Date"><a href="#日起对象Date" class="headerlink" title="日起对象Date"></a>日起对象Date</h2><p>Date对象代表日期</p><p> Date</p><p>类型使用自 UTC（Coordinated Universal Time，国际协调时间）1970 年 1 月 1 日午夜（零时）开始经过的毫秒数来保存日期。Date 类型保存的日期能够精确到 1970 年 1 月 1 日之前或之后的 285616 年。</p><p>创建一个日期对象，使用 new 运算符和 Date 构造方法(构造函数)即可。</p><p>​    <strong>var d = new Date();</strong></p><p>在调用 Date 构造方法而不传递参数的情况下，新建的对象自动获取当前的时间和日期。</p><p>创建日期对象并指定时间</p><p>​    <strong>var d = new Date(“2015/08/22”);</strong></p><p>​    <strong>var d = new Date(2016,04,13,14,34);</strong></p><p>【注】time可以是“2015/08/22”， “2015-08-22”  ，或1970年当前日期的毫秒数56521211021</p><h4 id="5、日期对象Date（格式化方法，了解即可）"><a href="#5、日期对象Date（格式化方法，了解即可）" class="headerlink" title="5、日期对象Date（格式化方法，了解即可）"></a>5、日期对象Date（格式化方法，了解即可）</h4><table><thead><tr><th>alert(box.toDateString());</th><th>//以特定的格式显示星期几、月、日和年</th></tr></thead><tbody><tr><td>alert(box.toTimeString());</td><td>//以特定的格式显示时、分、秒和时区</td></tr><tr><td>alert(box.toLocaleDateString());</td><td>//以特定地区格式显示星期几、月、日和年</td></tr><tr><td>alert(box.toLocaleTimeString());</td><td>//以特定地区格式显示时、分、秒和时区</td></tr><tr><td>alert(box.toUTCString());</td><td>//以特定的格式显示完整的 UTC 日期。</td></tr></tbody></table><h4 id="6、日期对象Date方法"><a href="#6、日期对象Date方法" class="headerlink" title="6、日期对象Date方法"></a>6、日期对象Date方法</h4><p>x(“2015-08-24”);</p><p>//转换格式默认支持2015-08-24或2015/08/24</p><p>//返回距离1970年1月1日0时的毫秒数</p><p>d.getTime()/d.setTime()</p><p>getTime获取某个日期自1970年以来的毫秒数</p><p>setTime修改日期的毫秒数，对应的日期时间也会修改</p><p>var myDate = new Date();</p><p>myDate.getTime();</p><h4 id="7、日期对象方法"><a href="#7、日期对象方法" class="headerlink" title="7、日期对象方法"></a>7、日期对象方法</h4><h5 id="重点记忆（set-get既能获取又能够赋值-get只能获取）"><a href="#重点记忆（set-get既能获取又能够赋值-get只能获取）" class="headerlink" title="重点记忆（set/get既能获取又能够赋值    get只能获取）"></a>重点记忆（set/get既能获取又能够赋值    get只能获取）</h5><blockquote><p>调用格式： 日期对象.方法()</p></blockquote><p>set/getDate() 从Date对象中返回一个月中的某一天(1~31)</p><p>getDay() 从Date对象返回一周中的某一天(0~6 )    获取日期星期几（0~6）0是周日</p><p>set/getMonth() 从Date对象中返回月份(0~11)对应（1~12）</p><p>set/getFullYear() 从Date对象以四位数返回年份</p><p>set/getHours() 返回Date对象的小时(0~23)</p><p>set/getMinutes() 返回Date对象的分钟(0~59)</p><p>set/getSeconds() 返回Date对象的秒数(0~59)</p><p>set/getMilliseconds()   返回Date对象的毫秒</p><p>set/getTime() 返回1970年1月1日至今的毫秒数</p><p>getTimezoneOffset()     返回本地时间与格林威治标准时间(GMT)的分钟差</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><h4 id="setInterval-函数，毫秒数"><a href="#setInterval-函数，毫秒数" class="headerlink" title="setInterval(函数，毫秒数)"></a>setInterval(函数，毫秒数)</h4><p>此处函数不加小括号，此处含义是把函数传过去让他执行</p><p>格式： var timer = setInterval(show, 1000);</p><p>返回值：当前定时器的编码</p><h4 id="clearInterval（timer）；-关闭定时器"><a href="#clearInterval（timer）；-关闭定时器" class="headerlink" title="clearInterval（timer）；//关闭定时器"></a>clearInterval（timer）；//关闭定时器</h4><p>函数写法：</p><p>1、</p><p>function show(){</p><p>}</p><p>2、</p><p>var show = function(){</p><p>}</p><p>show();</p><p>所以上面写法可以替换为</p><p>格式： setInterval( function(){</p><p>}, 1000);</p><p>此处函数叫做匿名函数；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、Math对象&quot;&gt;&lt;a href=&quot;#1、Math对象&quot; class=&quot;headerlink&quot; title=&quot;1、Math对象&quot;&gt;&lt;/a&gt;1、Math对象&lt;/h2&gt;&lt;h4 id=&quot;Math-random&quot;&gt;&lt;a href=&quot;#Math-random&quot; class
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>字符串String</title>
    <link href="http://www.luozy.top/2018/10/23/%E5%AD%97%E7%AC%A6%E4%B8%B2String/"/>
    <id>http://www.luozy.top/2018/10/23/字符串String/</id>
    <published>2018-10-23T07:15:27.000Z</published>
    <updated>2018-10-24T01:28:36.309Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>所有使用单引号或者双引号括起来的内容，都叫字符串。</p><p>​    【注】单引号和双引号没有区别，单引号如果嵌套，要交替使用。</p><p>声明字符串</p><p>1、new</p><p>var str = new String(1000);</p><p>alert(typeof str);//object</p><p>2、省略new 声明字符串</p><p>var str2 = String(1000);</p><p>alert(typeof str);//String</p><p>var str = “1000”;</p><p>alert(typeof str);//string</p><blockquote><p>上述三种不同声明方法使用起来没有区别</p></blockquote><h4 id="字符串数据类型"><a href="#字符串数据类型" class="headerlink" title="字符串数据类型"></a>字符串数据类型</h4><p>​    即是基本数据类型，又是复合数据类型。</p><p>变量存的是字符串的地址</p><p>字符串只读一旦被声明就没法修改，只能抹去重新赋值</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>str.length</p><p>返回当前字符串中字符个数，汉字相当于一个字符；</p><p>访问字符串某一个字符</p><p>可以通过 str[下标]</p><p>【注】只读不可修改</p><p>+拼接字符串</p><h2 id="方法（注意方法调用要加小括号-）"><a href="#方法（注意方法调用要加小括号-）" class="headerlink" title="方法（注意方法调用要加小括号()）"></a>方法（注意方法调用要加小括号()）</h2><h5 id="big-用大号字体显示字符串"><a href="#big-用大号字体显示字符串" class="headerlink" title="big()                 用大号字体显示字符串"></a>big()                 用大号字体显示字符串</h5><h5 id="blink-显示闪动字符串-IE下无效"><a href="#blink-显示闪动字符串-IE下无效" class="headerlink" title="blink()              显示闪动字符串(IE下无效)"></a>blink()              显示闪动字符串(IE下无效)</h5><h5 id="bold-使用粗体显示字符串"><a href="#bold-使用粗体显示字符串" class="headerlink" title="bold()               使用粗体显示字符串"></a>bold()               使用粗体显示字符串</h5><h5 id="fixed-以打字机文本显示字符串"><a href="#fixed-以打字机文本显示字符串" class="headerlink" title="fixed()              以打字机文本显示字符串"></a>fixed()              以打字机文本显示字符串</h5><h5 id="strike-使用删除线来显示字符串"><a href="#strike-使用删除线来显示字符串" class="headerlink" title="strike()             使用删除线来显示字符串"></a>strike()             使用删除线来显示字符串</h5><h5 id="fontcolor-使用指定颜色来显示字符串"><a href="#fontcolor-使用指定颜色来显示字符串" class="headerlink" title="fontcolor()       使用指定颜色来显示字符串"></a>fontcolor()       使用指定颜色来显示字符串</h5><h5 id="fontsize-使用指定尺寸来显示字符串"><a href="#fontsize-使用指定尺寸来显示字符串" class="headerlink" title="fontsize()         使用指定尺寸来显示字符串"></a>fontsize()         使用指定尺寸来显示字符串</h5><h5 id="link-将字符串显示为链接"><a href="#link-将字符串显示为链接" class="headerlink" title="link()                将字符串显示为链接"></a>link()                将字符串显示为链接</h5><h5 id="sub-把字符串显示为下标"><a href="#sub-把字符串显示为下标" class="headerlink" title="sub()                把字符串显示为下标"></a>sub()                把字符串显示为下标</h5><h5 id="sup-把字符串显示为上标"><a href="#sup-把字符串显示为上标" class="headerlink" title="sup()                把字符串显示为上标"></a>sup()                把字符串显示为上标</h5><p>document.write()中使用,用特殊的样式输出该字符串。</p><h3 id="字符串的方法-字符串的获取方法"><a href="#字符串的方法-字符串的获取方法" class="headerlink" title="字符串的方法-字符串的获取方法"></a>字符串的方法-字符串的获取方法</h3><p>charAt(3)         <strong>//获取下标为3的字符</strong></p><p>charCodeAt(3)     <strong>//获取下标为3的字符的编码</strong></p><p>【注】上述两个方法使用字符串对象调用</p><p>fromCharCode(94)  <strong>//编码转换成字符</strong></p><p> 该方法是 String 的静态方法，所以用String调用，        </p><p>如：var str = String.fromCharCode(97,98,99);</p><h3 id="字符串的查找方法"><a href="#字符串的查找方法" class="headerlink" title="字符串的查找方法"></a>字符串的查找方法</h3><p>​    <1>indexOf(“abc”, start);   查找字符串第一次出现的位置，可以传两个参数</1></p><p>​    <2>lastIndexOf(“abc”);      查找字符串最后一次出现的位置  如果没有找到  返回-1</2></p><p>​    <3>search()  正则匹配(返回出现的位置)</3></p><h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h4><p>格式： supStr.indexOf(subStr, start);</p><p>参数： subStr 子串 start 开始查找的位置</p><p>功能： 在supStr中找出subStr第一次出现的位置，从start得到位置开始找</p><p>返回值： -1没找到</p><p>​        &gt;=0 找到了并返回位置</p><h4 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h4><p>与indexOf类似不过是从后往前找</p><h4 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h4><p>格式： supStr.search(subStr/正则表达式);//只有一个参数</p><p>功能： 在supStr中找出subStr第一次出现的位置</p><p>ps：正则表达式是个功能更加强大的字符串</p><p>返回值： -1没找到</p><p>​        &gt;=0 找到了并返回位置</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><h4 id="replace-替换"><a href="#replace-替换" class="headerlink" title="replace()替换"></a>replace()替换</h4><p>格式： supStr.replace(oldStr/ 正则表达式，newStr);</p><p>功能:    用newstr替换oldStr；</p><p>返回值： 新生成的字符串//不会改变原来的字符串；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"how are you”;</span></span><br><span class="line"><span class="string"> alert(str);//"</span>how are you”;</span><br><span class="line">     alert(str.replace(“are”, “old are”)); <span class="comment">//"how old are you”;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的替换只能执行一次，不能够进行全局匹配，如果需要全局匹配，则应使用正则表达式： str.replace(/are/gi,"old are") g表示进行全局匹配，i表示匹配的时候忽略大小写</span></span><br></pre></td></tr></table></figure><h4 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h4><p>和数组slice工能类似</p><p>格式： 字符串.substring（start，end）；</p><p>功能： 提取指定范围内的字符串，生成一个新的字符串[start, end)</p><h4 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h4><p>格式： 字符串.splite(分隔符， 数字) ；</p><p>参数： 第二个：控制返回的数组中元素的个数，一般情况下不传；</p><p>功能： 用分隔符将字符串分割成小的字符串，放在数组中；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;Hello world , hi&quot;</span><br><span class="line">var strArr = str.split(&quot; &quot;);//Hello,world,,,hi</span><br><span class="line"></span><br><span class="line">//特殊用法使用空字符串分割</span><br><span class="line">结果：将字符串每个字符分割放在数组里；</span><br></pre></td></tr></table></figure><h4 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase()"></a>toLowerCase()</h4><p>转小写</p><h4 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase()"></a>toUpperCase()</h4><p>转大写</p><table><thead><tr><th>不改变原来字符串，而是生成新的字符串会改变原字符串</th><th>会改变原字符串</th></tr></thead><tbody><tr><td>replace</td><td>无</td></tr><tr><td>concat</td><td></td></tr><tr><td>split</td><td></td></tr><tr><td>substr</td><td></td></tr><tr><td></td></tr></tbody></table><table><thead><tr><th>修改原数组</th><th>不修改原数组</th></tr></thead><tbody><tr><td>pop push</td><td>concat</td></tr><tr><td>push  shift</td><td></td></tr><tr><td>reverse</td><td></td></tr><tr><td>splice</td><td></td></tr><tr><td></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">st-&gt;op-&gt;condasd</span><br></pre></td></tr></table></figure><p>substr与substring区别</p><p>substr返回的字符串包括结束处字符，而substring不包括</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h1&gt;&lt;p&gt;所有使用单引号或者双引号括起来的内容，都叫字符串。&lt;/p&gt;
&lt;p&gt;​    【注】单引号和双引号没有区别，
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>let和var的区别</title>
    <link href="http://www.luozy.top/2018/10/23/let%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.luozy.top/2018/10/23/let和var的区别/</id>
    <published>2018-10-23T03:32:43.000Z</published>
    <updated>2018-10-23T06:04:30.825Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="let与var"><a href="#let与var" class="headerlink" title="let与var"></a>let与var</h1><p>let是ES6新增的变量类型，是用来替代var的设计，与var不同的是：</p><p>1、let使用块级作用域<br>2、let不支持在同作用域中声明标识符相同的变量<br>3、let用TDZ禁止了声明前访问<br>我们一条一条说明：</p><p>1、JavaScript的作用域（scope）只有全局和局部，对于var声明的变量，只有函数才能为它创建新的作用域，而let支持块级作用域，花括号就能为它创建新的作用域；<br>2、相同作用域，var可以反复声明相同标识符的变量，而let是不允许的;<br>3、let声明的变量禁止在声明前访问，这也是为什么很多人认为let是不支持变量提升的原因，但真的是这样吗？我们来讨论这个问题：</p><p>我们先说明一下什么是变量提升（hoisting）</p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p><a href="https://blog.csdn.net/demo_18/article/details/78493489" target="_blank" rel="noopener">https://blog.csdn.net/demo_18/article/details/78493489</a></p><p>先上一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"hey I am now hoisting"</span>;</span><br></pre></td></tr></table></figure><p>看起来，我们在a被声明前调用a，没有报错，反而是返回一个undefined值，原因是：a其实已经在调用前被声明了，只是没有被初始化。JavaScript会把作用域里的所有变量和函数提到函数的顶部声明，相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">"hey I am now hoisting"</span>;</span><br></pre></td></tr></table></figure><p>JavaScript会使用undefined缺省值创建变量a，注意，事实上浏览器并没有把声明语句放到作用域的顶部，在编译阶段，控制流进入域，该域所有的变量和函数的声明先进入内存，文中代码的相对位置不会变动的。</p><p>由此可以知道，变量提升指的是变量声明的提升，不会提升变量的初始化和赋值。</p><p>对于let来说，情况有点不同:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//Uncaught ReferenceError: a is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">"hey I am now hoisting"</span>;</span><br><span class="line"></span><br><span class="line">这里抛出了一个错误，浏览器认为a并没有声明，这是否意味着<span class="keyword">let</span>并没有使a变量提升呢？我们再看一个例子</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">"hey I am outside"</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//Uncaught ReferenceError: a is not defined</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">"hey I am inside"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看，这里同样抛出了一个错误，认为a没有声明，但是，如果a没有变量提升，执行到console.log时应该是输出全局作用域中的a，而不是出现错误。</p><p>我们可以推知，这里确实出现了变量提升，而我们不能够访问的原因事实上是因为let的死区（temporal dead zone）设计：当前作用域顶部到该变量声明位置中间的部分，都是该let变量的死区，在死区中，禁止访问该变量。由此，我们给出结论，let声明的变量存在变量提升， 但是由于死区我们无法在声明前访问这个变量。</p><h5 id="最后要指出的是，函数也是存在提升（hoisting）的，并且，函数的提升不同于变量的提升，函数相当于把自己的声明、赋值整个的放到了当前作用域的顶部。"><a href="#最后要指出的是，函数也是存在提升（hoisting）的，并且，函数的提升不同于变量的提升，函数相当于把自己的声明、赋值整个的放到了当前作用域的顶部。" class="headerlink" title="最后要指出的是，函数也是存在提升（hoisting）的，并且，函数的提升不同于变量的提升，函数相当于把自己的声明、赋值整个的放到了当前作用域的顶部。"></a>最后要指出的是，函数也是存在提升（hoisting）的，并且，函数的提升不同于变量的提升，函数相当于把自己的声明、赋值整个的放到了当前作用域的顶部。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;let与var&quot;&gt;&lt;a href=&quot;#let与var&quot; class=&quot;headerlink&quot; title=&quot;let与var&quot;&gt;&lt;/a&gt;let与var&lt;/h1&gt;&lt;p&gt;let是ES6新增的变量类型，是用来替代var的设计，与var不同的是：&lt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ECMA5新增标签</title>
    <link href="http://www.luozy.top/2018/10/23/ECMA5%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE/"/>
    <id>http://www.luozy.top/2018/10/23/ECMA5新增标签/</id>
    <published>2018-10-23T02:41:52.000Z</published>
    <updated>2018-10-23T07:15:14.866Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="学习目标："><a href="#学习目标：" class="headerlink" title="学习目标："></a>学习目标：</h3><ol><li>ECMA5新增知识点</li><li>严格模式</li><li>新增数组方法</li><li>新增字符串方法</li><li>认识字符串，字符串概念</li><li>字符串的属性和函数</li><li>字符串练习</li><li>实现登录注册严格模式</li></ol><p>  除了正常运行模式，ECMAscript 5 添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。</p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>1、在严格模式下，声明变量必须使用var；</p><p>2、在严格模式下， 函数参数不能重名；</p><p>3、</p><p>this无法指向全局对象；</p><script>   “use strict”;    console.log(“已经进入严格模式”);    function a(){        this.b = 10; //报错，因为this是undefined    }    a();</script><p>4、在严格模式下，arguments存储的是函数传参时候的参数，在修改参数值后，arguments里面的值不会改变；    4.1arguments对象不允许被动态改变：</p><p>5、在严格模式下，新增保留字：implements, interface, let, package, private, protected, public, static, yield。</p><h2 id="ECMA新增的数组方法"><a href="#ECMA新增的数组方法" class="headerlink" title="ECMA新增的数组方法"></a>ECMA新增的数组方法</h2><h3 id="indexOf-data-start"><a href="#indexOf-data-start" class="headerlink" title="indexOf(data,start);"></a>indexOf(data,start);</h3><p>格式：数组.indexOf(data, start);</p><p>参数： data     要查找的元素；</p><p>​         start      从哪个位置开始查找</p><p>功能：查找某一个元素在数组中第一次出现的位置。</p><p>返回值：-1没找到； &gt;=找到了</p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>功能：数组遍历</p><p>var arr = [‘num1’,’num2’];</p><p>arr.forEach(function(item, index, array){</p><p>​    }</p><p>)</p><p>item    当前遍历到的元素num1;num2；</p><p>index    当前遍历到的元素的下标0；1</p><p>array    遍历的数组本身num1,num2</p><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>会遍历当前数组，然后调用参数中的方法，返回当前方法的返回值;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arr</span>)</span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item + <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//map不会改变原有数组，而是将函数执行一次之后的返回值组成一个数组，返回回来。</span></span><br></pre></td></tr></table></figure><h3 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter() 过滤"></a>filter() 过滤</h3><p>var res = [88,69,92,77,90,96,98,99].filter(function(item, index, array){ </p><p>​    return item&gt;80; //找出所有大于80的元素 </p><p>}); </p><p>结果：[88,92,90,96,98,99];//影响原数组</p><h3 id="reduce-归并"><a href="#reduce-归并" class="headerlink" title="reduce()归并"></a>reduce()归并</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre, next, index, array</span>)</span>&#123; </span><br><span class="line">    <span class="comment">//参数中的x和y，代表了之前的处理结果和下一个元素 return x+y; //return的结果会赋值给下一个函数的x参数 </span></span><br><span class="line">&#125;); 结果 ： <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="some-某些"><a href="#some-某些" class="headerlink" title="some()某些"></a>some()某些</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>([<span class="string">"yt"</span>,<span class="string">"hr"</span>,<span class="string">"wc"</span>,<span class="string">"jk"</span>].some(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123; </span><br><span class="line"><span class="comment">//判断数组中是否存在yt？ 如果找到了匹配的元素就不在运行了</span></span><br><span class="line">    <span class="keyword">return</span> item==<span class="string">"yt”; </span></span><br><span class="line"><span class="string">&#125;))&#123; </span></span><br><span class="line"><span class="string">    alert("</span>好的！<span class="string">"); </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><p>跟some一样，但要求每一项都符合，才返回true 有一项不合格就返回false</p><h3 id="String的trim方法"><a href="#String的trim方法" class="headerlink" title="String的trim方法"></a>String的trim方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" abc "</span>.trim(); </span><br><span class="line">首尾去空格 </span><br><span class="line"><span class="string">"abc"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;学习目标：&quot;&gt;&lt;a href=&quot;#学习目标：&quot; class=&quot;headerlink&quot; title=&quot;学习目标：&quot;&gt;&lt;/a&gt;学习目标：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;ECMA5新增知识点&lt;/li&gt;
&lt;li&gt;严格模式&lt;/li&gt;
&lt;li&gt;新增数组方
      
    
    </summary>
    
    
      <category term="H5 js" scheme="http://www.luozy.top/tags/H5-js/"/>
    
  </entry>
  
  <entry>
    <title>js排序</title>
    <link href="http://www.luozy.top/2018/10/22/js%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.luozy.top/2018/10/22/js排序/</id>
    <published>2018-10-22T07:32:22.000Z</published>
    <updated>2018-10-23T03:05:14.294Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="系统自带"><a href="#系统自带" class="headerlink" title="系统自带"></a>系统自带</h2><p>系统有自带的sort排序方法，但是他是对字符串进行判断排序</p><p>所以要对数字排序要给他写一个判断方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">sequence</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a &lt; b)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">5</span> ,<span class="number">56</span>, <span class="number">65</span>, <span class="number">84</span>, <span class="number">98</span>];</span><br><span class="line">alert(arr.sort(sequence));</span><br></pre></td></tr></table></figure><h2 id="用户编写"><a href="#用户编写" class="headerlink" title="用户编写"></a>用户编写</h2><h3 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h3><p>​                数组：9, 8, 7, 6, 5, 4<br>​                第一轮：五次<br>​                    9, 8, 7, 6, 5, 4<br>​                    8, 9, 7, 6, 5, 4<br>​                    8, 7, 9, 6, 5, 4<br>​                    8, 7, 6, 9, 5, 4<br>​                    8, 7, 6, 5, 9, 4<br>​                    8, 7, 6, 5, 4, 9</p><p>​                第二轮：四次<br>​                    8, 7, 6, 5, 4<br>​                    7, 8, 6, 5, 4<br>​                    7, 6, 8, 5, 4<br>​                    7, 6, 5, 8, 4<br>​                    7, 6, 5, 4, 8</p><p>​                第三轮：三次<br>​                    7, 6, 5, 4<br>​                    6, 7, 5, 4<br>​                    6, 5, 7, 4<br>​                    6, 5, 4, 7</p><p>​                第四轮：两次<br>​                    6, 5, 4<br>​                    5, 6, 4<br>​                    5, 4, 6</p><p>​                第五轮：一次<br>​                    5, 4<br>​                    4, 5</p><p>规律：</p><p>1、数组长度6</p><p>2、比较五轮 = 数组长度 - 1</p><p>3、数组长度 = 轮数 + 每一轮的次数</p><p>​    每一轮的次数 = 数组长度 - 轮数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bubbleSort(arr)&#123;</span><br><span class="line">    <span class="comment">//比较的轮数（arr.length-1）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//j每一轮比较的次数（数组长度 - 轮数）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">                arr[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h3><p>打擂台法</p><p>选择排序<br>​                第一轮：<br>​                    9, 8, 7, 6, 5, 4<br>​                    8, 9, 7, 6, 5, 4<br>​                    7, 9, 8, 6, 5, 4<br>​                    6, 9, 8, 7, 5, 4<br>​                    5, 9, 8, 7, 6, 4<br>​                    4, 9, 8, 7, 6, 5</p><p>​                第二轮：<br>​                       9, 8, 7, 6, 5<br>​                       8, 9, 7, 6, 5<br>​                       7, 9, 8, 6, 5<br>​                       6, 9, 8, 7, 5<br>​                       5, 9, 8, 7, 6</p><p>​                第三轮：<br>​                          9, 8, 7, 6<br>​                          8, 9, 7, 6<br>​                          7, 9, 8, 6<br>​                          6, 9, 8, 7</p><p>​                第四轮：</p><p>​                          9, 8, 7<br>​                          8, 9, 7<br>​                          7, 9, 8<br>​                第五轮：<br>​                         9, 8<br>​                         8, 9</p><p>规律：</p><p>​    通过比较首先选出最小的数放在第一个位置上，然后在其余的数中选出次小数放在第二个位置上,依此类推,直到所有的数成为有序序列。</p><p>​    轮数： 数组长度 -  1</p><p>​    每一轮比较次数：数组长度 - 当前轮数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j])&#123;</span><br><span class="line">                <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;系统自带&quot;&gt;&lt;a href=&quot;#系统自带&quot; class=&quot;headerlink&quot; title=&quot;系统自带&quot;&gt;&lt;/a&gt;系统自带&lt;/h2&gt;&lt;p&gt;系统有自带的sort排序方法，但是他是对字符串进行判断排序&lt;/p&gt;
&lt;p&gt;所以要对数字排序要给他写
      
    
    </summary>
    
    
      <category term="H5 js" scheme="http://www.luozy.top/tags/H5-js/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript组成</title>
    <link href="http://www.luozy.top/2018/10/20/JavaScript%E7%BB%84%E6%88%90/"/>
    <id>http://www.luozy.top/2018/10/20/JavaScript组成/</id>
    <published>2018-10-20T09:22:14.000Z</published>
    <updated>2018-10-23T03:06:52.035Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="JavaScript组成部分——ECMAScript、DOM、BOM"><a href="#JavaScript组成部分——ECMAScript、DOM、BOM" class="headerlink" title="JavaScript组成部分——ECMAScript、DOM、BOM"></a>JavaScript组成部分——ECMAScript、DOM、BOM</h2><blockquote><p>虽然 JavaScript 和 ECMAScript 通常被人们用来表达相同的含义，但 JavaScript 的含义却比ECMA-262标准中规定的要多得多。 一个完整的JavaScript应该由下列三个不同的部分组成</p></blockquote><h3 id="核心（ECMAScript）"><a href="#核心（ECMAScript）" class="headerlink" title="核心（ECMAScript）"></a>核心（ECMAScript）</h3><blockquote><p>​    ECMAScript是一种由ECMA国际（前身为欧洲计算机制造商协会，英文名为European Computer Manufacters Association）通过ECMA-262标准化的脚本程序设计语言。ECMAScript定义的只是这门语言的基础，而在此基础上可以构建更完善的脚本语言。我们常见的Web浏览器只是ECMAScript实现可能的宿主环境之一。组成部分有：语法、类型、语句、关键字、保留字、操作符、对象等。</p><p>​    目前ECMAScript有6个版本，分别是<strong>ECMAScript1</strong>、<strong>ECMAScript2</strong>、<strong>ECMAScript3</strong>、<strong>ECMAScript4</strong>（由于制定时分歧过大，并未正式布）、<strong>ECMAScript5、ECMAScript2015</strong>。截止发布日期，JavaScript的官方名称是ECMAScript 2015，下一版本将于今年（2016年）发布，命名为ECMAScript 2016。从2015年开始，新版本将按照ECMAScript+年份的形式发布。</p></blockquote><p>文档对象模型（DOM）——对应Document对象；</p><blockquote><p>​    一个与系统平台和编程语言无关的接口，程序和脚本可以通过这个接口动态访问和修改文档的内容、结构和样式。</p><p>​    DOM把一份文档理解为一颗家谱树（节点数），分别为parent（父节点）、child（子节点）、sibling（兄弟节点），如下图：</p><p>​    <img src="https://images2015.cnblogs.com/blog/920443/201605/920443-20160525093958709-1057258632.png" alt="img"></p><p>文档由节点组成的集合，节点有以下几种类型</p><p>​    元素节点（标签）、文本节点（包含在元素节点中）、属性节点（对元素做出更具体的描述）——几乎所有元素都有一个title属性</p></blockquote><p>DOM把整个网页映射成为一个多层节点</p><h3 id="浏览器对象模型（BOM）——对应window对象"><a href="#浏览器对象模型（BOM）——对应window对象" class="headerlink" title="浏览器对象模型（BOM）——对应window对象"></a>浏览器对象模型（BOM）——对应window对象</h3><p>他提供了很多对象，用于访问浏览器的功能；这些功能与人和网页内容无关；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;JavaScript组成部分——ECMAScript、DOM、BOM&quot;&gt;&lt;a href=&quot;#JavaScript组成部分——ECMAScript、DOM、BOM&quot; class=&quot;headerlink&quot; title=&quot;JavaScript组
      
    
    </summary>
    
    
      <category term="H5 js" scheme="http://www.luozy.top/tags/H5-js/"/>
    
  </entry>
  
  <entry>
    <title>js数组</title>
    <link href="http://www.luozy.top/2018/10/19/js%E6%95%B0%E7%BB%84/"/>
    <id>http://www.luozy.top/2018/10/19/js数组/</id>
    <published>2018-10-19T06:30:53.000Z</published>
    <updated>2018-10-24T03:51:14.098Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>//underfined、null、boolean、string、number为基本数值类型。逗号一并定义初始化多个变量。基本包装类型String、Boolean、Number通过valueOf()可以获取基本数值类型，可以实现自动装箱和拆箱操作。</p><blockquote><p>数组：存储批量数据的一个数据结构</p><p>数据类型：</p><p>​    基本数据类型：</p><p>​        数字</p><p>​        字符串</p><p>​        布尔值</p><p>​    特殊数据类型：</p><p>​        undefined null NaN</p><p>​    复合/引用数据类型：</p><p>​        数组</p></blockquote><h2 id="数组的声明和使用"><a href="#数组的声明和使用" class="headerlink" title="数组的声明和使用"></a>数组的声明和使用</h2><h3 id="声明数组三种方法"><a href="#声明数组三种方法" class="headerlink" title="声明数组三种方法"></a>声明数组三种方法</h3><p>1、var arr = new Array(10, true, “hello”);</p><p>2、var arr = Array(10 , true, “hello”);</p><p>3、var arr = [10, true, “hello”];</p><p>new Array()</p><p>Array()</p><p>​    如果传入参数的时候，仅仅传入了一个参数并且是个数字；</p><p>​    这是它的作用是声明了一个传入数字大小的数组，而不是把这个数字存了进去；</p><h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><p>数组元素：数组中的每一个数据</p><p>访问元素，通过下标（索引）访问。数组[下标]，下标从零开始</p><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p>1、for循环遍历</p><p>for(var i = 0; i&lt; arr.length; i++){</p><p>​    arr[i];</p><p>}</p><p>2、快速遍历（快速枚举）</p><blockquote><p>执行效率更高（但不稳定）</p><p>尽量在for in 的时候，不要增删数组中的元素。</p></blockquote><p>for(var i in arr){</p><p>​    arr[i];</p><p>}</p><h2 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h2><h3 id="1、栈方法-模拟栈结构"><a href="#1、栈方法-模拟栈结构" class="headerlink" title="1、栈方法(模拟栈结构)"></a>1、栈方法(模拟栈结构)</h3><p>特点：先进后出，从一头进同一一头出；</p><p>ECMAScript 数组提供了一种让数组的行为类似于其他数据结构的方法。也就是说，可 以让数组像栈一样，可以限制插入和删除项的数据结构。栈是一种数据结构(后进先出)，也 就是说最新添加的元素最早被移除。而栈中元素的插入(或叫推入)和移除(或叫弹出)，只发 生在一个位置——栈的顶部。ECMAScript 为<strong>数组</strong>专门提供了 <strong>push()</strong>和 <strong>pop()</strong>方法。</p><p><img src="C:\Users\罗中运\AppData\Local\Temp\chrome_drag6452_26913\Image.png" alt="Image"></p><h4 id="1、进栈："><a href="#1、进栈：" class="headerlink" title="1、进栈："></a>1、进栈：</h4><blockquote><p> push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回最该后数组的长度。</p></blockquote><p>push</p><p>格式：数组.push（参数一，参数二，。。。）；</p><p>功能：给原来的数组末尾加元素，直接修改原数组；</p><p>返回值：插完元素后，数组的长度；</p><h4 id="2、出栈："><a href="#2、出栈：" class="headerlink" title="2、出栈："></a>2、出栈：</h4><blockquote><p>二pop()方法则从数组末尾移除最后一个元素，减少数组的length值，然后返回移除的元素。</p></blockquote><p>pop</p><p>格式：数组.pop();</p><p>功能：在原来数组末尾取出一个元素；</p><p>返回值：取出的元素；</p><h3 id="2、队列方法（模拟队列）"><a href="#2、队列方法（模拟队列）" class="headerlink" title="2、队列方法（模拟队列）"></a>2、队列方法（模拟队列）</h3><p>特点：先进先出，从头部进，从尾部出；</p><p>队列在数组的末端添加元素，从数组的前端移除元素。通过push()想数组末尾添加一个元素，然后通过shift()方法从数组前端移除一个元素。</p><p><img src="C:\Users\罗中运\AppData\Local\Temp\chrome_drag6452_6292\Image.png" alt="Image"></p><p>1、shift() </p><blockquote><p> 方法可以移除数组首元素，并且返回长度</p></blockquote><p>孪生元素：unshift（）：从数组头部插入元素，返回插入后数组的长度；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alert(box.push(<span class="string">"深圳”));      //数组末尾添加一个元素，并且返回长度</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">alert(box.shift());                 //移除数组开头元素，并返回移除元素</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">alert(box.unshift());             //数组开头添加两个元素</span></span><br></pre></td></tr></table></figure><p>2.push（）</p><h2 id="复合数据类型与基本数据类型"><a href="#复合数据类型与基本数据类型" class="headerlink" title="复合数据类型与基本数据类型"></a>复合数据类型与基本数据类型</h2><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><strong>基本数据类型</strong></h4><h5 id="在声明变量，var-num2-num1赋值的时候引用没变，只是数值变了；"><a href="#在声明变量，var-num2-num1赋值的时候引用没变，只是数值变了；" class="headerlink" title="在声明变量，var num2 = num1赋值的时候引用没变，只是数值变了；"></a>在声明变量，var num2 = num1赋值的时候引用没变，只是数值变了；</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num2 = num1;</span><br><span class="line"></span><br><span class="line">num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">alert(num1);<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">alert(num2);<span class="comment">//20</span></span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h4><h5 id="gt-在进行arr2-arr1的时候实际上是将引用赋值了过去；这时候他们的引用（地址）不同但是所指向的内容（堆）相同；"><a href="#gt-在进行arr2-arr1的时候实际上是将引用赋值了过去；这时候他们的引用（地址）不同但是所指向的内容（堆）相同；" class="headerlink" title="&gt; 在进行arr2=arr1的时候实际上是将引用赋值了过去；这时候他们的引用（地址）不同但是所指向的内容（堆）相同；"></a>&gt; 在进行arr2=arr1的时候实际上是将引用赋值了过去；这时候他们的引用（地址）不同但是所指向的内容（堆）相同；</h5><p>​    程序在运行之前，会给程序预先分配好程序运行的空间；    </p><p>​    程序运行段 程序运行内存；这部分一旦被申请，就没法修改；</p><p>​    复合数据类型存储在叫做<strong>堆</strong>的内存中；</p><p><strong>也就是内容实际是存在堆里面，程序运行段内存存的是堆的引用；</strong></p><h5 id="在复合数据类型变量里面，只存这个数据的地址；"><a href="#在复合数据类型变量里面，只存这个数据的地址；" class="headerlink" title="在复合数据类型变量里面，只存这个数据的地址；"></a>在复合数据类型变量里面，只存这个数据的地址；</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">"num1"</span>,<span class="string">"num2"</span>,<span class="string">"num3"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = arr1;</span><br><span class="line"></span><br><span class="line">arr2.push(<span class="string">"num4"</span>);</span><br><span class="line"></span><br><span class="line">alert(arr1);<span class="comment">//num1,num2,num3,num4</span></span><br><span class="line"></span><br><span class="line">alert(arr2);<span class="comment">//num1,num2,num3,num4</span></span><br></pre></td></tr></table></figure><h3 id="concat方法"><a href="#concat方法" class="headerlink" title="concat方法"></a>concat方法</h3><p>1、功能1：生成一个新数组；</p><p>2、功能 2：进行数组合并，生成一个合并后的新数组；</p><p>​    格式：数组2 = concat（数组1，元素1，元素2，…）；</p><p>var arr2 = arr1.concat();//生成了一个新数组赋值给arr2，而不是将引用（地址）赋值给arr2；</p><p><img src="https://img-blog.csdn.net/20161022234725144" alt="这里写图片描述">；</p><h3 id="slice方法"><a href="#slice方法" class="headerlink" title="slice方法"></a>slice方法</h3><p>格式： 数组.slice（start，end）；</p><p>参数：start 开始提取的位置</p><p>​    end 结束提取的位置</p><p>​    提取的元素范围[start,end)；</p><h5 id="提取元素但不会修改原数组"><a href="#提取元素但不会修改原数组" class="headerlink" title="提取元素但不会修改原数组"></a>提取元素但不会修改原数组</h5><p>返回值：提取到的元素，组成的元素；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&quot;num1&quot;,&quot;num2&quot;,&quot;num3&quot;];</span><br><span class="line">var arr2 = arr1.slice(1,2);//num2</span><br></pre></td></tr></table></figure><h3 id="splice方法"><a href="#splice方法" class="headerlink" title="splice方法"></a>splice方法</h3><p>功能：增删改数组</p><blockquote><p>格式：数组.splice(start,length,元素1，元素2，…)；</p><p>功能1：删除选中的元素：数组.splice(start,length）；</p><p>功能2：插入元素数组.splice(start,0，元素1，元素2，….）；</p><p>功能3：混合使用 数组.splice(start,1，元素);//替换了start位置的元素；</p><p>返回值是删除元素的数组；</p><p>第一个参数：开始截取的下标</p><p>第二个参数：截取元素的长度</p><p>第三个和之后的参数，插入的元素</p></blockquote><h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><p>将数组的元素组起一个字符串，</p><blockquote><p>格式“数组.jion（字符串）；</p><p>参数：拼接的拼接符</p><p>返回值：拼接完成的字符串；</p></blockquote><h4 id="reverse方法"><a href="#reverse方法" class="headerlink" title="reverse方法"></a>reverse方法</h4><blockquote><p>数组逆置 </p></blockquote><p>ps :<strong>concat slice jion不修改原数组；</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;//underfined、null、boolean、string、number为基本数值类型。逗号一并定义初始化多个变量。基本包装类型String、Boolean、Number通过valueOf()可以获取基本数值类型，可以实现自动装箱和拆箱操作。
      
    
    </summary>
    
    
      <category term="H5 js" scheme="http://www.luozy.top/tags/H5-js/"/>
    
  </entry>
  
  <entry>
    <title>js作用域</title>
    <link href="http://www.luozy.top/2018/10/19/js%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://www.luozy.top/2018/10/19/js作用域/</id>
    <published>2018-10-19T01:17:42.000Z</published>
    <updated>2018-10-23T06:13:09.057Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>程序必须读到内存中，才能被CPU运行。</p><p>声明变量 分配内存空间的过程。</p><p>函数调用，函数运行的时候，需要内存空间来运行；</p><p>【注】</p><p>​    在某一函数内声明的变量或形参（形参在函数内和变量基本一致），它的生命周期是这个函数调用开始到这个函数调用结束，销毁；</p><h4 id="作用域："><a href="#作用域：" class="headerlink" title="作用域："></a>作用域：</h4><p>​    局部作用域：每一个函数都死一个局部作用域。</p><p>​            在局部作用域里面声明的变量和形参，叫局部变量；</p><p>​    全局作用域：在全局作用域里面声明的变量和形参，叫做全局变量；</p><h5 id="js中只有全局作用域和函数作用域"><a href="#js中只有全局作用域和函数作用域" class="headerlink" title="js中只有全局作用域和函数作用域"></a>js中只有全局作用域和函数作用域</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i =<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure><blockquote><p>可以执行，结果为10</p></blockquote><p>为什么呢，因为在JavaScript中不同于Java他没有块作用域；</p><p>当然在JavaScript中我们也可以实现块作用域的功能。如以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">)()</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure><blockquote><p>这种写法叫做立即调用函数表达式</p></blockquote><h4 id="访问数据："><a href="#访问数据：" class="headerlink" title="访问数据："></a>访问数据：</h4><p>​    1、就近原则</p><p>​    2、访问数据，如果当前作用域没有该数据，则从大一级的作用域寻找；</p><p>##### </p><h4 id="全局函数："><a href="#全局函数：" class="headerlink" title="全局函数："></a>全局函数：</h4><p>​    var a =function(x){</p><p>​        var b = ‘bb’;</p><p>​        return b;</p><p>​    }</p><p>【注】：如果不写var直接声明变量，那么这个变量将会被声明为全局变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;程序必须读到内存中，才能被CPU运行。&lt;/p&gt;
&lt;p&gt;声明变量 分配内存空间的过程。&lt;/p&gt;
&lt;p&gt;函数调用，函数运行的时候，需要内存空间来运行；&lt;/p&gt;
&lt;p&gt;【注】&lt;/p&gt;
&lt;p&gt;​    在某一函数内声明的变量或形参（形参在函数内和变量基本一
      
    
    </summary>
    
    
      <category term="H5 js" scheme="http://www.luozy.top/tags/H5-js/"/>
    
  </entry>
  
  <entry>
    <title>js函数的概念和作用</title>
    <link href="http://www.luozy.top/2018/10/18/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8/"/>
    <id>http://www.luozy.top/2018/10/18/js函数的概念和作用/</id>
    <published>2018-10-18T06:11:06.000Z</published>
    <updated>2018-10-23T03:06:30.919Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="JS函数及作用"><a href="#JS函数及作用" class="headerlink" title="JS函数及作用"></a>JS函数及作用</h1><ol><li>函数的概念，及作用</li><li>函数的声明</li><li>如何执行函数（调用）</li><li>函数的参数（实参，形参）,返回值</li><li>arguments</li><li>作用域</li><li>DOM的简单操作</li><li>递归</li></ol><blockquote><p>在js的世界里存在函数，函数是把强大的功能集中在一起；</p><p>调用函数，执行函数中具体的代码，最终把函数的功能实现了；</p><p>书写步骤：</p><p>​    1、在标签或文件里书写函数</p><p>​    2、在一处调用</p></blockquote><h3 id="1、概念："><a href="#1、概念：" class="headerlink" title="1、概念："></a>1、概念：</h3><p>函数就是把完成特定功能的一段代码[抽象出来]，使之成为程序中的一个<strong>[独立实体]</strong>，起个名字<strong>（函数名）</strong>。可以在同一个程序或其他程序中多次重复使用<strong>（通过函数名调用）</strong>。</p><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><ul><li>使程序变得简短而清晰</li><li>有利于程序维护</li><li>可以提高程序开发效率</li><li>提高了代码的重用性（复用性</li></ul><h3 id="2、声明函数"><a href="#2、声明函数" class="headerlink" title="2、声明函数"></a>2、声明函数</h3><p>function     函数名(){</p><p>​    具体要执行的代码；</p><p>}</p><h4 id="调用："><a href="#调用：" class="headerlink" title="调用："></a>调用：</h4><p>函数名();</p><h3 id="3、函数的分类"><a href="#3、函数的分类" class="headerlink" title="3、函数的分类"></a>3、函数的分类</h3><p>分三大类：</p><p>​    1、内置函数（系统函数）</p><p>​    2、用户自定义函数</p><p>​    3、事件驱动函数</p><h3 id="4、函数参数"><a href="#4、函数参数" class="headerlink" title="4、函数参数"></a>4、函数参数</h3><blockquote><p>不确定的值要当做参数去假设；</p><p>分为： 形参、实参</p><p>形参（形式上的参数）</p><p>传参：用实际的参数去代替原来形式上的参数。</p></blockquote><p>如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    alert(x + y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传参</span></span><br><span class="line">add(<span class="number">10</span>， <span class="number">20</span>)；</span><br></pre></td></tr></table></figure><h3 id="返回值（return）"><a href="#返回值（return）" class="headerlink" title="返回值（return）"></a>返回值（return）</h3><blockquote><p>可有可无</p><p>作用：</p><p>1、作为函数的值，return后面表达式的值就是函数的返回值；</p><p>2、在执行return后，函数后面的代码不会再执行；</p></blockquote><h4 id="编写一个函数"><a href="#编写一个函数" class="headerlink" title="编写一个函数"></a>编写一个函数</h4><p>1、确定未知量</p><p>也就是形参数量，多个形参通过逗号隔开；</p><p>2、编写函数；</p><p>3、确认返回值；（只会执行一个）</p><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><blockquote><p>每一个函数内部都有一个arguments</p></blockquote><p>功能： 当我们调用函数的时候，给函数传入实参，会全部存储在arguments里面。</p><p>使用arguments</p><p>​    arguments.length 传入了几个实参</p><p>​    arguments[下标]    通过索引访问</p><p>ps：为了让函数可读性更高，尽量不要用arguments</p><h3 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h3><p>特点：</p><p>​    1、函数自己调用自己；</p><p>​    2、递归函数一般都有参数；</p><p>​    3、递归函数一般都有return；</p><p>功能：</p><p>​    循环能做的，递归都能做，循环做不到的递归也能做；</p><p>作用：</p><p>​    精简代码</p><h4 id="递归的规律"><a href="#递归的规律" class="headerlink" title="递归的规律"></a>递归的规律</h4><p>​    1、找出临界值（），临界值无需计算直接可以得出</p><p>​    2、找出第n次和第n-1次的关系</p><p>​    3、假设函数运行，写出第n次和第n-1次的关系</p><p>1、递归会导致内存溢出，尾递归除外- -</p><p>2、为了能回溯，递归函数的参数和地址需要分配在 call stack 上，大部分语言的 call stack 大小都是有限的，递归太深就会爆掉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;JS函数及作用&quot;&gt;&lt;a href=&quot;#JS函数及作用&quot; class=&quot;headerlink&quot; title=&quot;JS函数及作用&quot;&gt;&lt;/a&gt;JS函数及作用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;函数的概念，及作用&lt;/li&gt;
&lt;li&gt;函数的声明&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="H5 js 函数" scheme="http://www.luozy.top/tags/H5-js-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
</feed>
