<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>luozy&#39;s Blog</title>
  
  <subtitle>Inflexible thinking, bad humor</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.luozy.top/"/>
  <updated>2018-10-31T02:08:47.239Z</updated>
  <id>http://www.luozy.top/</id>
  
  <author>
    <name>luozy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.luozy.top/2018/10/31/hello-world/"/>
    <id>http://www.luozy.top/2018/10/31/hello-world/</id>
    <published>2018-10-31T02:08:47.239Z</published>
    <updated>2018-10-31T02:08:47.239Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>事件</title>
    <link href="http://www.luozy.top/2018/10/31/%E4%BA%8B%E4%BB%B6/"/>
    <id>http://www.luozy.top/2018/10/31/事件/</id>
    <published>2018-10-31T01:57:14.000Z</published>
    <updated>2018-10-31T02:38:10.101Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内联模式"><a href="#内联模式" class="headerlink" title="内联模式"></a>内联模式</h3><p>​    这种模型是最传统接单的一种处理事件的方法。在内联模型中，事件处理函数是 HTML 标签的一个属性，用于处理指定事件。虽然内联在早期使用较多，但它是和 HTML 混写的， 并没有与 HTML 分离。</p><p>//在 HTML 中把事件处理函数作为属性执行 JS 代码</p><p>&lt;input type=”button”value=”按钮”onclick=”alert(‘Lee’);” /&gt;</p><p>//注意单双引号</p><p>//在 HTML 中把事件处理函数作为属性执行 JS 函数</p><p>&lt;input type=”button”value=”按钮”onclick=”box();” /&gt;</p><p>//执行 JS 的函数 </p><p>PS：函数不得放到 window.onload 里面，这样就看不见了。</p><h3 id="脚本模式"><a href="#脚本模式" class="headerlink" title="脚本模式"></a>脚本模式</h3><p>   由于内联模型违反了 HTML 与 JavaScript 代码层次分离的原则。为了解决这个问题，我们可以在 JavaScript 中处理事件。这种处理方式就是脚本模型。</p><p>var input=document.getElementsByTagName(‘input’)[0];</p><p>//得到 input 对象</p><p>input.onclick=function(){</p><p>//匿名函数执行</p><p>​         alert(‘Lee’);</p><p>};</p><p>PS：通过匿名函数，可以直接触发对应的代码。也可以通过指定的函数名赋值的方式 来执行函数(赋值的函数名不要跟着括号)。</p><p>input.onclick=box;   //把函数名赋值给事件处理函数</p><h4 id="3、事件处理函数"><a href="#3、事件处理函数" class="headerlink" title="3、事件处理函数"></a>3、事件处理函数</h4><p>JavaScript 可以处理的事件类型为：鼠标事件、键盘事件、HTML 事件。</p><p>PS：所有的事件处理函数都会都有两个部分组成，on+ 事件名称，例如 click 事件的事件处理函数就是：onclick。在这里，我们主要谈论脚本模型的方式来构建事件，违反分离原 则的内联模式，我们忽略掉。</p><h5 id="3-1-鼠标事件，页面所有元素都可触发"><a href="#3-1-鼠标事件，页面所有元素都可触发" class="headerlink" title="3.1.鼠标事件，页面所有元素都可触发"></a>3.1.鼠标事件，页面所有元素都可触发</h5><table><thead><tr><th>click：</th><th>当用户单击鼠标按钮或按下回车键时触发</th></tr></thead><tbody><tr><td>dblclick：</td><td>当用户双击主鼠标按钮时触发。</td></tr><tr><td>mousedown：</td><td>当用户按下了鼠标还未弹起时触发。</td></tr><tr><td>mouseup：</td><td>当用户释放鼠标按钮时触发。</td></tr><tr><td>mouseover：</td><td>当鼠标移到某个元素上方时触发。</td></tr><tr><td>mouseout：</td><td>当鼠标移出某个元素上方时触发。</td></tr><tr><td>mousemove：</td><td>当鼠标指针在元素上移动时触发。</td></tr></tbody></table><h5 id="3-2-键盘事件（1、快捷键2、输入文本）"><a href="#3-2-键盘事件（1、快捷键2、输入文本）" class="headerlink" title="3.2.键盘事件（1、快捷键2、输入文本）"></a>3.2.键盘事件（1、快捷键2、输入文本）</h5><blockquote><p>添加在1、全局（window）2、输入框</p><p>keyup keydown keypress</p></blockquote><p>keydown：当用户按下键盘上任意键触发，如果按住不放，会重复触发。</p><p>onkeydown=function(){</p><p>​        alert(‘Lee’);</p><p>};</p><p>keypress：当用户按下键盘上的字符键触发，如果按住不放，会重复触发</p><p>onkeypress= function(){</p><p>​        alert(‘Lee’);</p><p>};</p><p>keyup：当用户释放键盘上的键触发。</p><p>onkeyup=function() {</p><p>​        alert(‘Lee’);</p><p>};</p><h5 id="3-3HTML事件"><a href="#3-3HTML事件" class="headerlink" title="3.3HTML事件"></a>3.3HTML事件</h5><p>window事件</p><table><thead><tr><th>Scroll</th><th>页面滚动的时候触发</th></tr></thead><tbody><tr><td>Resize</td><td>当窗口大小发生变化触发</td></tr><tr><td>load</td><td>页面加载完成的时候触发</td></tr><tr><td>unload</td><td>页面解构的时候执行</td></tr></tbody></table><p>window.onscroll=function() { alert(‘Lee’); };</p><p>window.onresize=function(){ alert(‘Lee’); };</p><p>window.onload=function() { alert(‘Lee’); };</p><p>window.onunload= function(){ alert(‘Lee’); };</p><h5 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h5><table><thead><tr><th>blur</th><th>当文本失去焦点的时候触发</th></tr></thead><tbody><tr><td>focus</td><td>当获取焦点的时候触发</td></tr><tr><td>select</td><td>当用户选择文本框(input 或 textarea)中的一个或多个字符触发。</td></tr><tr><td>change</td><td>当文本框(input 或 textarea)内容改变且失去焦点后触发。</td></tr><tr><td>submit</td><td>当用户点击提交按钮在<form>元素上触发。//只有在form控件里触发</form></td></tr><tr><td>reset</td><td>当用户点击重置按钮在<form>元素上触发。//</form></td></tr></tbody></table><p>input.onblur=function(){ alert(‘Lee’); };</p><p>input.onfocus= function(){ alert(‘Lee’); };</p><p>input.onselect=function(){ alert(‘Lee’); };</p><p>input.onchange=function(){ alert(‘Lee’); };</p><p>form.onsubmit=function(){ alert(‘Lee’); };</p><p>form.onreset=function(){ alert(‘Lee’); };</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;内联模式&quot;&gt;&lt;a href=&quot;#内联模式&quot; class=&quot;headerlink&quot; title=&quot;内联模式&quot;&gt;&lt;/a&gt;内联模式&lt;/h3&gt;&lt;p&gt;​    这种模型是最传统接单的一种处理事件的方法。在内联模型中，事件处理函数是 HTML 标签的一个属性，用于处理指定事件
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Brower对象</title>
    <link href="http://www.luozy.top/2018/10/26/Brower%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.luozy.top/2018/10/26/Brower对象/</id>
    <published>2018-10-26T11:25:05.000Z</published>
    <updated>2018-10-26T11:53:25.418Z</updated>
    
    <content type="html"><![CDATA[<p>## </p><h2 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h2><p>Window 对象表示浏览器中打开的窗口。</p><p>如果文档包含框架（&lt;.frame &gt; 或 &lt;.iframe&gt; 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。</p><p><img src="http://www.runoob.com/images/lamp.gif" alt="Note"><strong>注意：</strong> 没有应用于 window 对象的公开标准，不过所有浏览器都支持该对象。</p><h2 id="Window-对象属性"><a href="#Window-对象属性" class="headerlink" title="Window 对象属性"></a>Window 对象属性</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/jsref/prop-win-closed.html" target="_blank" rel="noopener">closed</a></td><td>返回窗口是否已被关闭。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-defaultstatus.html" target="_blank" rel="noopener">defaultStatus</a></td><td>设置或返回窗口状态栏中的默认文本。</td></tr><tr><td><a href="http://www.runoob.com/jsref/dom-obj-document.html" target="_blank" rel="noopener">document</a></td><td>对 Document 对象的只读引用。(请参阅<a href="http://www.runoob.com/jsref/dom-obj-document.html" target="_blank" rel="noopener">对象</a>)</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-frames.html" target="_blank" rel="noopener">frames</a></td><td>返回窗口中所有命名的框架。该集合是 Window 对象的数组，每个 Window 对象在窗口中含有一个框架。</td></tr><tr><td><a href="http://www.runoob.com/jsref/obj-history.html" target="_blank" rel="noopener">history</a></td><td>对 History 对象的只读引用。请参数 <a href="http://www.runoob.com/jsref/obj-history.html" target="_blank" rel="noopener">History 对象</a>。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-innerheight.html" target="_blank" rel="noopener">innerHeight</a></td><td>返回窗口的文档显示区的高度。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-innerheight.html" target="_blank" rel="noopener">innerWidth</a></td><td>返回窗口的文档显示区的宽度。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-localstorage.html" target="_blank" rel="noopener">localStorage</a></td><td>在浏览器中存储 key/value 对。没有过期时间。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-length.html" target="_blank" rel="noopener">length</a></td><td>设置或返回窗口中的框架数量。</td></tr><tr><td><a href="http://www.runoob.com/jsref/obj-location.html" target="_blank" rel="noopener">location</a></td><td>用于窗口或框架的 Location 对象。请参阅 <a href="http://www.runoob.com/jsref/obj-location.html" target="_blank" rel="noopener">Location 对象</a>。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-name.html" target="_blank" rel="noopener">name</a></td><td>设置或返回窗口的名称。</td></tr><tr><td><a href="http://www.runoob.com/jsref/obj-navigator.html" target="_blank" rel="noopener">navigator</a></td><td>对 Navigator 对象的只读引用。请参数 <a href="http://www.runoob.com/jsref/obj-navigator.html" target="_blank" rel="noopener">Navigator 对象</a>。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-opener.html" target="_blank" rel="noopener">opener</a></td><td>返回对创建此窗口的窗口的引用。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-outerheight.html" target="_blank" rel="noopener">outerHeight</a></td><td>返回窗口的外部高度，包含工具条与滚动条。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-outerheight.html" target="_blank" rel="noopener">outerWidth</a></td><td>返回窗口的外部宽度，包含工具条与滚动条。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-pagexoffset.html" target="_blank" rel="noopener">pageXOffset</a></td><td>设置或返回当前页面相对于窗口显示区左上角的 X 位置。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-pagexoffset.html" target="_blank" rel="noopener">pageYOffset</a></td><td>设置或返回当前页面相对于窗口显示区左上角的 Y 位置。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-parent.html" target="_blank" rel="noopener">parent</a></td><td>返回父窗口。</td></tr><tr><td><a href="http://www.runoob.com/jsref/obj-screen.html" target="_blank" rel="noopener">screen</a></td><td>对 Screen 对象的只读引用。请参数 <a href="http://www.runoob.com/jsref/obj-screen.html" target="_blank" rel="noopener">Screen 对象</a>。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-screenleft.html" target="_blank" rel="noopener">screenLeft</a></td><td>返回相对于屏幕窗口的x坐标</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-screenleft.html" target="_blank" rel="noopener">screenTop</a></td><td>返回相对于屏幕窗口的y坐标</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-screenx.html" target="_blank" rel="noopener">screenX</a></td><td>返回相对于屏幕窗口的x坐标</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-sessionstorage.html" target="_blank" rel="noopener">sessionStorage</a></td><td>在浏览器中存储 key/value 对。 在关闭窗口或标签页之后将会删除这些数据。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-screenx.html" target="_blank" rel="noopener">screenY</a></td><td>返回相对于屏幕窗口的y坐标</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-self.html" target="_blank" rel="noopener">self</a></td><td>返回对当前窗口的引用。等价于 Window 属性。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-status.html" target="_blank" rel="noopener">status</a></td><td>设置窗口状态栏的文本。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-win-top.html" target="_blank" rel="noopener">top</a></td><td>返回最顶层的父窗口。</td></tr></tbody></table><h2 id="Window-对象方法"><a href="#Window-对象方法" class="headerlink" title="Window 对象方法"></a>Window 对象方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/jsref/met-win-alert.html" target="_blank" rel="noopener">alert()</a></td><td>显示带有一段消息和一个确认按钮的警告框。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-atob.html" target="_blank" rel="noopener">atob()</a></td><td>解码一个 base-64 编码的字符串。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-btoa.html" target="_blank" rel="noopener">btoa()</a></td><td>创建一个 base-64 编码的字符串。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-blur.html" target="_blank" rel="noopener">blur()</a></td><td>把键盘焦点从顶层窗口移开。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-clearinterval.html" target="_blank" rel="noopener">clearInterval()</a></td><td>取消由 setInterval() 设置的 timeout。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-cleartimeout.html" target="_blank" rel="noopener">clearTimeout()</a></td><td>取消由 setTimeout() 方法设置的 timeout。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-close.html" target="_blank" rel="noopener">close()</a></td><td>关闭浏览器窗口。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-confirm.html" target="_blank" rel="noopener">confirm()</a></td><td>显示带有一段消息以及确认按钮和取消按钮的对话框。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-createpopup.html" target="_blank" rel="noopener">createPopup()</a></td><td>创建一个 pop-up 窗口。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-focus.html" target="_blank" rel="noopener">focus()</a></td><td>把键盘焦点给予一个窗口。</td></tr><tr><td>getSelection()</td><td>返回一个 Selection 对象，表示用户选择的文本范围或光标的当前位置。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-getcomputedstyle.html" target="_blank" rel="noopener">getComputedStyle()</a></td><td>获取指定元素的 CSS 样式。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-matchmedia.html" target="_blank" rel="noopener">matchMedia()</a></td><td>该方法用来检查 media query 语句，它返回一个 MediaQueryList对象。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-moveby.html" target="_blank" rel="noopener">moveBy()</a></td><td>可相对窗口的当前坐标把它移动指定的像素。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-moveto.html" target="_blank" rel="noopener">moveTo()</a></td><td>把窗口的左上角移动到一个指定的坐标。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-open.html" target="_blank" rel="noopener">open()</a></td><td>打开一个新的浏览器窗口或查找一个已命名的窗口。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-print.html" target="_blank" rel="noopener">print()</a></td><td>打印当前窗口的内容。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-prompt.html" target="_blank" rel="noopener">prompt()</a></td><td>显示可提示用户输入的对话框。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-resizeby.html" target="_blank" rel="noopener">resizeBy()</a></td><td>按照指定的像素调整窗口的大小。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-resizeto.html" target="_blank" rel="noopener">resizeTo()</a></td><td>把窗口的大小调整到指定的宽度和高度。</td></tr><tr><td>scroll()</td><td>已废弃。 该方法已经使用了 <a href="http://www.runoob.com/jsref/met-win-scrollto.html" target="_blank" rel="noopener">scrollTo()</a> 方法来替代。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-scrollby.html" target="_blank" rel="noopener">scrollBy()</a></td><td>按照指定的像素值来滚动内容。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-scrollto.html" target="_blank" rel="noopener">scrollTo()</a></td><td>把内容滚动到指定的坐标。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-setinterval.html" target="_blank" rel="noopener">setInterval()</a></td><td>按照指定的周期（以毫秒计）来调用函数或计算表达式。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-settimeout.html" target="_blank" rel="noopener">setTimeout()</a></td><td>在指定的毫秒数后调用函数或计算表达式。</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-win-stop.html" target="_blank" rel="noopener">stop()</a></td><td>停止页面载入。</td></tr></tbody></table><h2 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h2><p>History 对象包含用户（在浏览器窗口中）访问过的 URL。</p><p>History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。</p><p><img src="http://www.runoob.com/images/lamp.gif" alt="Note"><strong>注意：</strong> 没有应用于History对象的公开标准，不过所有浏览器都支持该对象。</p><h2 id="History-对象属性"><a href="#History-对象属性" class="headerlink" title="History 对象属性"></a>History 对象属性</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/jsref/prop-his-length.html" target="_blank" rel="noopener">length</a></td><td>返回历史列表中的网址数</td></tr></tbody></table><h2 id="History-对象方法"><a href="#History-对象方法" class="headerlink" title="History 对象方法"></a>History 对象方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/jsref/met-his-back.html" target="_blank" rel="noopener">back()</a></td><td>加载 history 列表中的前一个 URL</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-his-forward.html" target="_blank" rel="noopener">forward()</a></td><td>加载 history 列表中的下一个 URL</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-his-go.html" target="_blank" rel="noopener">go()</a></td><td>加载 history 列表中的某个具体页面</td></tr></tbody></table><h2 id="Location-对象"><a href="#Location-对象" class="headerlink" title="Location 对象"></a>Location 对象</h2><p>Location 对象包含有关当前 URL 的信息。</p><p>Location 对象是 window 对象的一部分，可通过 window.Location 属性对其进行访问。</p><p><img src="http://www.runoob.com/images/lamp.gif" alt="Note"><strong>注意：</strong> 没有应用于Location对象的公开标准，不过所有浏览器都支持该对象。</p><hr><h2 id="Location-对象属性"><a href="#Location-对象属性" class="headerlink" title="Location 对象属性"></a>Location 对象属性</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/jsref/prop-loc-hash.html" target="_blank" rel="noopener">hash</a></td><td>返回一个URL的锚部分</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-loc-host.html" target="_blank" rel="noopener">host</a></td><td>返回一个URL的主机名和端口</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-loc-hostname.html" target="_blank" rel="noopener">hostname</a></td><td>返回URL的主机名</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-loc-href.html" target="_blank" rel="noopener">href</a></td><td>返回完整的URL</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-loc-pathname.html" target="_blank" rel="noopener">pathname</a></td><td>返回的URL路径名。</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-loc-port.html" target="_blank" rel="noopener">port</a></td><td>返回一个URL服务器使用的端口号</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-loc-protocol.html" target="_blank" rel="noopener">protocol</a></td><td>返回一个URL协议</td></tr><tr><td><a href="http://www.runoob.com/jsref/prop-loc-search.html" target="_blank" rel="noopener">search</a></td><td>返回一个URL的查询部分</td></tr></tbody></table><h2 id="Location-对象方法"><a href="#Location-对象方法" class="headerlink" title="Location 对象方法"></a>Location 对象方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/jsref/met-loc-assign.html" target="_blank" rel="noopener">assign()</a></td><td>载入一个新的文档</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-loc-reload.html" target="_blank" rel="noopener">reload()</a></td><td>重新载入当前文档</td></tr><tr><td><a href="http://www.runoob.com/jsref/met-loc-replace.html" target="_blank" rel="noopener">replace()</a></td><td>用新的文档替换当前文档</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;## &lt;/p&gt;
&lt;h2 id=&quot;Window对象&quot;&gt;&lt;a href=&quot;#Window对象&quot; class=&quot;headerlink&quot; title=&quot;Window对象&quot;&gt;&lt;/a&gt;Window对象&lt;/h2&gt;&lt;p&gt;Window 对象表示浏览器中打开的窗口。&lt;/p&gt;
&lt;p&gt;如果文档包含
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>DOM</title>
    <link href="http://www.luozy.top/2018/10/26/DOM/"/>
    <id>http://www.luozy.top/2018/10/26/DOM/</id>
    <published>2018-10-26T06:28:51.000Z</published>
    <updated>2018-10-30T08:16:38.077Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="文档对象模型DOM（document-Object-Model）"><a href="#文档对象模型DOM（document-Object-Model）" class="headerlink" title="文档对象模型DOM（document Object Model）"></a>文档对象模型DOM（document Object Model）</h1><blockquote><p>DOM 中的三个字母，D（文档）可以理解为整个 Web 加载的网页文档；O（对象）可 以理解为类似 window 对象之类的东西，可以调用属性和方法，这里我们说的是 document 对象；M（模型）可以理解为网页文档的树型结构。</p></blockquote><p>所谓DOM就是以家族的形式描述HTML       节点有 父子 兄弟 </p><p>注：在JavaScript里真的这么叫！！！只不过加上了节点两个字称作父子节点，兄弟节点。<img src="C:\Users\罗中运\AppData\Local\Temp\chrome_drag17544_7625\Image.png" alt="Image"></p><h4 id="加载-HTML-页面时，Web-浏览器生成一个树型结构，用来表示页面内部结构。DOM-将-这种树型结构称为节点组成的节点树。"><a href="#加载-HTML-页面时，Web-浏览器生成一个树型结构，用来表示页面内部结构。DOM-将-这种树型结构称为节点组成的节点树。" class="headerlink" title="加载 HTML 页面时，Web 浏览器生成一个树型结构，用来表示页面内部结构。DOM 将 这种树型结构称为节点组成的节点树。"></a>加载 HTML 页面时，Web 浏览器生成一个树型结构，用来表示页面内部结构。DOM 将 这种树型结构称为节点组成的节点树。</h4><h2 id="DOM中所有节点的种类"><a href="#DOM中所有节点的种类" class="headerlink" title="DOM中所有节点的种类"></a>DOM中所有节点的种类</h2><p>元素节点  <div></div></p><p>属性节点 id =‘div1’</p><p>文本节点 div文本</p><p><img src="C:\Users\罗中运\AppData\Local\Temp\chrome_drag17544_26641\Image.png" alt="Image">  W3C 提供了比较方便简单的定位节点的方法和属性，以便我们快速的对节点进行操作。 分别为：getElementById()、getElementsByTagName()、getElementsByName()、getElementsClassName()、getAttribute()、 setAttribute()和 removeAttribute()。<img src="C:\Users\罗中运\AppData\Local\Temp\chrome_drag17544_20962\Image.png" alt="Image"></p><h3 id="获取元素节点"><a href="#获取元素节点" class="headerlink" title="获取元素节点"></a>获取元素节点</h3><blockquote><p>W3C 提供了比较方便简单的定位节点的方法和属性，以便我们快速的对节点进行操作。 分别为：getElementById()、getElementsByTagName()、getElementsByName()、getElementsClassName()、getAttribute()、 setAttribute()和 removeAttribute()。</p></blockquote><p>ps:代码由上而下执行，script在头部的时候，先执行script的内容，在执行body里面的。</p><p>所以要用到 window.onload</p><h4 id="window-onload-function"><a href="#window-onload-function" class="headerlink" title="window.onload = function(){"></a>window.onload = function(){</h4><h4 id=""><a href="#" class="headerlink" title="}"></a>}</h4><p><strong>方法在页面加载完毕后才会执行。</strong></p><p>这样就可以先加载完body，再执行script里面的内容。</p><h4 id="1、document-getElementById（）通过id获取元素节点"><a href="#1、document-getElementById（）通过id获取元素节点" class="headerlink" title="1、document.getElementById（）通过id获取元素节点"></a>1、document.getElementById（）通过id获取元素节点</h4><h4 id="2、node-getElementsByTagName-获取相同元素的节点列表"><a href="#2、node-getElementsByTagName-获取相同元素的节点列表" class="headerlink" title="2、node.getElementsByTagName()    获取相同元素的节点列表"></a>2、node.getElementsByTagName()    获取相同元素的节点列表</h4><p>​    参数：小写的标签名</p><p>​    返回值：获取所有符合条件的元素节点，使用起来和数组差不多</p><p>​    </p><p>​    可以指定在哪个节点开始找元素</p><p>​    var op = ducument.getElementById(“h1”);</p><p>​    var nodes = op.getElementsByTagName(“div”);</p><p>​    //作用： 获取到h1下的所有div</p><h4 id="3、document-getElementsByName-获取相同元素名称（name）的节点列表"><a href="#3、document-getElementsByName-获取相同元素名称（name）的节点列表" class="headerlink" title="3、document.getElementsByName()获取相同元素名称（name）的节点列表"></a>3、document.getElementsByName()获取相同元素名称（name）的节点列表</h4><h4 id="4、node-getElementsByClassName-获取相同ClassName的节点-IE8以上才兼容"><a href="#4、node-getElementsByClassName-获取相同ClassName的节点-IE8以上才兼容" class="headerlink" title="4、node.getElementsByClassName() 获取相同ClassName的节点(IE8以上才兼容)"></a>4、node.getElementsByClassName() 获取相同ClassName的节点(IE8以上才兼容)</h4><p>​    也可以指定在哪个节点开始找元素</p><p>​    封装getElementsByClassName():</p><p>​    function elementByClassName(node, className){</p><p>​        var nodes =    node.getElementsByTagName(“*”);</p><p>​        var arr = [];        </p><p>​        for(var i = 0; i &lt; nodes.length; i++){</p><p>​            if(nodes[i].className == className){</p><p>​                arr.push(nodes[i]);</p><p>​            }</p><p>​        }</p><p>​        return arr;</p><p>​    }</p><h4 id="5、getAttribute-获取特定元素节点属性的值"><a href="#5、getAttribute-获取特定元素节点属性的值" class="headerlink" title="5、getAttribute()获取特定元素节点属性的值"></a>5、getAttribute()获取特定元素节点属性的值</h4><h4 id="6、setAttribute-设置特点元素特点属性的值"><a href="#6、setAttribute-设置特点元素特点属性的值" class="headerlink" title="6、setAttribute()设置特点元素特点属性的值"></a>6、setAttribute()设置特点元素特点属性的值</h4><h4 id="7、removeAttribute-移除特定元素节点属性"><a href="#7、removeAttribute-移除特定元素节点属性" class="headerlink" title="7、removeAttribute()移除特定元素节点属性"></a>7、removeAttribute()移除特定元素节点属性</h4><h4 id="document-querySelector-IE8以下不兼容"><a href="#document-querySelector-IE8以下不兼容" class="headerlink" title="document.querySelector() //IE8以下不兼容"></a>document.querySelector() //IE8以下不兼容</h4><p>返回值：只返回符合条件的第一个节点。</p><h4 id="document-querySelectorAll"><a href="#document-querySelectorAll" class="headerlink" title="document.querySelectorAll()"></a>document.querySelectorAll()</h4><p>必须是document开头，返回一个数组</p><p>参数:都是css选择器的格式去写的字符串。</p><p>如：</p><p>​    var node = document.querySelector(“.box”);//获取class等于box的第一个节点</p><p>​    var node = document.querySelector(“ol .box”);//ol下class==box的第一个节点</p><p>​    var nodes = document.querySelector(“className”)；//返回的是数组，即使是获取id</p><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><p>只要是元素节点，都有以下两个属性</p><p>​    tagName    输出当前元素节点的标签类型</p><p>​    innerHTML（双标签）    获取标签建内容（元素节点也是text格式显示）</p><p>​    设置的时候标签会以样式输出</p><h4 id="通过属性名访问属性的值"><a href="#通过属性名访问属性的值" class="headerlink" title="通过属性名访问属性的值"></a>通过属性名访问属性的值</h4><p>​    .id，.title，.className，.width ，.style.width,.style.backgroundColor  …</p><p>​    ps: 样式里面的-换成首字母大写，即烤串式写法换为驼峰式写法</p><p>​    获取样式只能获取行间样式</p><h5 id="获取style标签内样式-：-跨浏览器获取当前有效样式的方法"><a href="#获取style标签内样式-：-跨浏览器获取当前有效样式的方法" class="headerlink" title="获取style标签内样式 ：//    跨浏览器获取当前有效样式的方法"></a>获取style标签内样式 ：//    跨浏览器获取当前有效样式的方法</h5><p>Div.currentStyle[‘height’];//IE</p><p>getCompitedStyle(oDiv)[‘height’];//谷歌火狐等</p><p>自定义兼容写法</p><p>​    function getStyle(node , styleStr){</p><p>​            return node.currentStyle ? node.currentStyle[styleStr] : getComputedStyle(node)[styleStr];</p><p>​     }</p><h4 id="通过getAttribute属性获取"><a href="#通过getAttribute属性获取" class="headerlink" title="通过getAttribute属性获取"></a>通过getAttribute属性获取</h4><p>ele.getAttribute();</p><p>ele.setAttribute();</p><p>removeAttribute();</p><h3 id="属性设置和方法设置区别"><a href="#属性设置和方法设置区别" class="headerlink" title="属性设置和方法设置区别"></a>属性设置和方法设置区别</h3><p>​            //1、区别<br>​            // alert(oDiv.className);<br>​            // alert(oDiv.getAttribute(“class”));</p><p>​            // oDiv.className = ‘xxx’;<br>​            // oDiv.setAttribute(“class”, “xxx”);</p><p>​            //2、自定义属性<br>​            // alert(oDiv.xxx);<br>​            // alert(oDiv.getAttribute(“xxx”));</p><p>​            //设置自定义属性<br>​            /<em>oDiv.zzz = ‘mmm’;<br>​            alert(oDiv.zzz);</em>/</p><p>​            //如果你想添加一个属性，并且将这个属性显示在行间<br>​            // oDiv.setAttribute(‘zzz’, ‘mmm’);</p><p>​            /<em><br>​                removeAttribute();<br>​            </em>/</p><p>​            // oDiv.className = “”;<br>​            oDiv.removeAttribute(“class”);</p><h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3><p>childNodes</p><p>DOM节点</p><p><strong>1、元素节点</strong></p><p><strong>2、属性节点</strong></p><p><strong>3、文本节点</strong></p><p>上述文本通用属性</p><p>​        nodeName    nodeType    nodevalue</p><p>元素    标签名        1            </p><p>属性    属性名        2            属性值</p><p>文本    #text        3            文本内容</p><p>【注】文本节点只能通过标签（元素节点）的子节点获取；</p><p>【注】 空格回车也会当做文本节点；！！！会导致节点变多</p><p>firstChild    子节点中的第一个节点</p><p>lastChild        子节点中的最后一个节点</p><p><strong>children获取元素节点</strong></p><p>firstElementChild</p><p>lastElementChild</p><p>nextElementSibling()获取兄弟节点的下一个节点</p><p>.innerHTML与.outerHTML</p><p>区别：一个是内部内容不包含自身标签，outer包含本标签</p><h4 id="attribute属性节点"><a href="#attribute属性节点" class="headerlink" title="attribute属性节点"></a>attribute属性节点</h4><p>attributes是一个集合</p><p>集合：特点  1、无序，2、不重复</p><p>不可以通过序列下标获取，可以通过具体索引获取</p><p>box.attributes                //NamedNodeMap</p><p>box.attributes.length;        //返回属性节点个数</p><p>box.attributes[0];            //Attr，返回最后一个属性节点</p><p>box.attributes[0].nodeType;   //2，节点类型</p><p>box.attributes[0].nodeValue;  //属性值</p><p>box.attributes[‘id’];         //Attr，返回属性为 id 的节点</p><p>box.attributes.getNamedItem(‘id’); //Attr</p><h3 id="去空白节点"><a href="#去空白节点" class="headerlink" title="去空白节点"></a>去空白节点</h3><p>//返回一个新数组</p><p>function removeSpaceNodes(nodes){</p><p>​    var arr = [];</p><p>​    for(var i = 0; i &lt; nodes.length; i++){</p><p>​        if(node[i].nodeType == 3 &amp;&amp; /^\s+$/).test(nodes[i])){</p><p>​            continue;</p><p>​            arr.push(nodes[i]);</p><p>​        }</p><p>​    }</p><p>​    return arr;</p><p>}</p><p>PS：上面的方法，采用的忽略空白文件节点的方法，把得到元素节点累加到数组里返 回。那么还有一种做法是，直接删除空位文件节点即可</p><p>//修改原数组</p><p>function filterSpaceNode(nodes){</p><p>​    for(vari=0;i&lt;nodes.length;i++) {</p><p>​          if(nodes[i].nodeType== 3&amp;&amp;/^\s+$/.test(nodes[i].nodeValue)){</p><p>​          //得到空白节点之后，移到父节点上，删除子节点           </p><p>​            nodes[i].parentNode.removeChild(nodes[i]);</p><p>​         }</p><p>​    }</p><p>​    return nodes;</p><p>}</p><h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作**"></a>节点操作**</h2><p><strong>document.write();</strong></p><p>会覆盖页面上原有的内容；所以一般不会用在节点操作上</p><p><strong>document.createElement(标签名);</strong></p><p>功能：生成一个标签</p><p>返回值：新创建的这个元素节点</p><p><strong>node1.appendChild(node2);</strong></p><p>功能：将node2插入到node1的子节点末尾。</p><p><strong>document.createTextNode()</strong>；</p><p>功能：创建文本节点</p><p>node.appendChild(tNode);</p><p>相同功能：node.innerHTML</p><p><strong>.insertBefore</strong>()</p><p>格式： node1.parentNode.insertBefore(node2,nide1)</p><p>功能：将node2插入到node1之前</p><p><strong>replaceChild()</strong></p><p>格式：node1.parentNode.replace(node2, node1)</p><p>功能：用node2将node1替换掉</p><p><strong>cloneNode()</strong></p><p>格式：node.cloneNode();</p><p>参数：true：即克隆标签也克隆文本 ，默认false</p><p><strong>removeChild()</strong></p><p>格式：node.parentNode.removeChild();</p><h2 id="事件驱动方法-两种写法"><a href="#事件驱动方法-两种写法" class="headerlink" title="事件驱动方法 两种写法"></a>事件驱动方法 两种写法</h2><p>行间</p><p>onclick = “func();”</p><p>写在script里面</p><p>先通过id获取元素</p><p>ele.onclick = function(){</p><p>}</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>每一个函数，系统都会提供一个内置的变量，这个变量就是this.this存储的都是当前函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;文档对象模型DOM（document-Object-Model）&quot;&gt;&lt;a href=&quot;#文档对象模型DOM（document-Object-Model）&quot; class=&quot;headerlink&quot; title=&quot;文档对象模型DOM（docum
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>BOM</title>
    <link href="http://www.luozy.top/2018/10/26/BOM/"/>
    <id>http://www.luozy.top/2018/10/26/BOM/</id>
    <published>2018-10-26T01:26:49.000Z</published>
    <updated>2018-10-26T09:17:56.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BOM-Browser-object-model-浏览器对象模型"><a href="#BOM-Browser-object-model-浏览器对象模型" class="headerlink" title="BOM(Browser object model)浏览器对象模型"></a>BOM(Browser object model)浏览器对象模型</h1><blockquote><p> 一个浏览器窗口就是一个bom（浏览器对象）</p></blockquote><p><img src="C:\Users\罗中运\AppData\Roaming\Typora\typora-user-images\1540517515858.png" alt="1540517515858"></p><h5 id="window下的方法，通常情况下window开头的方法函数都可以省略window使用"><a href="#window下的方法，通常情况下window开头的方法函数都可以省略window使用" class="headerlink" title="window下的方法，通常情况下window开头的方法函数都可以省略window使用"></a>window下的方法，通常情况下window开头的方法函数都可以省略window使用</h5><h4 id="confirm（）方法"><a href="#confirm（）方法" class="headerlink" title="confirm（）方法"></a>confirm（）方法</h4><blockquote><p>confirm() 方法用于显示一个带有指定消息和 OK 及取消按钮的对话框。</p></blockquote><p>返回值：点击确定，返回true</p><p>​        点击取消，返回false </p><h4 id="prompt"><a href="#prompt" class="headerlink" title="prompt()"></a>prompt()</h4><blockquote><p>prompt()方法用于显示可提示用户进行输入的对话框。</p><p>这个方法返回用户输入的字符串。</p></blockquote><p>参数： 第一个参数 提示面板上显示的内容</p><p>​          第二个参数 输入框上显示的内容（可以不填）</p><p>返回值：输入框的内容    </p><h4 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h4><blockquote><p>open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口。</p></blockquote><p>第一个参数： 加载的url</p><p>第二个参数：指定target属性窗口的名称，（）</p><p>第三个参数：一串特殊意义的字符串，配置我们打开窗口的大小坐标</p><h5 id="url完整组成"><a href="#url完整组成" class="headerlink" title="url完整组成"></a>url完整组成</h5><h5 id="协议：-主机名：端口号-路径-？查询字符串-锚点"><a href="#协议：-主机名：端口号-路径-？查询字符串-锚点" class="headerlink" title="协议：//主机名：端口号/路径/？查询字符串#锚点"></a>协议：//主机名：端口号/路径/？查询字符串#锚点</h5><h5 id="protocol-hostname-port-pathname-search-hash"><a href="#protocol-hostname-port-pathname-search-hash" class="headerlink" title="protocol://hostname:port/pathname/?search#hash"></a>protocol://hostname:port/pathname/?search#hash</h5><h4 id="opener打开当前窗口的父窗口的对象（只有火狐浏览器兼容）"><a href="#opener打开当前窗口的父窗口的对象（只有火狐浏览器兼容）" class="headerlink" title="opener打开当前窗口的父窗口的对象（只有火狐浏览器兼容）"></a>opener打开当前窗口的父窗口的对象（只有火狐浏览器兼容）</h4><p>opener.document.write(“father”);//父窗口输出</p><h4 id="setTimeout-延时器"><a href="#setTimeout-延时器" class="headerlink" title="setTimeout()延时器"></a>setTimeout()延时器</h4><p>格式：</p><p>var timer = setTimerout(函数，毫秒数);</p><p>功能： 延迟对应毫秒数，去执行函数，有且仅执行一次；</p><p>取消延时器</p><p>clearTImeout(timer);</p><h4 id="history-历史对象"><a href="#history-历史对象" class="headerlink" title="history 历史对象"></a>history 历史对象</h4><p>window.history</p><p>属性</p><p>history.length    历史纪录长度</p><p>方法：</p><p>​    history.back();//后退</p><p>​    history.forward();//前进</p><p>​    history.go();//到指定历史界面</p><p>​        参数：正整数，负整数，0 前进/后退n条记录；0重新加载</p><h4 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h4><blockquote><p>地址栏部分</p><p>url：统一资源定位符</p><p>组成一个完整的url，必须按格式进行填写。</p></blockquote><h5 id="第一部分：location-protocol-协议"><a href="#第一部分：location-protocol-协议" class="headerlink" title="第一部分：location.protocol 协议"></a>第一部分：location.protocol 协议</h5><p>http://</p><p>https://</p><p>传输方式</p><h5 id="第二部分：主机名-location-hostname"><a href="#第二部分：主机名-location-hostname" class="headerlink" title="第二部分：主机名 location.hostname"></a>第二部分：主机名 location.hostname</h5><p><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 域名IP的昵称</p><p>61.135.169.125 IP 全网唯一</p><h5 id="location-port-端口号"><a href="#location-port-端口号" class="headerlink" title="location.port 端口号"></a>location.port 端口号</h5><p>系统会给当前使用网络的app，分配一个号码，这个号码就是端口号</p><p>当前电脑内唯一识别正在使用网络的软件；</p><p>ip：port 在全球范围内定位当前使用网络的软件</p><h5 id="pathname路径"><a href="#pathname路径" class="headerlink" title="pathname路径"></a>pathname路径</h5><p>location.pathname</p><h5 id="search向服务器提交数据部分（查询字符串）"><a href="#search向服务器提交数据部分（查询字符串）" class="headerlink" title="search向服务器提交数据部分（查询字符串）"></a>search向服务器提交数据部分（查询字符串）</h5><p>location.search </p><p>查询字符串</p><p>？name1 =value&amp; name2 = value</p><h5 id="hash锚点"><a href="#hash锚点" class="headerlink" title="hash锚点"></a>hash锚点</h5><p>location.hash</p><h3 id="location方法"><a href="#location方法" class="headerlink" title="location方法"></a>location方法</h3><p>location.assign（） 跳转到某一个url</p><p>location.replace（） 在当前窗口替换url</p><p>assign和replace区别assign有历史记录，replace没有</p><p>location.reload（） 刷新网页 参数location.reload（true）：不经过缓存直接刷新页面</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BOM-Browser-object-model-浏览器对象模型&quot;&gt;&lt;a href=&quot;#BOM-Browser-object-model-浏览器对象模型&quot; class=&quot;headerlink&quot; title=&quot;BOM(Browser object model)浏览器
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面向对象和面向过程</title>
    <link href="http://www.luozy.top/2018/10/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.luozy.top/2018/10/25/面向对象和面向过程/</id>
    <published>2018-10-25T01:39:02.000Z</published>
    <updated>2018-10-25T01:42:22.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象与面向过程的本质的区别"><a href="#面向对象与面向过程的本质的区别" class="headerlink" title="面向对象与面向过程的本质的区别"></a>面向对象与面向过程的本质的区别</h1><h3 id="一、面向对象与面向过程的区别"><a href="#一、面向对象与面向过程的区别" class="headerlink" title="一、面向对象与面向过程的区别"></a>一、面向对象与面向过程的区别</h3><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p><p>可以拿生活中的实例来理解面向过程与面向对象，例如五子棋，面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。</p><p>如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。</p><p>可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。</p><p>上述的内容是从网上查到的，觉得这个例子非常的生动形象，我就写了下来，现在就应该理解了他俩的区别了吧，其实就是两句话，面向对象就是高度实物抽象化、面向过程就是自顶向下的编程！</p><h3 id="二、面向对象的特点"><a href="#二、面向对象的特点" class="headerlink" title="二、面向对象的特点"></a>二、面向对象的特点</h3><p>​    在了解其特点之前，咱们先谈谈对象，对象就是现实世界存在的任何事务都可以称之为对象，有着自己独特的个性</p><p>​    属性用来描述具体某个对象的特征。比如小志身高180M，体重70KG，这里身高、体重都是属性。<br>面向对象的思想就是把一切都看成对象，而对象一般都由属性+方法组成！</p><p>​    属性属于对象静态的一面，用来形容对象的一些特性，方法属于对象动态的一面，咱们举一个例子，小明会跑，会说话，跑、说话这些行为就是对象的方法！所以为动态的一面， 我们把属性和方法称为这个对象的成员！</p><p>​    <strong>类</strong>：具有同种属性的对象称为类，是个抽象的概念。比如“人”就是一类，期中有一些人名，比如小明、小红、小玲等等这些都是对象，类就相当于一个模具，他定义了它所包含的全体对象的公共特征和功能，对象就是类的一个实例化，小明就是人的一个实例化！我们在做程序的时候，经常要将一个变量实例化，就是这个原理！我们一般在做程序的时候一般都不用类名的，比如我们在叫小明的时候，不会喊“人，你干嘛呢！”而是说的是“小明，你在干嘛呢！”</p><p>​    面向对象有三大特性，分别是封装性、继承性和多态性，这里小编不给予太多的解释，因为在后边的博客会专门总结的！</p><h3 id="三、面向过程与面向对象的优缺点"><a href="#三、面向过程与面向对象的优缺点" class="headerlink" title="三、面向过程与面向对象的优缺点"></a>三、面向过程与面向对象的优缺点</h3><p>​    很多资料上全都是一群很难理解的理论知识，整的小编头都大了，后来发现了一个比较好的文章，写的真是太棒了，通俗易懂，想要不明白都难!</p><p>​    用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭。所谓盖浇饭，北京叫盖饭，东北叫烩饭，广东叫碟头饭，就是在一碗白米饭上面浇上一份盖菜，你喜欢什么菜，你就浇上什么菜。我觉得这个比喻还是比较贴切的。</p><p>​    蛋炒饭制作的细节，我不太清楚，因为我没当过厨师，也不会做饭，但最后的一道工序肯定是把米饭和鸡蛋混在一起炒匀。盖浇饭呢，则是把米饭和盖菜分别做好，你如果要一份红烧肉盖饭呢，就给你浇一份红烧肉；如果要一份青椒土豆盖浇饭，就给浇一份青椒土豆丝。</p><p>​    蛋炒饭的好处就是入味均匀，吃起来香。如果恰巧你不爱吃鸡蛋，只爱吃青菜的话，那么唯一的办法就是全部倒掉，重新做一份青菜炒饭了。盖浇饭就没这么多麻烦，你只需要把上面的盖菜拨掉，更换一份盖菜就可以了。盖浇饭的缺点是入味不均，可能没有蛋炒饭那么香。</p><p>​    到底是蛋炒饭好还是盖浇饭好呢？其实这类问题都很难回答，非要比个上下高低的话，就必须设定一个场景，否则只能说是各有所长。如果大家都不是美食家，没那么多讲究，那么从饭馆角度来讲的话，做盖浇饭显然比蛋炒饭更有优势，他可以组合出来任意多的组合，而且不会浪费。</p><p>​    盖浇饭的好处就是”菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是”可维护性“比较好，”饭” 和”菜”的耦合度比较低。蛋炒饭将”蛋”“饭”搅和在一起，想换”蛋”“饭”中任何一种都很困难，耦合度很高，以至于”可维护性”比较差。软件工程追求的目标之一就是可维护性，可维护性主要表现在3个方面：可理解性、可测试性和可修改性。面向对象的好处之一就是显著的改善了软件系统的可维护性。 　　 </p><h4 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h4><blockquote><p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。<br>缺点：没有面向对象易维护、易复用、易扩展</p></blockquote><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><blockquote><p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 </p><p>缺点：性能比面向过程低</p></blockquote><hr><p>作者：十四期_李光<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/jerry11112/article/details/79027834" target="_blank" rel="noopener">https://blog.csdn.net/jerry11112/article/details/79027834</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向对象与面向过程的本质的区别&quot;&gt;&lt;a href=&quot;#面向对象与面向过程的本质的区别&quot; class=&quot;headerlink&quot; title=&quot;面向对象与面向过程的本质的区别&quot;&gt;&lt;/a&gt;面向对象与面向过程的本质的区别&lt;/h1&gt;&lt;h3 id=&quot;一、面向对象与面向过程的区
      
    
    </summary>
    
    
      <category term="对象" scheme="http://www.luozy.top/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Math对象和日期对象</title>
    <link href="http://www.luozy.top/2018/10/25/Math%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.luozy.top/2018/10/25/Math对象和日期对象/</id>
    <published>2018-10-25T01:07:48.000Z</published>
    <updated>2018-10-26T09:31:01.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、Math对象"><a href="#1、Math对象" class="headerlink" title="1、Math对象"></a>1、Math对象</h2><h4 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h4><p>[0,1)返回随机数</p><h4 id="Math-max-num1-num2-Math-min-num1-num2"><a href="#Math-max-num1-num2-Math-min-num1-num2" class="headerlink" title="Math.max(num1,num2),Math.min(num1,num2);"></a>Math.max(num1,num2),Math.min(num1,num2);</h4><p>取较大，较小值</p><h4 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round()"></a>Math.round()</h4><p>四舍五入，变成整数</p><h4 id="Math-floor-Math-ceil"><a href="#Math-floor-Math-ceil" class="headerlink" title="Math.floor(), Math.ceil()"></a>Math.floor(), Math.ceil()</h4><p>向下，上取整</p><h4 id="Math-sqrt"><a href="#Math-sqrt" class="headerlink" title="Math.sqrt()"></a>Math.sqrt()</h4><p>开平方</p><h4 id="Math-abs"><a href="#Math-abs" class="headerlink" title="Math.abs()"></a>Math.abs()</h4><p>取绝对值</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p><img src="C:\Users\罗中运\Pictures\Saved Pictures\对象.png" alt="对象"></p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>1、抽象：抽指把核心的东西抽出来，把与我们要解决的问题有关的东西拿出来摆在面前 </p><p>2、封装：让使用对象的人不考虑内部实现，只考虑功能使用  把内部的代码保护起来，只留出一些个api接口供用户使用</p><p>3、继承：就是为了代码的复用，从父类上继承出一些方法和属性，子类也有自己的一些属性 </p><p>4、多态：实际上是不同对象作用与同一操作产生不同的效果。多态的思想实际上是把“想做什么”和“谁去做“分开</p><h5 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h5><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p><p>可以拿生活中的实例来理解面向过程与面向对象，例如五子棋，面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。</p><h6 id="如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。"><a href="#如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。" class="headerlink" title="如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。"></a>如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。</h6><h6 id="可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。"><a href="#可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。" class="headerlink" title="可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。"></a>可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。</h6><p>###### </p><h4 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a>对象的组成</h4><p>1、方法   函数：过程、动态的</p><p>2、属性   变量：状态、静态的，</p><h4 id="this当前的方法属于谁就是谁"><a href="#this当前的方法属于谁就是谁" class="headerlink" title="this当前的方法属于谁就是谁"></a>this<strong>当前的方法属于谁就是谁</strong></h4><p>例如点击事件里的this，其实就是触发事件的那个dom对象的onclick方法里的this，当然是人家自己咯</p><p> 再比如说一个函数里的this，这个函数都属于window的一个方法，当然里面的this也是window咯</p><p>  还有哦，不要在系统对象上面添加属性和方法，这样不太好</p><p> 那么在谁身上加呢？在object这个对象身上，别的date呀array呀，这些对象都是有一些个好玩的功能的，</p><p>  object也就自己最强大的一个功能就是，没有功能~~~~ 这样咱们就可以随意给他加属性和方法而不用去想会不会覆盖了</p><p>1、通过历史</p><p>​    面向过程语言：汇编、c语言</p><p>​    面向对象语言：c++，java</p><p>2、编程思想</p><p>​    面向过程：只关心数字逻辑</p><p>​    面向过程：具体某一个是提来的，唯一的实体。</p><p>3、语法：<br>​    在JS中需要通过两个语法实现面向对象程序。<br>​    类   在JS没有类这个概念。<br>​    对象 </p><p>​    类：将具有同一类特征的事物总结，抽象的概念。<br>​    对象：唯一的某一个个体。</p><p>​    类           对象<br>​    人          你、我、他<br>​    复仇者联盟  钢铁侠    </p><p>4、代码<br>​    数据类型：<br>​            基本数据类型：<br>​            特殊数据类型：null undefined NaN<br>​            复合数据类型：数组、字符串、对象</p><p>5、数据结构：<br>​    基本数据类型(只能存储单个的值)  -&gt;  数组(可以处理批量的数据)  -&gt;  对象(既能存储数据，又能存储函数)</p><h4 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h4><p>1、最基础的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、通过new声明对象</span></span><br><span class="line"><span class="comment">// var obj = new Object();</span></span><br><span class="line"><span class="comment">//2、省略new声明对象</span></span><br><span class="line"><span class="comment">// var obj = Object();</span></span><br><span class="line"><span class="comment">//3、直接通过对象常量赋值</span></span><br><span class="line"><span class="comment">/*var obj = &#123;&#125;;</span></span><br><span class="line"><span class="comment">添加对象的属性  和普通的变量是一样的</span></span><br><span class="line"><span class="comment">obj.name = '小明';</span></span><br><span class="line"><span class="comment">obj.age = 18;</span></span><br><span class="line"><span class="comment">//添加对象的方法/函数</span></span><br><span class="line"><span class="comment">obj.run = function()&#123;</span></span><br><span class="line"><span class="comment">alert("会跑")</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">alert(obj.name);</span></span><br><span class="line"><span class="comment">obj.run();*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*var obj = &#123;</span></span><br><span class="line"><span class="comment">name: "小明",</span></span><br><span class="line"><span class="comment">age: 18,</span></span><br><span class="line"><span class="comment">run: function()&#123;</span></span><br><span class="line"><span class="comment">alert("会跑");</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">alert(obj.name);</span></span><br><span class="line"><span class="comment">obj.run();*/</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加对象的属性  和普通的变量是一样的</span></span><br><span class="line">obj.name = <span class="string">'小明'</span>;</span><br><span class="line">obj[<span class="string">'age'</span>] = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加对象的方法/函数</span></span><br><span class="line">obj.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"会跑"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(obj[<span class="string">'name'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除对象的属性和方法的关键字 delete</span></span><br><span class="line"><span class="comment">// delete删除对象属性，delete删除不了变量及原型链中的变量</span></span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line">alert(obj.name);</span><br><span class="line"></span><br><span class="line">obj.run();</span><br></pre></td></tr></table></figure><p>但是这样太麻烦，我要写100个人，那得写100次。有别的方法吗？有</p><p>2、工厂方式 通过构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//原料</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">//加工</span></span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age=age;</span><br><span class="line">    obj.showAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         alert(<span class="keyword">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出厂</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1=createPerson(<span class="string">"shizhikai"</span>,<span class="string">'3岁'</span>)</span><br><span class="line"><span class="keyword">var</span> obj2=createPerson(<span class="string">"ni"</span>,<span class="string">'18岁'</span>);</span><br><span class="line"></span><br><span class="line">alert(obj1.showName)<span class="comment">//function()&#123;alert(this.name)&#125;</span></span><br><span class="line">alert(obj2.showName)<span class="comment">//function()&#123;alert(this.name)&#125;</span></span><br></pre></td></tr></table></figure><h2 id="日起对象Date"><a href="#日起对象Date" class="headerlink" title="日起对象Date"></a>日起对象Date</h2><p>Date对象代表日期</p><p> Date</p><p>类型使用自 UTC（Coordinated Universal Time，国际协调时间）1970 年 1 月 1 日午夜（零时）开始经过的毫秒数来保存日期。Date 类型保存的日期能够精确到 1970 年 1 月 1 日之前或之后的 285616 年。</p><p>创建一个日期对象，使用 new 运算符和 Date 构造方法(构造函数)即可。</p><p>​    <strong>var d = new Date();</strong></p><p>在调用 Date 构造方法而不传递参数的情况下，新建的对象自动获取当前的时间和日期。</p><p>创建日期对象并指定时间</p><p>​    <strong>var d = new Date(“2015/08/22”);</strong></p><p>​    <strong>var d = new Date(2016,04,13,14,34);</strong></p><p>【注】time可以是“2015/08/22”， “2015-08-22”  ，或1970年当前日期的毫秒数56521211021</p><h4 id="5、日期对象Date（格式化方法，了解即可）"><a href="#5、日期对象Date（格式化方法，了解即可）" class="headerlink" title="5、日期对象Date（格式化方法，了解即可）"></a>5、日期对象Date（格式化方法，了解即可）</h4><table><thead><tr><th>alert(box.toDateString());</th><th>//以特定的格式显示星期几、月、日和年</th></tr></thead><tbody><tr><td>alert(box.toTimeString());</td><td>//以特定的格式显示时、分、秒和时区</td></tr><tr><td>alert(box.toLocaleDateString());</td><td>//以特定地区格式显示星期几、月、日和年</td></tr><tr><td>alert(box.toLocaleTimeString());</td><td>//以特定地区格式显示时、分、秒和时区</td></tr><tr><td>alert(box.toUTCString());</td><td>//以特定的格式显示完整的 UTC 日期。</td></tr></tbody></table><h4 id="6、日期对象Date方法"><a href="#6、日期对象Date方法" class="headerlink" title="6、日期对象Date方法"></a>6、日期对象Date方法</h4><p>x(“2015-08-24”);</p><p>//转换格式默认支持2015-08-24或2015/08/24</p><p>//返回距离1970年1月1日0时的毫秒数</p><p>d.getTime()/d.setTime()</p><p>getTime获取某个日期自1970年以来的毫秒数</p><p>setTime修改日期的毫秒数，对应的日期时间也会修改</p><p>var myDate = new Date();</p><p>myDate.getTime();</p><h4 id="7、日期对象方法"><a href="#7、日期对象方法" class="headerlink" title="7、日期对象方法"></a>7、日期对象方法</h4><h5 id="重点记忆（set-get既能获取又能够赋值-get只能获取）"><a href="#重点记忆（set-get既能获取又能够赋值-get只能获取）" class="headerlink" title="重点记忆（set/get既能获取又能够赋值    get只能获取）"></a>重点记忆（set/get既能获取又能够赋值    get只能获取）</h5><blockquote><p>调用格式： 日期对象.方法()</p></blockquote><p>set/getDate() 从Date对象中返回一个月中的某一天(1~31)</p><p>getDay() 从Date对象返回一周中的某一天(0~6 )    获取日期星期几（0~6）0是周日</p><p>set/getMonth() 从Date对象中返回月份(0~11)对应（1~12）</p><p>set/getFullYear() 从Date对象以四位数返回年份</p><p>set/getHours() 返回Date对象的小时(0~23)</p><p>set/getMinutes() 返回Date对象的分钟(0~59)</p><p>set/getSeconds() 返回Date对象的秒数(0~59)</p><p>set/getMilliseconds()   返回Date对象的毫秒</p><p>set/getTime() 返回1970年1月1日至今的毫秒数</p><p>getTimezoneOffset()     返回本地时间与格林威治标准时间(GMT)的分钟差</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><h4 id="setInterval-函数，毫秒数"><a href="#setInterval-函数，毫秒数" class="headerlink" title="setInterval(函数，毫秒数)"></a>setInterval(函数，毫秒数)</h4><p>此处函数不加小括号，此处含义是把函数传过去让他执行</p><p>格式： var timer = setInterval(show, 1000);</p><p>返回值：当前定时器的编码</p><h4 id="clearInterval（timer）；-关闭定时器"><a href="#clearInterval（timer）；-关闭定时器" class="headerlink" title="clearInterval（timer）；//关闭定时器"></a>clearInterval（timer）；//关闭定时器</h4><p>函数写法：</p><p>1、</p><p>function show(){</p><p>}</p><p>2、</p><p>var show = function(){</p><p>}</p><p>show();</p><p>所以上面写法可以替换为</p><p>格式： setInterval( function(){</p><p>}, 1000);</p><p>此处函数叫做匿名函数；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、Math对象&quot;&gt;&lt;a href=&quot;#1、Math对象&quot; class=&quot;headerlink&quot; title=&quot;1、Math对象&quot;&gt;&lt;/a&gt;1、Math对象&lt;/h2&gt;&lt;h4 id=&quot;Math-random&quot;&gt;&lt;a href=&quot;#Math-random&quot; class
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>字符串String</title>
    <link href="http://www.luozy.top/2018/10/23/%E5%AD%97%E7%AC%A6%E4%B8%B2String/"/>
    <id>http://www.luozy.top/2018/10/23/字符串String/</id>
    <published>2018-10-23T07:15:27.000Z</published>
    <updated>2018-10-24T01:28:36.309Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>所有使用单引号或者双引号括起来的内容，都叫字符串。</p><p>​    【注】单引号和双引号没有区别，单引号如果嵌套，要交替使用。</p><p>声明字符串</p><p>1、new</p><p>var str = new String(1000);</p><p>alert(typeof str);//object</p><p>2、省略new 声明字符串</p><p>var str2 = String(1000);</p><p>alert(typeof str);//String</p><p>var str = “1000”;</p><p>alert(typeof str);//string</p><blockquote><p>上述三种不同声明方法使用起来没有区别</p></blockquote><h4 id="字符串数据类型"><a href="#字符串数据类型" class="headerlink" title="字符串数据类型"></a>字符串数据类型</h4><p>​    即是基本数据类型，又是复合数据类型。</p><p>变量存的是字符串的地址</p><p>字符串只读一旦被声明就没法修改，只能抹去重新赋值</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>str.length</p><p>返回当前字符串中字符个数，汉字相当于一个字符；</p><p>访问字符串某一个字符</p><p>可以通过 str[下标]</p><p>【注】只读不可修改</p><p>+拼接字符串</p><h2 id="方法（注意方法调用要加小括号-）"><a href="#方法（注意方法调用要加小括号-）" class="headerlink" title="方法（注意方法调用要加小括号()）"></a>方法（注意方法调用要加小括号()）</h2><h5 id="big-用大号字体显示字符串"><a href="#big-用大号字体显示字符串" class="headerlink" title="big()                 用大号字体显示字符串"></a>big()                 用大号字体显示字符串</h5><h5 id="blink-显示闪动字符串-IE下无效"><a href="#blink-显示闪动字符串-IE下无效" class="headerlink" title="blink()              显示闪动字符串(IE下无效)"></a>blink()              显示闪动字符串(IE下无效)</h5><h5 id="bold-使用粗体显示字符串"><a href="#bold-使用粗体显示字符串" class="headerlink" title="bold()               使用粗体显示字符串"></a>bold()               使用粗体显示字符串</h5><h5 id="fixed-以打字机文本显示字符串"><a href="#fixed-以打字机文本显示字符串" class="headerlink" title="fixed()              以打字机文本显示字符串"></a>fixed()              以打字机文本显示字符串</h5><h5 id="strike-使用删除线来显示字符串"><a href="#strike-使用删除线来显示字符串" class="headerlink" title="strike()             使用删除线来显示字符串"></a>strike()             使用删除线来显示字符串</h5><h5 id="fontcolor-使用指定颜色来显示字符串"><a href="#fontcolor-使用指定颜色来显示字符串" class="headerlink" title="fontcolor()       使用指定颜色来显示字符串"></a>fontcolor()       使用指定颜色来显示字符串</h5><h5 id="fontsize-使用指定尺寸来显示字符串"><a href="#fontsize-使用指定尺寸来显示字符串" class="headerlink" title="fontsize()         使用指定尺寸来显示字符串"></a>fontsize()         使用指定尺寸来显示字符串</h5><h5 id="link-将字符串显示为链接"><a href="#link-将字符串显示为链接" class="headerlink" title="link()                将字符串显示为链接"></a>link()                将字符串显示为链接</h5><h5 id="sub-把字符串显示为下标"><a href="#sub-把字符串显示为下标" class="headerlink" title="sub()                把字符串显示为下标"></a>sub()                把字符串显示为下标</h5><h5 id="sup-把字符串显示为上标"><a href="#sup-把字符串显示为上标" class="headerlink" title="sup()                把字符串显示为上标"></a>sup()                把字符串显示为上标</h5><p>document.write()中使用,用特殊的样式输出该字符串。</p><h3 id="字符串的方法-字符串的获取方法"><a href="#字符串的方法-字符串的获取方法" class="headerlink" title="字符串的方法-字符串的获取方法"></a>字符串的方法-字符串的获取方法</h3><p>charAt(3)         <strong>//获取下标为3的字符</strong></p><p>charCodeAt(3)     <strong>//获取下标为3的字符的编码</strong></p><p>【注】上述两个方法使用字符串对象调用</p><p>fromCharCode(94)  <strong>//编码转换成字符</strong></p><p> 该方法是 String 的静态方法，所以用String调用，        </p><p>如：var str = String.fromCharCode(97,98,99);</p><h3 id="字符串的查找方法"><a href="#字符串的查找方法" class="headerlink" title="字符串的查找方法"></a>字符串的查找方法</h3><p>​    <1>indexOf(“abc”, start);   查找字符串第一次出现的位置，可以传两个参数</1></p><p>​    <2>lastIndexOf(“abc”);      查找字符串最后一次出现的位置  如果没有找到  返回-1</2></p><p>​    <3>search()  正则匹配(返回出现的位置)</3></p><h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h4><p>格式： supStr.indexOf(subStr, start);</p><p>参数： subStr 子串 start 开始查找的位置</p><p>功能： 在supStr中找出subStr第一次出现的位置，从start得到位置开始找</p><p>返回值： -1没找到</p><p>​        &gt;=0 找到了并返回位置</p><h4 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h4><p>与indexOf类似不过是从后往前找</p><h4 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h4><p>格式： supStr.search(subStr/正则表达式);//只有一个参数</p><p>功能： 在supStr中找出subStr第一次出现的位置</p><p>ps：正则表达式是个功能更加强大的字符串</p><p>返回值： -1没找到</p><p>​        &gt;=0 找到了并返回位置</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><h4 id="replace-替换"><a href="#replace-替换" class="headerlink" title="replace()替换"></a>replace()替换</h4><p>格式： supStr.replace(oldStr/ 正则表达式，newStr);</p><p>功能:    用newstr替换oldStr；</p><p>返回值： 新生成的字符串//不会改变原来的字符串；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"how are you”;</span></span><br><span class="line"><span class="string"> alert(str);//"</span>how are you”;</span><br><span class="line">     alert(str.replace(“are”, “old are”)); <span class="comment">//"how old are you”;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的替换只能执行一次，不能够进行全局匹配，如果需要全局匹配，则应使用正则表达式： str.replace(/are/gi,"old are") g表示进行全局匹配，i表示匹配的时候忽略大小写</span></span><br></pre></td></tr></table></figure><h4 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h4><p>和数组slice工能类似</p><p>格式： 字符串.substring（start，end）；</p><p>功能： 提取指定范围内的字符串，生成一个新的字符串[start, end)</p><h4 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h4><p>格式： 字符串.splite(分隔符， 数字) ；</p><p>参数： 第二个：控制返回的数组中元素的个数，一般情况下不传；</p><p>功能： 用分隔符将字符串分割成小的字符串，放在数组中；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;Hello world , hi&quot;</span><br><span class="line">var strArr = str.split(&quot; &quot;);//Hello,world,,,hi</span><br><span class="line"></span><br><span class="line">//特殊用法使用空字符串分割</span><br><span class="line">结果：将字符串每个字符分割放在数组里；</span><br></pre></td></tr></table></figure><h4 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase()"></a>toLowerCase()</h4><p>转小写</p><h4 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase()"></a>toUpperCase()</h4><p>转大写</p><table><thead><tr><th>不改变原来字符串，而是生成新的字符串会改变原字符串</th><th>会改变原字符串</th></tr></thead><tbody><tr><td>replace</td><td>无</td></tr><tr><td>concat</td><td></td></tr><tr><td>split</td><td></td></tr><tr><td>substr</td><td></td></tr><tr><td></td></tr></tbody></table><table><thead><tr><th>修改原数组</th><th>不修改原数组</th></tr></thead><tbody><tr><td>pop push</td><td>concat</td></tr><tr><td>push  shift</td><td></td></tr><tr><td>reverse</td><td></td></tr><tr><td>splice</td><td></td></tr><tr><td></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">st-&gt;op-&gt;condasd</span><br></pre></td></tr></table></figure><p>substr与substring区别</p><p>substr返回的字符串包括结束处字符，而substring不包括</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h1&gt;&lt;p&gt;所有使用单引号或者双引号括起来的内容，都叫字符串。&lt;/p&gt;
&lt;p&gt;​    【注】单引号和双引号没有区别，
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>let和var的区别</title>
    <link href="http://www.luozy.top/2018/10/23/let%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.luozy.top/2018/10/23/let和var的区别/</id>
    <published>2018-10-23T03:32:43.000Z</published>
    <updated>2018-10-23T06:04:30.825Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="let与var"><a href="#let与var" class="headerlink" title="let与var"></a>let与var</h1><p>let是ES6新增的变量类型，是用来替代var的设计，与var不同的是：</p><p>1、let使用块级作用域<br>2、let不支持在同作用域中声明标识符相同的变量<br>3、let用TDZ禁止了声明前访问<br>我们一条一条说明：</p><p>1、JavaScript的作用域（scope）只有全局和局部，对于var声明的变量，只有函数才能为它创建新的作用域，而let支持块级作用域，花括号就能为它创建新的作用域；<br>2、相同作用域，var可以反复声明相同标识符的变量，而let是不允许的;<br>3、let声明的变量禁止在声明前访问，这也是为什么很多人认为let是不支持变量提升的原因，但真的是这样吗？我们来讨论这个问题：</p><p>我们先说明一下什么是变量提升（hoisting）</p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p><a href="https://blog.csdn.net/demo_18/article/details/78493489" target="_blank" rel="noopener">https://blog.csdn.net/demo_18/article/details/78493489</a></p><p>先上一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"hey I am now hoisting"</span>;</span><br></pre></td></tr></table></figure><p>看起来，我们在a被声明前调用a，没有报错，反而是返回一个undefined值，原因是：a其实已经在调用前被声明了，只是没有被初始化。JavaScript会把作用域里的所有变量和函数提到函数的顶部声明，相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">"hey I am now hoisting"</span>;</span><br></pre></td></tr></table></figure><p>JavaScript会使用undefined缺省值创建变量a，注意，事实上浏览器并没有把声明语句放到作用域的顶部，在编译阶段，控制流进入域，该域所有的变量和函数的声明先进入内存，文中代码的相对位置不会变动的。</p><p>由此可以知道，变量提升指的是变量声明的提升，不会提升变量的初始化和赋值。</p><p>对于let来说，情况有点不同:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//Uncaught ReferenceError: a is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">"hey I am now hoisting"</span>;</span><br><span class="line"></span><br><span class="line">这里抛出了一个错误，浏览器认为a并没有声明，这是否意味着<span class="keyword">let</span>并没有使a变量提升呢？我们再看一个例子</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">"hey I am outside"</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//Uncaught ReferenceError: a is not defined</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">"hey I am inside"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看，这里同样抛出了一个错误，认为a没有声明，但是，如果a没有变量提升，执行到console.log时应该是输出全局作用域中的a，而不是出现错误。</p><p>我们可以推知，这里确实出现了变量提升，而我们不能够访问的原因事实上是因为let的死区（temporal dead zone）设计：当前作用域顶部到该变量声明位置中间的部分，都是该let变量的死区，在死区中，禁止访问该变量。由此，我们给出结论，let声明的变量存在变量提升， 但是由于死区我们无法在声明前访问这个变量。</p><h5 id="最后要指出的是，函数也是存在提升（hoisting）的，并且，函数的提升不同于变量的提升，函数相当于把自己的声明、赋值整个的放到了当前作用域的顶部。"><a href="#最后要指出的是，函数也是存在提升（hoisting）的，并且，函数的提升不同于变量的提升，函数相当于把自己的声明、赋值整个的放到了当前作用域的顶部。" class="headerlink" title="最后要指出的是，函数也是存在提升（hoisting）的，并且，函数的提升不同于变量的提升，函数相当于把自己的声明、赋值整个的放到了当前作用域的顶部。"></a>最后要指出的是，函数也是存在提升（hoisting）的，并且，函数的提升不同于变量的提升，函数相当于把自己的声明、赋值整个的放到了当前作用域的顶部。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;let与var&quot;&gt;&lt;a href=&quot;#let与var&quot; class=&quot;headerlink&quot; title=&quot;let与var&quot;&gt;&lt;/a&gt;let与var&lt;/h1&gt;&lt;p&gt;let是ES6新增的变量类型，是用来替代var的设计，与var不同的是：&lt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://www.luozy.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ECMA5新增标签</title>
    <link href="http://www.luozy.top/2018/10/23/ECMA5%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE/"/>
    <id>http://www.luozy.top/2018/10/23/ECMA5新增标签/</id>
    <published>2018-10-23T02:41:52.000Z</published>
    <updated>2018-10-23T07:15:14.866Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="学习目标："><a href="#学习目标：" class="headerlink" title="学习目标："></a>学习目标：</h3><ol><li>ECMA5新增知识点</li><li>严格模式</li><li>新增数组方法</li><li>新增字符串方法</li><li>认识字符串，字符串概念</li><li>字符串的属性和函数</li><li>字符串练习</li><li>实现登录注册严格模式</li></ol><p>  除了正常运行模式，ECMAscript 5 添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。</p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>1、在严格模式下，声明变量必须使用var；</p><p>2、在严格模式下， 函数参数不能重名；</p><p>3、</p><p>this无法指向全局对象；</p><script>   “use strict”;    console.log(“已经进入严格模式”);    function a(){        this.b = 10; //报错，因为this是undefined    }    a();</script><p>4、在严格模式下，arguments存储的是函数传参时候的参数，在修改参数值后，arguments里面的值不会改变；    4.1arguments对象不允许被动态改变：</p><p>5、在严格模式下，新增保留字：implements, interface, let, package, private, protected, public, static, yield。</p><h2 id="ECMA新增的数组方法"><a href="#ECMA新增的数组方法" class="headerlink" title="ECMA新增的数组方法"></a>ECMA新增的数组方法</h2><h3 id="indexOf-data-start"><a href="#indexOf-data-start" class="headerlink" title="indexOf(data,start);"></a>indexOf(data,start);</h3><p>格式：数组.indexOf(data, start);</p><p>参数： data     要查找的元素；</p><p>​         start      从哪个位置开始查找</p><p>功能：查找某一个元素在数组中第一次出现的位置。</p><p>返回值：-1没找到； &gt;=找到了</p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>功能：数组遍历</p><p>var arr = [‘num1’,’num2’];</p><p>arr.forEach(function(item, index, array){</p><p>​    }</p><p>)</p><p>item    当前遍历到的元素num1;num2；</p><p>index    当前遍历到的元素的下标0；1</p><p>array    遍历的数组本身num1,num2</p><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>会遍历当前数组，然后调用参数中的方法，返回当前方法的返回值;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arr</span>)</span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item + <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//map不会改变原有数组，而是将函数执行一次之后的返回值组成一个数组，返回回来。</span></span><br></pre></td></tr></table></figure><h3 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter() 过滤"></a>filter() 过滤</h3><p>var res = [88,69,92,77,90,96,98,99].filter(function(item, index, array){ </p><p>​    return item&gt;80; //找出所有大于80的元素 </p><p>}); </p><p>结果：[88,92,90,96,98,99];//影响原数组</p><h3 id="reduce-归并"><a href="#reduce-归并" class="headerlink" title="reduce()归并"></a>reduce()归并</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre, next, index, array</span>)</span>&#123; </span><br><span class="line">    <span class="comment">//参数中的x和y，代表了之前的处理结果和下一个元素 return x+y; //return的结果会赋值给下一个函数的x参数 </span></span><br><span class="line">&#125;); 结果 ： <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="some-某些"><a href="#some-某些" class="headerlink" title="some()某些"></a>some()某些</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>([<span class="string">"yt"</span>,<span class="string">"hr"</span>,<span class="string">"wc"</span>,<span class="string">"jk"</span>].some(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123; </span><br><span class="line"><span class="comment">//判断数组中是否存在yt？ 如果找到了匹配的元素就不在运行了</span></span><br><span class="line">    <span class="keyword">return</span> item==<span class="string">"yt”; </span></span><br><span class="line"><span class="string">&#125;))&#123; </span></span><br><span class="line"><span class="string">    alert("</span>好的！<span class="string">"); </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><p>跟some一样，但要求每一项都符合，才返回true 有一项不合格就返回false</p><h3 id="String的trim方法"><a href="#String的trim方法" class="headerlink" title="String的trim方法"></a>String的trim方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" abc "</span>.trim(); </span><br><span class="line">首尾去空格 </span><br><span class="line"><span class="string">"abc"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;学习目标：&quot;&gt;&lt;a href=&quot;#学习目标：&quot; class=&quot;headerlink&quot; title=&quot;学习目标：&quot;&gt;&lt;/a&gt;学习目标：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;ECMA5新增知识点&lt;/li&gt;
&lt;li&gt;严格模式&lt;/li&gt;
&lt;li&gt;新增数组方
      
    
    </summary>
    
    
      <category term="H5 js" scheme="http://www.luozy.top/tags/H5-js/"/>
    
  </entry>
  
  <entry>
    <title>js排序</title>
    <link href="http://www.luozy.top/2018/10/22/js%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.luozy.top/2018/10/22/js排序/</id>
    <published>2018-10-22T07:32:22.000Z</published>
    <updated>2018-10-23T03:05:14.294Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="系统自带"><a href="#系统自带" class="headerlink" title="系统自带"></a>系统自带</h2><p>系统有自带的sort排序方法，但是他是对字符串进行判断排序</p><p>所以要对数字排序要给他写一个判断方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">sequence</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a &lt; b)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">5</span> ,<span class="number">56</span>, <span class="number">65</span>, <span class="number">84</span>, <span class="number">98</span>];</span><br><span class="line">alert(arr.sort(sequence));</span><br></pre></td></tr></table></figure><h2 id="用户编写"><a href="#用户编写" class="headerlink" title="用户编写"></a>用户编写</h2><h3 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h3><p>​                数组：9, 8, 7, 6, 5, 4<br>​                第一轮：五次<br>​                    9, 8, 7, 6, 5, 4<br>​                    8, 9, 7, 6, 5, 4<br>​                    8, 7, 9, 6, 5, 4<br>​                    8, 7, 6, 9, 5, 4<br>​                    8, 7, 6, 5, 9, 4<br>​                    8, 7, 6, 5, 4, 9</p><p>​                第二轮：四次<br>​                    8, 7, 6, 5, 4<br>​                    7, 8, 6, 5, 4<br>​                    7, 6, 8, 5, 4<br>​                    7, 6, 5, 8, 4<br>​                    7, 6, 5, 4, 8</p><p>​                第三轮：三次<br>​                    7, 6, 5, 4<br>​                    6, 7, 5, 4<br>​                    6, 5, 7, 4<br>​                    6, 5, 4, 7</p><p>​                第四轮：两次<br>​                    6, 5, 4<br>​                    5, 6, 4<br>​                    5, 4, 6</p><p>​                第五轮：一次<br>​                    5, 4<br>​                    4, 5</p><p>规律：</p><p>1、数组长度6</p><p>2、比较五轮 = 数组长度 - 1</p><p>3、数组长度 = 轮数 + 每一轮的次数</p><p>​    每一轮的次数 = 数组长度 - 轮数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bubbleSort(arr)&#123;</span><br><span class="line">    <span class="comment">//比较的轮数（arr.length-1）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//j每一轮比较的次数（数组长度 - 轮数）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">                arr[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h3><p>打擂台法</p><p>选择排序<br>​                第一轮：<br>​                    9, 8, 7, 6, 5, 4<br>​                    8, 9, 7, 6, 5, 4<br>​                    7, 9, 8, 6, 5, 4<br>​                    6, 9, 8, 7, 5, 4<br>​                    5, 9, 8, 7, 6, 4<br>​                    4, 9, 8, 7, 6, 5</p><p>​                第二轮：<br>​                       9, 8, 7, 6, 5<br>​                       8, 9, 7, 6, 5<br>​                       7, 9, 8, 6, 5<br>​                       6, 9, 8, 7, 5<br>​                       5, 9, 8, 7, 6</p><p>​                第三轮：<br>​                          9, 8, 7, 6<br>​                          8, 9, 7, 6<br>​                          7, 9, 8, 6<br>​                          6, 9, 8, 7</p><p>​                第四轮：</p><p>​                          9, 8, 7<br>​                          8, 9, 7<br>​                          7, 9, 8<br>​                第五轮：<br>​                         9, 8<br>​                         8, 9</p><p>规律：</p><p>​    通过比较首先选出最小的数放在第一个位置上，然后在其余的数中选出次小数放在第二个位置上,依此类推,直到所有的数成为有序序列。</p><p>​    轮数： 数组长度 -  1</p><p>​    每一轮比较次数：数组长度 - 当前轮数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j])&#123;</span><br><span class="line">                <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;系统自带&quot;&gt;&lt;a href=&quot;#系统自带&quot; class=&quot;headerlink&quot; title=&quot;系统自带&quot;&gt;&lt;/a&gt;系统自带&lt;/h2&gt;&lt;p&gt;系统有自带的sort排序方法，但是他是对字符串进行判断排序&lt;/p&gt;
&lt;p&gt;所以要对数字排序要给他写
      
    
    </summary>
    
    
      <category term="H5 js" scheme="http://www.luozy.top/tags/H5-js/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript组成</title>
    <link href="http://www.luozy.top/2018/10/20/JavaScript%E7%BB%84%E6%88%90/"/>
    <id>http://www.luozy.top/2018/10/20/JavaScript组成/</id>
    <published>2018-10-20T09:22:14.000Z</published>
    <updated>2018-10-23T03:06:52.035Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="JavaScript组成部分——ECMAScript、DOM、BOM"><a href="#JavaScript组成部分——ECMAScript、DOM、BOM" class="headerlink" title="JavaScript组成部分——ECMAScript、DOM、BOM"></a>JavaScript组成部分——ECMAScript、DOM、BOM</h2><blockquote><p>虽然 JavaScript 和 ECMAScript 通常被人们用来表达相同的含义，但 JavaScript 的含义却比ECMA-262标准中规定的要多得多。 一个完整的JavaScript应该由下列三个不同的部分组成</p></blockquote><h3 id="核心（ECMAScript）"><a href="#核心（ECMAScript）" class="headerlink" title="核心（ECMAScript）"></a>核心（ECMAScript）</h3><blockquote><p>​    ECMAScript是一种由ECMA国际（前身为欧洲计算机制造商协会，英文名为European Computer Manufacters Association）通过ECMA-262标准化的脚本程序设计语言。ECMAScript定义的只是这门语言的基础，而在此基础上可以构建更完善的脚本语言。我们常见的Web浏览器只是ECMAScript实现可能的宿主环境之一。组成部分有：语法、类型、语句、关键字、保留字、操作符、对象等。</p><p>​    目前ECMAScript有6个版本，分别是<strong>ECMAScript1</strong>、<strong>ECMAScript2</strong>、<strong>ECMAScript3</strong>、<strong>ECMAScript4</strong>（由于制定时分歧过大，并未正式布）、<strong>ECMAScript5、ECMAScript2015</strong>。截止发布日期，JavaScript的官方名称是ECMAScript 2015，下一版本将于今年（2016年）发布，命名为ECMAScript 2016。从2015年开始，新版本将按照ECMAScript+年份的形式发布。</p></blockquote><p>文档对象模型（DOM）——对应Document对象；</p><blockquote><p>​    一个与系统平台和编程语言无关的接口，程序和脚本可以通过这个接口动态访问和修改文档的内容、结构和样式。</p><p>​    DOM把一份文档理解为一颗家谱树（节点数），分别为parent（父节点）、child（子节点）、sibling（兄弟节点），如下图：</p><p>​    <img src="https://images2015.cnblogs.com/blog/920443/201605/920443-20160525093958709-1057258632.png" alt="img"></p><p>文档由节点组成的集合，节点有以下几种类型</p><p>​    元素节点（标签）、文本节点（包含在元素节点中）、属性节点（对元素做出更具体的描述）——几乎所有元素都有一个title属性</p></blockquote><p>DOM把整个网页映射成为一个多层节点</p><h3 id="浏览器对象模型（BOM）——对应window对象"><a href="#浏览器对象模型（BOM）——对应window对象" class="headerlink" title="浏览器对象模型（BOM）——对应window对象"></a>浏览器对象模型（BOM）——对应window对象</h3><p>他提供了很多对象，用于访问浏览器的功能；这些功能与人和网页内容无关；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;JavaScript组成部分——ECMAScript、DOM、BOM&quot;&gt;&lt;a href=&quot;#JavaScript组成部分——ECMAScript、DOM、BOM&quot; class=&quot;headerlink&quot; title=&quot;JavaScript组
      
    
    </summary>
    
    
      <category term="H5 js" scheme="http://www.luozy.top/tags/H5-js/"/>
    
  </entry>
  
  <entry>
    <title>js数组</title>
    <link href="http://www.luozy.top/2018/10/19/js%E6%95%B0%E7%BB%84/"/>
    <id>http://www.luozy.top/2018/10/19/js数组/</id>
    <published>2018-10-19T06:30:53.000Z</published>
    <updated>2018-10-24T03:51:14.098Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>//underfined、null、boolean、string、number为基本数值类型。逗号一并定义初始化多个变量。基本包装类型String、Boolean、Number通过valueOf()可以获取基本数值类型，可以实现自动装箱和拆箱操作。</p><blockquote><p>数组：存储批量数据的一个数据结构</p><p>数据类型：</p><p>​    基本数据类型：</p><p>​        数字</p><p>​        字符串</p><p>​        布尔值</p><p>​    特殊数据类型：</p><p>​        undefined null NaN</p><p>​    复合/引用数据类型：</p><p>​        数组</p></blockquote><h2 id="数组的声明和使用"><a href="#数组的声明和使用" class="headerlink" title="数组的声明和使用"></a>数组的声明和使用</h2><h3 id="声明数组三种方法"><a href="#声明数组三种方法" class="headerlink" title="声明数组三种方法"></a>声明数组三种方法</h3><p>1、var arr = new Array(10, true, “hello”);</p><p>2、var arr = Array(10 , true, “hello”);</p><p>3、var arr = [10, true, “hello”];</p><p>new Array()</p><p>Array()</p><p>​    如果传入参数的时候，仅仅传入了一个参数并且是个数字；</p><p>​    这是它的作用是声明了一个传入数字大小的数组，而不是把这个数字存了进去；</p><h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><p>数组元素：数组中的每一个数据</p><p>访问元素，通过下标（索引）访问。数组[下标]，下标从零开始</p><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p>1、for循环遍历</p><p>for(var i = 0; i&lt; arr.length; i++){</p><p>​    arr[i];</p><p>}</p><p>2、快速遍历（快速枚举）</p><blockquote><p>执行效率更高（但不稳定）</p><p>尽量在for in 的时候，不要增删数组中的元素。</p></blockquote><p>for(var i in arr){</p><p>​    arr[i];</p><p>}</p><h2 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h2><h3 id="1、栈方法-模拟栈结构"><a href="#1、栈方法-模拟栈结构" class="headerlink" title="1、栈方法(模拟栈结构)"></a>1、栈方法(模拟栈结构)</h3><p>特点：先进后出，从一头进同一一头出；</p><p>ECMAScript 数组提供了一种让数组的行为类似于其他数据结构的方法。也就是说，可 以让数组像栈一样，可以限制插入和删除项的数据结构。栈是一种数据结构(后进先出)，也 就是说最新添加的元素最早被移除。而栈中元素的插入(或叫推入)和移除(或叫弹出)，只发 生在一个位置——栈的顶部。ECMAScript 为<strong>数组</strong>专门提供了 <strong>push()</strong>和 <strong>pop()</strong>方法。</p><p><img src="C:\Users\罗中运\AppData\Local\Temp\chrome_drag6452_26913\Image.png" alt="Image"></p><h4 id="1、进栈："><a href="#1、进栈：" class="headerlink" title="1、进栈："></a>1、进栈：</h4><blockquote><p> push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回最该后数组的长度。</p></blockquote><p>push</p><p>格式：数组.push（参数一，参数二，。。。）；</p><p>功能：给原来的数组末尾加元素，直接修改原数组；</p><p>返回值：插完元素后，数组的长度；</p><h4 id="2、出栈："><a href="#2、出栈：" class="headerlink" title="2、出栈："></a>2、出栈：</h4><blockquote><p>二pop()方法则从数组末尾移除最后一个元素，减少数组的length值，然后返回移除的元素。</p></blockquote><p>pop</p><p>格式：数组.pop();</p><p>功能：在原来数组末尾取出一个元素；</p><p>返回值：取出的元素；</p><h3 id="2、队列方法（模拟队列）"><a href="#2、队列方法（模拟队列）" class="headerlink" title="2、队列方法（模拟队列）"></a>2、队列方法（模拟队列）</h3><p>特点：先进先出，从头部进，从尾部出；</p><p>队列在数组的末端添加元素，从数组的前端移除元素。通过push()想数组末尾添加一个元素，然后通过shift()方法从数组前端移除一个元素。</p><p><img src="C:\Users\罗中运\AppData\Local\Temp\chrome_drag6452_6292\Image.png" alt="Image"></p><p>1、shift() </p><blockquote><p> 方法可以移除数组首元素，并且返回长度</p></blockquote><p>孪生元素：unshift（）：从数组头部插入元素，返回插入后数组的长度；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alert(box.push(<span class="string">"深圳”));      //数组末尾添加一个元素，并且返回长度</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">alert(box.shift());                 //移除数组开头元素，并返回移除元素</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">alert(box.unshift());             //数组开头添加两个元素</span></span><br></pre></td></tr></table></figure><p>2.push（）</p><h2 id="复合数据类型与基本数据类型"><a href="#复合数据类型与基本数据类型" class="headerlink" title="复合数据类型与基本数据类型"></a>复合数据类型与基本数据类型</h2><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><strong>基本数据类型</strong></h4><h5 id="在声明变量，var-num2-num1赋值的时候引用没变，只是数值变了；"><a href="#在声明变量，var-num2-num1赋值的时候引用没变，只是数值变了；" class="headerlink" title="在声明变量，var num2 = num1赋值的时候引用没变，只是数值变了；"></a>在声明变量，var num2 = num1赋值的时候引用没变，只是数值变了；</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num2 = num1;</span><br><span class="line"></span><br><span class="line">num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">alert(num1);<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">alert(num2);<span class="comment">//20</span></span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h4><h5 id="gt-在进行arr2-arr1的时候实际上是将引用赋值了过去；这时候他们的引用（地址）不同但是所指向的内容（堆）相同；"><a href="#gt-在进行arr2-arr1的时候实际上是将引用赋值了过去；这时候他们的引用（地址）不同但是所指向的内容（堆）相同；" class="headerlink" title="&gt; 在进行arr2=arr1的时候实际上是将引用赋值了过去；这时候他们的引用（地址）不同但是所指向的内容（堆）相同；"></a>&gt; 在进行arr2=arr1的时候实际上是将引用赋值了过去；这时候他们的引用（地址）不同但是所指向的内容（堆）相同；</h5><p>​    程序在运行之前，会给程序预先分配好程序运行的空间；    </p><p>​    程序运行段 程序运行内存；这部分一旦被申请，就没法修改；</p><p>​    复合数据类型存储在叫做<strong>堆</strong>的内存中；</p><p><strong>也就是内容实际是存在堆里面，程序运行段内存存的是堆的引用；</strong></p><h5 id="在复合数据类型变量里面，只存这个数据的地址；"><a href="#在复合数据类型变量里面，只存这个数据的地址；" class="headerlink" title="在复合数据类型变量里面，只存这个数据的地址；"></a>在复合数据类型变量里面，只存这个数据的地址；</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">"num1"</span>,<span class="string">"num2"</span>,<span class="string">"num3"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = arr1;</span><br><span class="line"></span><br><span class="line">arr2.push(<span class="string">"num4"</span>);</span><br><span class="line"></span><br><span class="line">alert(arr1);<span class="comment">//num1,num2,num3,num4</span></span><br><span class="line"></span><br><span class="line">alert(arr2);<span class="comment">//num1,num2,num3,num4</span></span><br></pre></td></tr></table></figure><h3 id="concat方法"><a href="#concat方法" class="headerlink" title="concat方法"></a>concat方法</h3><p>1、功能1：生成一个新数组；</p><p>2、功能 2：进行数组合并，生成一个合并后的新数组；</p><p>​    格式：数组2 = concat（数组1，元素1，元素2，…）；</p><p>var arr2 = arr1.concat();//生成了一个新数组赋值给arr2，而不是将引用（地址）赋值给arr2；</p><p><img src="https://img-blog.csdn.net/20161022234725144" alt="这里写图片描述">；</p><h3 id="slice方法"><a href="#slice方法" class="headerlink" title="slice方法"></a>slice方法</h3><p>格式： 数组.slice（start，end）；</p><p>参数：start 开始提取的位置</p><p>​    end 结束提取的位置</p><p>​    提取的元素范围[start,end)；</p><h5 id="提取元素但不会修改原数组"><a href="#提取元素但不会修改原数组" class="headerlink" title="提取元素但不会修改原数组"></a>提取元素但不会修改原数组</h5><p>返回值：提取到的元素，组成的元素；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&quot;num1&quot;,&quot;num2&quot;,&quot;num3&quot;];</span><br><span class="line">var arr2 = arr1.slice(1,2);//num2</span><br></pre></td></tr></table></figure><h3 id="splice方法"><a href="#splice方法" class="headerlink" title="splice方法"></a>splice方法</h3><p>功能：增删改数组</p><blockquote><p>格式：数组.splice(start,length,元素1，元素2，…)；</p><p>功能1：删除选中的元素：数组.splice(start,length）；</p><p>功能2：插入元素数组.splice(start,0，元素1，元素2，….）；</p><p>功能3：混合使用 数组.splice(start,1，元素);//替换了start位置的元素；</p><p>返回值是删除元素的数组；</p><p>第一个参数：开始截取的下标</p><p>第二个参数：截取元素的长度</p><p>第三个和之后的参数，插入的元素</p></blockquote><h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><p>将数组的元素组起一个字符串，</p><blockquote><p>格式“数组.jion（字符串）；</p><p>参数：拼接的拼接符</p><p>返回值：拼接完成的字符串；</p></blockquote><h4 id="reverse方法"><a href="#reverse方法" class="headerlink" title="reverse方法"></a>reverse方法</h4><blockquote><p>数组逆置 </p></blockquote><p>ps :<strong>concat slice jion不修改原数组；</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;//underfined、null、boolean、string、number为基本数值类型。逗号一并定义初始化多个变量。基本包装类型String、Boolean、Number通过valueOf()可以获取基本数值类型，可以实现自动装箱和拆箱操作。
      
    
    </summary>
    
    
      <category term="H5 js" scheme="http://www.luozy.top/tags/H5-js/"/>
    
  </entry>
  
  <entry>
    <title>js作用域</title>
    <link href="http://www.luozy.top/2018/10/19/js%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://www.luozy.top/2018/10/19/js作用域/</id>
    <published>2018-10-19T01:17:42.000Z</published>
    <updated>2018-10-23T06:13:09.057Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>程序必须读到内存中，才能被CPU运行。</p><p>声明变量 分配内存空间的过程。</p><p>函数调用，函数运行的时候，需要内存空间来运行；</p><p>【注】</p><p>​    在某一函数内声明的变量或形参（形参在函数内和变量基本一致），它的生命周期是这个函数调用开始到这个函数调用结束，销毁；</p><h4 id="作用域："><a href="#作用域：" class="headerlink" title="作用域："></a>作用域：</h4><p>​    局部作用域：每一个函数都死一个局部作用域。</p><p>​            在局部作用域里面声明的变量和形参，叫局部变量；</p><p>​    全局作用域：在全局作用域里面声明的变量和形参，叫做全局变量；</p><h5 id="js中只有全局作用域和函数作用域"><a href="#js中只有全局作用域和函数作用域" class="headerlink" title="js中只有全局作用域和函数作用域"></a>js中只有全局作用域和函数作用域</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i =<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure><blockquote><p>可以执行，结果为10</p></blockquote><p>为什么呢，因为在JavaScript中不同于Java他没有块作用域；</p><p>当然在JavaScript中我们也可以实现块作用域的功能。如以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">)()</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure><blockquote><p>这种写法叫做立即调用函数表达式</p></blockquote><h4 id="访问数据："><a href="#访问数据：" class="headerlink" title="访问数据："></a>访问数据：</h4><p>​    1、就近原则</p><p>​    2、访问数据，如果当前作用域没有该数据，则从大一级的作用域寻找；</p><p>##### </p><h4 id="全局函数："><a href="#全局函数：" class="headerlink" title="全局函数："></a>全局函数：</h4><p>​    var a =function(x){</p><p>​        var b = ‘bb’;</p><p>​        return b;</p><p>​    }</p><p>【注】：如果不写var直接声明变量，那么这个变量将会被声明为全局变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;程序必须读到内存中，才能被CPU运行。&lt;/p&gt;
&lt;p&gt;声明变量 分配内存空间的过程。&lt;/p&gt;
&lt;p&gt;函数调用，函数运行的时候，需要内存空间来运行；&lt;/p&gt;
&lt;p&gt;【注】&lt;/p&gt;
&lt;p&gt;​    在某一函数内声明的变量或形参（形参在函数内和变量基本一
      
    
    </summary>
    
    
      <category term="H5 js" scheme="http://www.luozy.top/tags/H5-js/"/>
    
  </entry>
  
  <entry>
    <title>js函数的概念和作用</title>
    <link href="http://www.luozy.top/2018/10/18/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8/"/>
    <id>http://www.luozy.top/2018/10/18/js函数的概念和作用/</id>
    <published>2018-10-18T06:11:06.000Z</published>
    <updated>2018-10-23T03:06:30.919Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="JS函数及作用"><a href="#JS函数及作用" class="headerlink" title="JS函数及作用"></a>JS函数及作用</h1><ol><li>函数的概念，及作用</li><li>函数的声明</li><li>如何执行函数（调用）</li><li>函数的参数（实参，形参）,返回值</li><li>arguments</li><li>作用域</li><li>DOM的简单操作</li><li>递归</li></ol><blockquote><p>在js的世界里存在函数，函数是把强大的功能集中在一起；</p><p>调用函数，执行函数中具体的代码，最终把函数的功能实现了；</p><p>书写步骤：</p><p>​    1、在标签或文件里书写函数</p><p>​    2、在一处调用</p></blockquote><h3 id="1、概念："><a href="#1、概念：" class="headerlink" title="1、概念："></a>1、概念：</h3><p>函数就是把完成特定功能的一段代码[抽象出来]，使之成为程序中的一个<strong>[独立实体]</strong>，起个名字<strong>（函数名）</strong>。可以在同一个程序或其他程序中多次重复使用<strong>（通过函数名调用）</strong>。</p><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><ul><li>使程序变得简短而清晰</li><li>有利于程序维护</li><li>可以提高程序开发效率</li><li>提高了代码的重用性（复用性</li></ul><h3 id="2、声明函数"><a href="#2、声明函数" class="headerlink" title="2、声明函数"></a>2、声明函数</h3><p>function     函数名(){</p><p>​    具体要执行的代码；</p><p>}</p><h4 id="调用："><a href="#调用：" class="headerlink" title="调用："></a>调用：</h4><p>函数名();</p><h3 id="3、函数的分类"><a href="#3、函数的分类" class="headerlink" title="3、函数的分类"></a>3、函数的分类</h3><p>分三大类：</p><p>​    1、内置函数（系统函数）</p><p>​    2、用户自定义函数</p><p>​    3、事件驱动函数</p><h3 id="4、函数参数"><a href="#4、函数参数" class="headerlink" title="4、函数参数"></a>4、函数参数</h3><blockquote><p>不确定的值要当做参数去假设；</p><p>分为： 形参、实参</p><p>形参（形式上的参数）</p><p>传参：用实际的参数去代替原来形式上的参数。</p></blockquote><p>如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    alert(x + y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传参</span></span><br><span class="line">add(<span class="number">10</span>， <span class="number">20</span>)；</span><br></pre></td></tr></table></figure><h3 id="返回值（return）"><a href="#返回值（return）" class="headerlink" title="返回值（return）"></a>返回值（return）</h3><blockquote><p>可有可无</p><p>作用：</p><p>1、作为函数的值，return后面表达式的值就是函数的返回值；</p><p>2、在执行return后，函数后面的代码不会再执行；</p></blockquote><h4 id="编写一个函数"><a href="#编写一个函数" class="headerlink" title="编写一个函数"></a>编写一个函数</h4><p>1、确定未知量</p><p>也就是形参数量，多个形参通过逗号隔开；</p><p>2、编写函数；</p><p>3、确认返回值；（只会执行一个）</p><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><blockquote><p>每一个函数内部都有一个arguments</p></blockquote><p>功能： 当我们调用函数的时候，给函数传入实参，会全部存储在arguments里面。</p><p>使用arguments</p><p>​    arguments.length 传入了几个实参</p><p>​    arguments[下标]    通过索引访问</p><p>ps：为了让函数可读性更高，尽量不要用arguments</p><h3 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h3><p>特点：</p><p>​    1、函数自己调用自己；</p><p>​    2、递归函数一般都有参数；</p><p>​    3、递归函数一般都有return；</p><p>功能：</p><p>​    循环能做的，递归都能做，循环做不到的递归也能做；</p><p>作用：</p><p>​    精简代码</p><h4 id="递归的规律"><a href="#递归的规律" class="headerlink" title="递归的规律"></a>递归的规律</h4><p>​    1、找出临界值（），临界值无需计算直接可以得出</p><p>​    2、找出第n次和第n-1次的关系</p><p>​    3、假设函数运行，写出第n次和第n-1次的关系</p><p>1、递归会导致内存溢出，尾递归除外- -</p><p>2、为了能回溯，递归函数的参数和地址需要分配在 call stack 上，大部分语言的 call stack 大小都是有限的，递归太深就会爆掉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;JS函数及作用&quot;&gt;&lt;a href=&quot;#JS函数及作用&quot; class=&quot;headerlink&quot; title=&quot;JS函数及作用&quot;&gt;&lt;/a&gt;JS函数及作用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;函数的概念，及作用&lt;/li&gt;
&lt;li&gt;函数的声明&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="H5 js 函数" scheme="http://www.luozy.top/tags/H5-js-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何在JavaScript中获取CSS值</title>
    <link href="http://www.luozy.top/2018/10/18/%E5%A6%82%E4%BD%95%E5%9C%A8JavaScript%E4%B8%AD%E8%8E%B7%E5%8F%96CSS%E5%80%BC/"/>
    <id>http://www.luozy.top/2018/10/18/如何在JavaScript中获取CSS值/</id>
    <published>2018-10-18T03:57:51.000Z</published>
    <updated>2018-10-18T06:21:36.556Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有时候单独的使用CSS是不够的。您可能需要使用JavaScript控制CSS值。但是你如何在JavaScript中获得CSS值？</p><p>有两种可能的方式，取决于您是尝试获取内联样式还是计算样式</p></blockquote><h2 id="获取内联样式"><a href="#获取内联样式" class="headerlink" title="获取内联样式"></a>获取内联样式</h2><blockquote><p>内联样式是存在于 HTML <code>style</code> 属性(attribute)中的样式。</p></blockquote><h5 id="html-代码："><a href="#html-代码：" class="headerlink" title="html 代码："></a>html 代码：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"element"</span> <span class="attr">style</span>=<span class="string">"font-size: 2em; color: red;"</span>&gt;</span></span><br><span class="line">    Red hot chili pepper!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="JavaScript代码"><a href="#JavaScript代码" class="headerlink" title="JavaScript代码"></a>JavaScript代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.querySelector(<span class="string">'.element'</span>)</span><br><span class="line"><span class="keyword">const</span> fontSize = element.style.fontSize</span><br><span class="line"><span class="built_in">console</span>.log(fontSize) <span class="comment">// 2em</span></span><br><span class="line"><span class="keyword">const</span> color = element.style.color</span><br><span class="line"><span class="built_in">console</span>.log(color) <span class="comment">// red</span></span><br></pre></td></tr></table></figure><h2 id="获取计算样式"><a href="#获取计算样式" class="headerlink" title="获取计算样式"></a>获取计算样式</h2><p>如果您的样式是在CSS文件中编写的，则需要获取计算出的样式。为此，您可以使用 <code>getComputedStyle</code> 。</p><p>它有两个值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:<span class="keyword">const</span> style = getComputedStyle(Element, );</span><br></pre></td></tr></table></figure><p>这里的<code>Element</code>是指您使用 <code>querySelector</code> 选择的元素。</p><p>这里的 <code>pseudoElement</code> 指的是你想要获取的伪类元素的字符串（如果有的话）。如果您没有选择伪元素，则可以省略这个值。</p><p>让我们通过一个例子来帮助理解。假设您有以下HTML和CSS：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTML 代码:<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"element"</span>&gt;</span> This is my element <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">CSS 代码:.element &#123; background-color: red &#125;</span><br></pre></td></tr></table></figure><p>首先，您需要使用 <code>querySelector</code> 选择元素。然后，使用 <code>getComputedStyle</code> 获取元素的样式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:<span class="keyword">const</span> element = <span class="built_in">document</span>.querySelector(<span class="string">'.element'</span>)<span class="keyword">const</span> style = getComputedStyle(element)</span><br></pre></td></tr></table></figure><p>如果你用 <code>console.log(style)</code> 打印，您应该看到一个包含每个CSS属性及其各自值的对象。</p><p><img src="http://newimg88.b0.upaiyun.com/newimg88/2018/07/all-properties.png" alt="img"></p><p>图注：<code>getComputedStyle</code> 返回一个包含每个CSS属性及其各自值的对象</p><p>您还可以在Chrome和Firefox的开发工具中看到此对象。</p><p>对于Firefox开发工具，请查看 “Inspector”，“Computed”。</p><p><img src="http://newimg88.b0.upaiyun.com/newimg88/2018/07/firefox.png" alt="img"></p><p>图注：Firefox dev工具计算样式选项卡</p><p>对于Chrome开发工具，请查看“Elements” 面板。 如果开发工具窗口很大，您可以在右侧面板上看到计算出的样式。 如果开发工具窗口很小，您可以在“Computed”选项卡下查看。</p><p><img src="http://newimg88.b0.upaiyun.com/newimg88/2018/07/chrome.png" alt="img"></p><p>图注：Chrome dev工具计算样式选项卡</p><p>要获取CSS属性的值，请以驼峰形式编写属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 代码:<span class="keyword">const</span> style = getComputedStyle(element)<span class="keyword">const</span> backgroundColor = style.backgroundColorconsole.log(backgroundColor) <span class="comment">// rgb(0, 0, 0)</span></span><br></pre></td></tr></table></figure><p>注意：<code>getComputedStyle</code> 是只读的。您无法使用 <code>getComputedStyle</code> 设置CSS值。</p><p>注意2：<code>getComputedStyle</code> 获取计算出的CSS值。你将从 <code>getComputedStyle</code> 获得 px 单位值，而不是像 <code>em</code> 和 <code>rem</code> 这样的相对单位。</p><h2 id="从伪类元素中获取样式"><a href="#从伪类元素中获取样式" class="headerlink" title="从伪类元素中获取样式"></a>从伪类元素中获取样式</h2><p>要从伪类元素获取样式，您需要将伪类元素的字符串作为第二个参数传递给 <code>getComputedStyle</code> 。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTML 代码:<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"element"</span>&gt;</span> This is my element <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">CSS 代码:element &#123; background-color: red &#125;.element::before &#123; content: "Before pseudo element"; &#125;</span><br><span class="line">JavaScript 代码:const element = document.querySelector('.element')pseudoElementStyle = getComputedStyle(element, '::before')console.log(pseudoElementStyle.content) // Before pseudo element</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>您可以通过两种方法在JavaScript中获取CSS值：</p><ol><li><code>style</code> 属性(property)</li><li><code>getComputedStyle</code> 。</li></ol><p><code>style</code> 属性仅检索内联CSS值，而 <code>getComputedStyle</code> 样式检索计算的CSS值。</p><p>原文链接：<a href="https://zellwk.com/blog/css-values-in-js/" target="_blank" rel="noopener">https://zellwk.com/blog/css-values-in-js/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有时候单独的使用CSS是不够的。您可能需要使用JavaScript控制CSS值。但是你如何在JavaScript中获得CSS值？&lt;/p&gt;
&lt;p&gt;有两种可能的方式，取决于您是尝试获取内联样式还是计算样式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="H5 js" scheme="http://www.luozy.top/tags/H5-js/"/>
    
  </entry>
  
  <entry>
    <title>js循环练习</title>
    <link href="http://www.luozy.top/2018/10/18/js%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97%E7%BB%83%E4%B9%A0/"/>
    <id>http://www.luozy.top/2018/10/18/js循环嵌套练习/</id>
    <published>2018-10-18T02:40:40.000Z</published>
    <updated>2018-10-18T02:42:28.885Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 水仙花</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;h3&gt;找出所有的水仙花数，三位数，各位立方和等于该数本身。153 = 1 ^ 3 + 5 ^ 3 + 3 ^ 3&lt;/h3&gt;"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">100</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">Math</span>.pow((i % <span class="number">10</span>),<span class="number">3</span>) +  <span class="built_in">Math</span>.pow( (<span class="built_in">parseInt</span>(i / <span class="number">10</span>) % <span class="number">10</span>),<span class="number">3</span>) + <span class="built_in">Math</span>.pow((<span class="built_in">parseInt</span>(i / <span class="number">100</span>) % <span class="number">10</span>),<span class="number">3</span>)) == i)&#123;</span><br><span class="line">        <span class="built_in">document</span>.write( <span class="string">"&lt;br/&gt;"</span> + <span class="string">"&amp;nbsp;"</span> + i + <span class="string">" : "</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="built_in">Math</span>.pow((i % <span class="number">10</span>),<span class="number">3</span>) + <span class="string">"*"</span> + <span class="built_in">Math</span>.pow( (<span class="built_in">parseInt</span>(i / <span class="number">10</span>) % <span class="number">10</span>),<span class="number">3</span>) + <span class="string">"*"</span> + <span class="built_in">Math</span>.pow((<span class="built_in">parseInt</span>(i / <span class="number">100</span>) % <span class="number">10</span>),<span class="number">3</span>)+ <span class="string">"="</span>+ i );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最大公约数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;h3&gt;最大公约数&lt;/h3&gt;"</span>);</span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = (num1 &gt; num2 ? num1 : num2); i &gt; <span class="number">1</span>; i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(num1 % i== <span class="number">0</span> &amp;&amp; num2 % i == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"最大公约数为"</span> + i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小公倍数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;h3&gt;最小公倍数&lt;/h3&gt;"</span>);</span><br><span class="line"><span class="keyword">var</span> num3 = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> num4 = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = (num3 &gt; num4 ? num4 : num3); i &lt; num1 * num2; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i % num3 == <span class="number">0</span> &amp;&amp; i % num4 == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"最大公约数为"</span> + i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入两个数n，a，如果n==3，a==2； 输出 2 + 22 + 222 的值。（不用输出式子）如果n==4，a==3；输出 3 + 33 + 333 + 3333的值。</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;h3&gt;2 + 22 + 222 =&lt;/h3&gt;"</span>);</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">var</span> number = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> flag = number;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= count; i++)&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(flag + <span class="string">" + "</span>);</span><br><span class="line">    sum += flag;</span><br><span class="line">    flag += <span class="built_in">Math</span>.pow(<span class="number">10</span> , i) * number;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">" = "</span> + sum);</span><br><span class="line"><span class="comment">//回文数</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;h3&gt;回文数&lt;/h3&gt;"</span>);</span><br><span class="line"><span class="keyword">var</span> num5 = <span class="number">123321</span>;</span><br><span class="line"><span class="keyword">var</span> places = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> flag5 = num5;</span><br><span class="line"><span class="keyword">while</span>(flag5 / <span class="number">10</span> &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    places++;</span><br><span class="line">    flag5 /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.write(places + <span class="string">"位数"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; places; i+=<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">parseInt</span>(num5 / <span class="built_in">Math</span>.pow(<span class="number">10</span> , places-i)) == (num5 % <span class="number">10</span>))&#123;</span><br><span class="line">        num5 %= <span class="built_in">Math</span>.pow(<span class="number">10</span> , places-i);</span><br><span class="line">        num5 /= <span class="number">10</span>;</span><br><span class="line">        num5 = <span class="built_in">parseInt</span>(num5);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"不是回文数"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
    
      <category term="H5 js 循环" scheme="http://www.luozy.top/tags/H5-js-%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>js流程控制语句</title>
    <link href="http://www.luozy.top/2018/10/17/js%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
    <id>http://www.luozy.top/2018/10/17/js流程控制语句/</id>
    <published>2018-10-17T06:29:22.000Z</published>
    <updated>2018-10-23T03:05:51.247Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h1><h4 id="1、顺序结构"><a href="#1、顺序结构" class="headerlink" title="1、顺序结构"></a>1、顺序结构</h4><p>​    默认</p><h4 id="2、选择结构-分支语句-条件语句（双分支语句if、多分支语句switch）"><a href="#2、选择结构-分支语句-条件语句（双分支语句if、多分支语句switch）" class="headerlink" title="2、选择结构/分支语句/条件语句（双分支语句if、多分支语句switch）"></a>2、选择结构/分支语句/条件语句（双分支语句if、多分支语句switch）</h4><blockquote><p>if(条件判断语句){</p><p>​    代码；</p><p>}else{</p><p>​    代码；</p><p>}</p><p>switch(){</p><p>​    case ‘情形1’ ：代码；</p><p>​    case ‘情形2’ ：代码；</p><p>}</p></blockquote><h4 id="3、循环机构"><a href="#3、循环机构" class="headerlink" title="3、循环机构"></a>3、循环机构</h4><blockquote><p>循环：重复去做一件事情</p></blockquote><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><blockquote><p>格式：</p><p>for(表达式1；表达式2；表达式3){</p><p>​    循环的代码；</p><p>}</p><p>执行过程：</p><p>​    1、先会去执行表达式1，再去判断表达式2，如果表达式为 true，执行循环代码。如果表达式为false，结束循环。</p><p>​    2、再去执行表达式3，判断表达式2是否成立，重复1,2。</p><p>ps:好处：必要表达式不容易丢；</p></blockquote><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><blockquote><p>循环格式：</p><p>​    while（循环条件）{</p><p>​        如果条件成立，运行此处代码；</p><p>​    }</p><p>循环编写过程：</p><p>1、确定循环次数</p><p>2、每次执行的动作</p><p>ps: 注意不要造成死循环</p></blockquote><h5 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h5><blockquote><p>与while基本相同</p><p>唯一区别：do while 第一次会先执行再去判断。</p></blockquote><p>【注】：</p><p>do{</p><p>}while();</p><p>while后面的；不可省略</p><p>ps: do while 几乎不用 ， while循环用的比较少， for循环经常使用</p><h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p>for( ;  ;  ;){    </p><p>​    for( ; ; ;){</p><p>​    }</p><p>}</p><p>while(){</p><p>​    for( ; ; ;){</p><p>​    }</p><p>}</p><h5 id="【注】：变量循环要由0开始"><a href="#【注】：变量循环要由0开始" class="headerlink" title="【注】：变量循环要由0开始"></a>【注】：变量循环要由0开始</h5><h4 id="break与cotinue"><a href="#break与cotinue" class="headerlink" title="break与cotinue"></a>break与cotinue</h4><blockquote><p>break</p><p>​    功能：结束当前循环。</p><p>continue</p><p>​    功能：跳过这次循环，直接进入下次循环。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;流程控制语句&quot;&gt;&lt;a href=&quot;#流程控制语句&quot; class=&quot;headerlink&quot; title=&quot;流程控制语句&quot;&gt;&lt;/a&gt;流程控制语句&lt;/h1&gt;&lt;h4 id=&quot;1、顺序结构&quot;&gt;&lt;a href=&quot;#1、顺序结构&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="js H5" scheme="http://www.luozy.top/tags/js-H5/"/>
    
  </entry>
  
  <entry>
    <title>js基础</title>
    <link href="http://www.luozy.top/2018/10/17/js%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.luozy.top/2018/10/17/js基础/</id>
    <published>2018-10-17T00:49:01.000Z</published>
    <updated>2018-10-23T03:06:16.844Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="js组成"><a href="#js组成" class="headerlink" title="js组成"></a>js组成</h2><blockquote><p>JavaScript</p><p>1、ECMAScript标准 4.0 5.0 6.0</p><p>2、BoM   浏览器对象</p><p>3、DOM 对象</p></blockquote><h3 id="JS语法规范"><a href="#JS语法规范" class="headerlink" title="JS语法规范"></a>JS语法规范</h3><blockquote><p>srcipt标签两个作用</p></blockquote><p>1、方法一 js代码写在script标签里面</p><p>2、方法二 外部引入js文件方式</p><p>ps: 不可混合使用</p><p>执行顺序自上而下</p><p>type表明要执行的内容格式</p><p>如不可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">"demo.js"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">alert(<span class="string">"hello world"</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h4><p>1、代码缩进；</p><p>2、每一条语句结尾都加一个分号；</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>单行注释 // ctrl ＋ /</p><p>多行注释 /<em>  </em>/  ctrl ＋ shift ＋ /</p><h2 id="js输出方式"><a href="#js输出方式" class="headerlink" title="js输出方式"></a>js输出方式</h2><blockquote><p>1） alert(); //弹出警告框，在警告框上显示内容</p><p>2）document write(); // 直接显示在页面上</p><p>3）console log(); //控制台输出，一般用来调试代码用的</p></blockquote><p>ps：</p><p>document.write(“hello world”);<br>document.write(“</p><h1>hello <em>world</em><h1>“);<br>console.log(“hello”);<p></p><p>要想输出标签要用 &amp;lt； 和&amp;gt；</p><h2 id="document-write-“-lt-srcipt-gt-”"><a href="#document-write-“-lt-srcipt-gt-”" class="headerlink" title="document.write(“&lt;srcipt &gt;”);"></a>document.write(“&lt;srcipt &gt;”);</h2><h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><h5 id="常量（字面量）"><a href="#常量（字面量）" class="headerlink" title="常量（字面量）"></a>常量（字面量）</h5><blockquote><p>数据类型: </p><p>​    基本数据类型：</p><p>​    number 数字 0, 10 ,3.14</p><p>​    string  字符串 所带单引号和双引号的都叫字符串</p><p>​    boolean 布尔值 true false</p><p>​    特殊数据类型：</p><p>​    null 空</p><p>​    undefined 未声明</p><p>​    NaN not a number 不是一个数字</p><p>关键字（有特殊功能的单词）：typeof ；//输出当前数据的输出类型。</p></blockquote><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><blockquote><p>值可以修改的叫做变量</p><p>​    1、声明变量，适合内存申请一部分空间，存储数据</p><p>​    2、变量的数据，是根据存储的数据决定的</p><p>​    初始化：声明变量后接着赋值叫做初始化</p><p>​    【注】如果声明变量的时候，没有赋值，默认是undefined。</p><p>​    /*</p><p>​        避免后续赋值的时候多出抹除undefined操作，先将值赋值为null。</p><p>​    */</p><p>​    </p></blockquote><h2 id="命名规则："><a href="#命名规则：" class="headerlink" title="命名规则："></a>命名规则：</h2><blockquote><p>【注】所有用户自定义的名字都叫标识符，变量名也叫标识符</p><p>*只能有数字、字母、下划线、$组成</p><p>​    *变量名不能有数字开头</p><p>​    *不能用关键字（如typeof）和保留字（系统已经征用的）</p><p>​    *js区分大小写 a和A不是一个</p><p>​    *见名思意</p><p>​    *尽量别用拼音和缩写，使用英文全拼（驼峰式命名className/烤串式命名class_name）</p></blockquote><p>​    </p><p>var num = 10；</p><p>alert（num）；</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>32 位操作系统</p><p>64位操作系统</p><p>位：地址总线 可最大寻址数</p><h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><p>十进制转2进制：</p><pre><code>要从右到左用二进制的每个数去乘以2的相应次方,小数点后则是从左往右</code></pre><p>num.toString(2);</p><p>num.toString(8);</p><p>num.toString(10);</p><p>num.toString(16);</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>算术运算符 + - * /</p><p>关系运算符 &lt; &gt; &gt;= &lt;= == === !=</p><p>逻辑运算符 &amp;&amp; || ！</p><p>赋值运算符 -= += /= %=</p><p>自增 、自减 ++ –</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><blockquote><p>概念： 任何运算符和操作数（变量/常量）组成的式子都叫做表达式；</p><p>1、表达式的值</p><p>2、表达式的功能</p></blockquote><h2 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h2><p>算术运算符和操作符组成的式子</p><p>1、如果两个数都是数字，进行数学运算</p><p>2、不同类型数据进行运算，会进行自动类型数据转换</p><h4 id="自动数据类型转换"><a href="#自动数据类型转换" class="headerlink" title="自动数据类型转换"></a>自动数据类型转换</h4><p>1、假设进行的运算是加法运算，并且一种有一个操作数是字符串，那么运算会变成字符串拼接</p><p>如： ‘10’+123=”10123”;</p><p>2、任何数据类型做除加法以外的运算，都会将别的类型转换为数字再进行运算。</p><p>ps: </p><p>1）当把一个带字母的字符串转化为数字时会转成NaN，而且NaN和任何数据进行运算都会变成NaN；</p><p>2）如果操作数是纯数字的字符串进行运算会转换为数字再进行运算；</p><p>3）true转换为数字是1，false是0；</p><p>4）undefined转换为数字是NaN，null是0；</p><p>3、</p><p>var num = 10 / 0 = Infinity</p><p>var num = -10 /0 = -Infinity</p><p>ps 计算机不会进行小数运算</p><h4 id="强制数据类型转换"><a href="#强制数据类型转换" class="headerlink" title="强制数据类型转换"></a>强制数据类型转换</h4><p>人为地进行数据转换</p><h5 id="Number（）将别的数据类型转换为数字"><a href="#Number（）将别的数据类型转换为数字" class="headerlink" title="Number（）将别的数据类型转换为数字"></a>Number（）将别的数据类型转换为数字</h5><p>1）纯数字的字符会转换成数字</p><p>2）如果带有非数字的字符会转成NaN</p><p>3）true=&gt;1, false=&gt;0</p><p>4)null=&gt;0,undefined=&gt;Nan</p><h5 id="Boolean（）将别的数据类型转换为布尔值"><a href="#Boolean（）将别的数据类型转换为布尔值" class="headerlink" title="Boolean（）将别的数据类型转换为布尔值"></a>Boolean（）将别的数据类型转换为布尔值</h5><p>1)数字：非0即真</p><p>2）有内容字符串=&gt;true,空字符串(“”)=&gt;true,非空即真</p><p>3）null=&gt;false,undefined=&gt;false,NaN=&gt;false;</p><h5 id="parseInt-取整：parseInt-20aa-20-parseInt-a20aa-NaN"><a href="#parseInt-取整：parseInt-20aa-20-parseInt-a20aa-NaN" class="headerlink" title="parseInt()      取整：parseInt(20aa)=20;parseInt(a20aa)=NaN;"></a>parseInt()      取整：parseInt(20aa)=20;parseInt(a20aa)=NaN;</h5><h5 id="parseFloat-取浮点数"><a href="#parseFloat-取浮点数" class="headerlink" title="parseFloat()   取浮点数"></a>parseFloat()   取浮点数</h5><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><blockquote><p>1、= 功能： 就是用来赋值，将等号右边的值赋给左边的变量</p><p>2、复合赋值运算符： += , -= , /= , *= , %=</p><p>3、一元运算符：++ –</p><p>​    a++： 先取a的值作为a++的值，在对a进行加一</p><p>​    ++a: 先对a进行加一，再取++a的值</p></blockquote><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>&lt;  &gt; = &gt;= &lt;= == === !=</p><p>关系运算符运算规则</p><p>1、两个都是数字，对数字进行比较；</p><p>2、其中一个是数字，另一个转化为数字进行比较</p><p>3、当两个操作数是字符串的时候</p><p>​    1）实际上是比较字符的ASCII码</p><p>​    2）逐个进行比较： 如”asd”&lt;”bsdf”=true因为a的ASCII码大于b的。</p><p>ps: true 转换成1进行比较，false转换成0进行比较</p><p>NaN和任何数据（包括自己）==都为false ！=都为true</p><p>4、全等（恒等）=== （1）值必须相等（2）数据类型也必须相等</p><h5 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h5><p>undefined == 0 false</p><p>null == 0 false</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>与/且     &amp;&amp;</p><p>​    格式： 表达式1 &amp;&amp; 表达式2</p><p>​    特点： 两个表达式都为真他才为真</p><p>或        ||</p><p>​    格式： 表达式1 ||　表达式２</p><p>​    特点：　只有两个表达式都为加表达式才为假</p><p>非　    ！</p><p>​    格式：　！表达式</p><p>​    特点：　！true = false</p></h1></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;js组成&quot;&gt;&lt;a href=&quot;#js组成&quot; class=&quot;headerlink&quot; title=&quot;js组成&quot;&gt;&lt;/a&gt;js组成&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;JavaScript&lt;/p&gt;
&lt;p&gt;1、ECMAScript标准 4.0
      
    
    </summary>
    
    
      <category term="H5" scheme="http://www.luozy.top/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>The Spectre（Alan Walker）</title>
    <link href="http://www.luozy.top/2018/10/13/The-Spectre%EF%BC%88Alan-Walker%EF%BC%89/"/>
    <id>http://www.luozy.top/2018/10/13/The-Spectre（Alan-Walker）/</id>
    <published>2018-10-13T03:27:26.000Z</published>
    <updated>2018-10-13T03:45:58.625Z</updated>
    
    <content type="html"><![CDATA[<video controls autoplay loop preload=""><br><br>​    <source id="mp4" src="http://pgip9g5iy.bkt.clouddn.com/Alan%20Walker%20-%20The%20Spectre.mp4" type="video/mp4"><br><br></video>]]></content>
    
    <summary type="html">
    
      
      
        &lt;video controls autoplay loop preload=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;​    &lt;source id=&quot;mp4&quot; src=&quot;http://pgip9g5iy.bkt.clouddn.com/Alan%20Walker%20-%20The%20Spect
      
    
    </summary>
    
    
      <category term="H5" scheme="http://www.luozy.top/tags/H5/"/>
    
  </entry>
  
</feed>
