<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chentj&#39;s Blog</title>
  
  <subtitle>Inflexible thinking, bad humor</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tianjiec.top/"/>
  <updated>2019-01-09T09:58:49.950Z</updated>
  <id>https://tianjiec.top/</id>
  
  <author>
    <name>chentj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://tianjiec.top/2019/01/09/react_03/"/>
    <id>https://tianjiec.top/2019/01/09/react_03/</id>
    <published>2019-01-09T13:09:01.441Z</published>
    <updated>2019-01-09T09:58:49.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React框架学习"><a href="#React框架学习" class="headerlink" title="React框架学习"></a>React框架学习</h1><p>##开发依赖devDependencies与运行依赖dependencies<br>npm自己的文档说dependencies是运行时依赖，devDependencies是开发时的依赖。即devDependencies 下列出的模块，是我们开发时用的，比如 我们安装 js的压缩包gulp-uglify 时，我们采用的是 “npm install –save-dev gulp-uglify ”命令安装，因为我们在发布后用不到它，而只是在我们开发才用到它。<br>dependencies 下的模块，则是我们发布后还需要依赖的模块，譬如像jQuery库或者Angular框架类似的，我们在开发完后后肯定还要依赖它们，否则就运行不了。</p><h3 id="webpack-facebook"><a href="#webpack-facebook" class="headerlink" title="webpack (facebook)"></a>webpack (facebook)</h3><p>前端工程化： npm、cnpm、yarn、bower | grunt 、 gulp 、webpack</p><p>gulp： 基于流的前端自动化构建工具，基于流的任务式的工具</p><p>webpack： 是一款模块化打包工具，webpack是基于配置的，通过配置一些选项来让webpack执行打包任务。</p><p>npm i webpack -g</p><p>npm i webpack-cli -g (4.0+)</p><p>npm i yarn -g    </p><p>webpack在打包的时候，依靠依赖关系图，在打包的时候需要告知webpack两个概念：入口和出口</p><p>一般情况下，我们需要使用webpack.config.js进行配置</p><h5 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h5><p>entry配置项目打包的入口，值可以为单个的字符串执行某一个文件的地址，这个时候该文件就是入口文件，webpack会根据入口文件里各模块间的关系形成依赖关系图，然后根据依赖关系图进行打包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry:&apos;./src/app.js&apos;,</span><br><span class="line">output:&#123;</span><br><span class="line">    path:path.join(__dirname,&apos;build&apos;),</span><br><span class="line">    filename:&apos;app.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是有的时候我们需要的是多入口，我们就写成数组的形式，数组里的每一个字符串地址指向的都是一个独立的入口，webpack会将这些入口的依赖打包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry:[&apos;./src/app.js&apos;,&apos;./src/vendor.js&apos;],</span><br><span class="line">output:&#123;</span><br><span class="line">    path:path.join(__dirname,&apos;build&apos;),</span><br><span class="line">    filename:&apos;[name].js&apos;//不确定名字的时候，这里会打包成main.js</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>刚才的两种entry配置都只会打包出一个js文件，但是在某一个应用中我们可能需要将js根据依赖关系打包成多个js文件，并且在多页面应用中，我们也确实不可能只使用一个js文件，那么我们就可以使用如下的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">entry:&#123;</span><br><span class="line">    app:&apos;./src/app.js&apos;,</span><br><span class="line">    vendor:&apos;./src/vendor.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line">output:&#123;</span><br><span class="line">    path:path.join(__dirname,&apos;build&apos;),</span><br><span class="line">    filename:&apos;[name]_[hash].js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，因为filename里写成名字是[name],所以会根据entry的配置的键名来为打包出的js文件命名，hash是每次打包的一个随机的hash值，可以用来做版本控制</p><h5 id="output"><a href="#output" class="headerlink" title="output"></a>output</h5><p>在这里我们配置打包输出的一些选项</p><p>filename可以确定打包出来的文件的名字，在里面我们可以使用[name],[hash]这样的占位符</p><p>path配置打包出去的文件的路径，需要是绝对路径</p><h5 id="env"><a href="#env" class="headerlink" title="env"></a>env</h5><p>在命令行或者终端中执行 webpack –env hello命令，就相当于在打包的时候传入一个参数为hello</p><p>在webpack.config.js中可以暴露出一个函数，这个函数就可以接收到env参数，当然函数就可以根据env参数来有选择的返回某一个或多个配置对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = (env)=&gt;&#123;</span><br><span class="line">    if(env==&apos;production&apos;)&#123;</span><br><span class="line">        return productionConfig</span><br><span class="line">    &#125;</span><br><span class="line">    return developmentConfig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>–watch 可以让webpack去监听文件的改变。<br>可以在package.json里的scripts中配置一些快捷操作，通过npm run来运行</p><h5 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h5><p>在webpack编译用的是loader，但是有一些loader无法完成的任务，交由插件（plugin）来完成，插件的时候需要在配置项中配置plugins选项，值是数组，可以放入多个插件的使用，而一般的插件都是一个构造器，我们只需在plugins数组中放入该插件的实例即可</p><p>html-webpack-plugin</p><p>这个插件可以选择是否依据模板来生成一个打包好的html文件，在里面可以配置、title、template、filename、minify等选项，详情请查阅<a href="https://segmentfault.com/a/1190000007294861" target="_blank" rel="noopener">文档</a></p><p>plugins:[<br>​    new HtmlWebpackPlugin({<br>​        template:”./src/index.html”,<br>​        minify:{<br>​            collapseWhitespace:true<br>​        }<br>​    })<br>]</p><h4 id="LOADERS"><a href="#LOADERS" class="headerlink" title="LOADERS"></a>LOADERS</h4><p>在webpack中专门有一些东西用来编译文件、处理文件，这些东西就叫loader，loader的使用就是在配置项中，设置module，在module中设置rules值为数组，在数组里放入多个匹配规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;test:/\.css$/,use:&apos;css-loader&apos;&#125;</span><br><span class="line">    ],</span><br><span class="line">    //before</span><br><span class="line">    loaders:[</span><br><span class="line">        &#123;test:/\.css$/,loader:&apos;css-loader&apos;&#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test为此次匹配要匹配的文件正则规则，use代表要使用的loader</p><p>使用url-loader可以将css中引入的图片（背景图）、js中生成的img图片处理一下，生成到打包目录里</p><p>视图html-withimg-loader可以将html中img标签引入的img图片打包到打包目录</p><p>file-loader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:/\.(png|jpe?g|svg|gif)$/,</span><br><span class="line">    // use:&apos;url-loader?limit=1000&amp;name=images/[hash:8].[name].[ext]&apos;</span><br><span class="line">    use:[</span><br><span class="line">        &#123;</span><br><span class="line">            loader:&apos;url-loader&apos;,</span><br><span class="line">            options:&#123;</span><br><span class="line">                limit:1000,</span><br><span class="line">                name:&apos;/static/images/assets/[hash:8].[name].[ext]&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test:/\.html$/,</span><br><span class="line">    use:&apos;html-withimg-loader&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理css:</p><p>cnpm i css-loader style-loader –save-dev</p><p>配置：</p><p>{<br>​    test:/.css$/,<br>​    use:[‘style-loader’,’css-loader’]<br>}</p><p>注意。webpack中loader的使用是从后往前的</p><p>css-loader可以将引入到js中的css代码给抽离出来，style-loader可以将抽离出来的css代码放入到style标签中</p><p>处理sass</p><p>{<br>test:/.scss$/,<br>use:[‘style-loader’,’css-loader’,’sass-loader’]<br>},</p><p>##postcss-loader 兼容前缀<br>//<a href="https://www.cnblogs.com/RoadAspenBK/p/9342850.html" target="_blank" rel="noopener">https://www.cnblogs.com/RoadAspenBK/p/9342850.html</a><br>yarn add postcss-loader  autoprefixer</p><p>//根目录创建postcss.config.js<br>module.exports = {<br>​    plugins:[<br>​        require(“autoprefixer”)<br>​    ]<br>}</p><p>//loader配置<br>use: [‘style-loader’,’css-loader’,{<br>​        loader: ‘postcss-loader’,<br>​        options: {<br>​            config: {<br>​                path: ‘postcss.config.js’  // 这个得在项目根目录创建此文件<br>​            }<br>​        }<br>​        },’sass-loader’]</p><p>//package.json上面添加<br>“browserslist”: [<br>​    “defaults”,<br>​    “not ie &lt; 11”,<br>​    “last 2 versions”,<br>​    “&gt; 1%”,<br>​    “iOS 7”,<br>​    “last 3 iOS versions”<br>  ]</p><p>将引入项目的css文件、scss文件抽成一个文件，引入到页面中</p><p>因为ExtractTextWebpackPlugin对webpack4支持的不是很好，所以我们这样解决：</p><p>cnpm i extract-text-webpack-plugin@next -D<br>yarn add extract-text-webpack-plugin@next -D</p><p>@next下载的就是最新的版本，可能是开发版本   3.x的版本过时了<br>“extract-text-webpack-plugin”: “^4.0.0-beta.0”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const ExtractTextWebpackPlugin = require(&apos;extract-text-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">///plugin</span><br><span class="line">new ExtractTextWebpackPlugin(&quot;style.css&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">///loader</span><br><span class="line">&#123;</span><br><span class="line">test:/\.css$/,</span><br><span class="line">use:ExtractTextWebpackPlugin.extract(&#123;</span><br><span class="line">      fallback: &quot;style-loader&quot;,</span><br><span class="line">      use: &quot;css-loader&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">test:/\.scss/,</span><br><span class="line">use:ExtractTextWebpackPlugin.extract(&#123;</span><br><span class="line">      fallback: &quot;style-loader&quot;,</span><br><span class="line">      use: [&quot;css-loader&quot;,&quot;sass-loader&quot;]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const OptimizeCssAssetsPlugin = require(‘optimize-css-assets-webpack-plugin’);//压缩css插件</p><p>//plugins配置<br>new OptimizeCssAssetsPlugin()</p><p>css兼容优化处理：post-css 、autoprefixer</p><p>处理es6：</p><p>需要的依赖：</p><p>“babel”: “^6.23.0”,<br>“babel-core”: “^6.24.1”,<br>“babel-loader”: “^7.0.0”,<br>“babel-preset-es2015”: “^6.24.1”,<br>“babel-preset-react”: “^6.24.1”,</p><p>rules：<br>{<br>​    test:/.js$/,<br>​    exclude: /node_modules/,<br>​    loader:’babel-loader’,<br>​    query: {<br>​        presets: [‘es2015’,’react’]<br>​     }<br>}</p><h5 id="ES6中的react"><a href="#ES6中的react" class="headerlink" title="ES6中的react"></a>ES6中的react</h5><p>1.创建组件：</p><p>使用class来创建组件</p><p>class App extends React.Component {</p><p>}</p><p>2.默认状态的设置</p><p>在es6中不再使用getInitialState来设置默认状态，而是在constructor里面直接给this.state上挂载状态</p><p>class App extends Component {<br>​    constructor(props){<br>​        super(props)<br>​<br>        this.state={<br>            doing:’吃饭’<br>        }<br>    }<br>}</p><ol><li>默认属性的设置</li></ol><p>在es6中，通过给类设置defaultProps属性来设置默认属性</p><p>App.defaultProps = {<br>​    name:’App根组件’<br>}</p><ol><li>做属性传参验证</li></ol><p>import PropTypes from ‘prop-types’;</p><p>App.propTypes = {<br>​    name:PropTypes.string<br>}</p><p>5.钩子函数有变化</p><p>getDefaultProps、getInitialState没有了</p><p>多出了constructor,而这个函数本身是类的构造器，在这里相当于getDefaultProps、getInitialState的结合</p><h5 id="create-react-app-脚手架"><a href="#create-react-app-脚手架" class="headerlink" title="create-react-app 脚手架"></a>create-react-app 脚手架</h5><p>npm install creat-react-app -g</p><p>create-react-app my-app //生成一个react开发模板在my-app目录<br>//生成的过程特别缓慢，可以使用yarn工具来下载，也就是说先去下载安装yarn   ：npm install yarn -g</p><p>当我们要进行二次配置的时候，需要找到node_modules文件夹里的react-scripts进行配置，但是当我们执行npm run eject就可以将配置文件抽出，方便开发配置</p><h5 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h5><p>当我们使用某些组件的时候，发现，该组件不需要拥有自己的状态，只需要接收到外界传入的属性之后做出相应的反应即可</p><p>这样的话，我们可以利用纯函数的方式将其制作成无状态组件，提高性能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">const Button = (props)=&gt;&#123;</span><br><span class="line">return &lt;button onClick=&#123;props.handler&#125;&gt;我要花钱&lt;/button&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Button</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React框架学习&quot;&gt;&lt;a href=&quot;#React框架学习&quot; class=&quot;headerlink&quot; title=&quot;React框架学习&quot;&gt;&lt;/a&gt;React框架学习&lt;/h1&gt;&lt;p&gt;##开发依赖devDependencies与运行依赖dependencies&lt;br&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="https://tianjiec.top/2019/01/09/webpack/"/>
    <id>https://tianjiec.top/2019/01/09/webpack/</id>
    <published>2019-01-09T08:55:22.000Z</published>
    <updated>2019-01-09T10:00:09.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React框架学习"><a href="#React框架学习" class="headerlink" title="React框架学习"></a>React框架学习</h1><h3 id="开发依赖devDependenvies与运行依赖dependencies"><a href="#开发依赖devDependenvies与运行依赖dependencies" class="headerlink" title="开发依赖devDependenvies与运行依赖dependencies"></a>开发依赖devDependenvies与运行依赖dependencies</h3><blockquote><p>npm自己的文档说dependencies是运行时依赖，devDependencies是开发时的依赖。即devDependencies 下列出的模块，是我们开发时用的，比如 我们安装 js的压缩包gulp-uglify 时，我们采用的是 “npm install –save-dev gulp-uglify ”命令安装，因为我们在发布后用不到它，而只是在我们开发才用到它。<br>dependencies 下的模块，则是我们发布后还需要依赖的模块，譬如像jQuery库或者Angular框架类似的，我们在开发完后后肯定还要依赖它们，否则就运行不了。</p></blockquote><h3 id="webpack（facebook）"><a href="#webpack（facebook）" class="headerlink" title="webpack（facebook）"></a>webpack（facebook）</h3><p>前端工程化：包管理器：npm、cnpm、yarn、bower | 构建工具：grunt、gulp、webpack</p><p>gulp： 基于流的前端自动化构建工具，基于流的任务式的工具</p><p>webpack： 是一款模块化打包工具，webpack是基于配置的，通过配置一些选项来让webpack执行打包任务。npm i webpack -g</p><p>npm i webpack-cli -g (4.0+)</p><p>npm i yarn -g    </p><p>webpack在打包的时候，依靠依赖关系图，在打包的时候需要告知webpack两个概念：入口和出口</p><p>一般情况下，我们需要使用webpack.config.js进行配置</p><h4 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h4><p>entry配置项目打包的入口，值可以为单个的字符串执行某一个文件的地址，这个时候该文件就是入口文件，webpack会根据入口文件里各个模块之间的关系形成依赖关系图，然后根据依赖关系图打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry:&apos;./src/app.js&apos;,</span><br><span class="line">output:&#123;</span><br><span class="line">    path:path.join(__dirname,&apos;build&apos;);</span><br><span class="line">    filename:&apos;app.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有的时候我么需要的是多入口，我们就需要写成数组的形式，数组里的每一个字符串地址指向的都是一个独立的入口，webpack会将这些入口依赖打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry:[&apos;./src/app.js&apos;,&apos;./src/vendor.js&apos;],</span><br><span class="line">output:&#123;</span><br><span class="line">    path:path.join(__dirname,&apos;build&apos;),</span><br><span class="line">    filename:&apos;[name]&apos;.js//不确定名字的时候，这里会打包成main.js</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，因为filename里写成名字是[name],所以会根据entry的配置的键名来为打包出的js文件命名，has是每次打包的一个随机的hash值，可以用来做版本控制</p><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><p>在这里我们配置打包输出的一些选项</p><p>filename可以确定打包出来的文件的名字，在我们里面可以使用[name],[hash]这样的占位符</p><p>path配置打包出去的文件路径，需要是绝对路径。</p><h4 id="env"><a href="#env" class="headerlink" title="env"></a>env</h4><p>在命令行或者终端中执行 wbpack –env hello命令，就相当于在打包的时候传入一个参数为 hello</p><p>在webpack.config.js中可以暴露出一个函数，这个函数就可以接收到env参数，当然函数就可以根据env参数来有选择的返回某一个或多个配置对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = (env)=&gt;&#123;</span><br><span class="line">    if(env==&apos;production&apos;)&#123;</span><br><span class="line">        return productionConfig</span><br><span class="line">    &#125;</span><br><span class="line">    return developmentConfig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>–watch 可以让webpack去监听文件的改变。<br>可以在package.json里的scripts中配置一些快捷操作，通过npm run来运行</p><h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><p>在webpack编译用的是loader,但是有一些loader无法完成的任务，交由插件（plugin）来完成 插件的时候需要在配置项中配置plugins选项，值是数组，可以放入多个插件的使用，而一般的插件都是一个构造器，我们只需要在plugins数组中放入该插件的实例即可。</p><h4 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h4><p>这个插件可以选择是否依据模板来生成一个打包好的html文件，在里面可以配置、title、template、filename、minify等选项，详情请查阅<a href="https://segmentfault.com/a/1190000007294861" target="_blank" rel="noopener">文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">template:&apos;./src/index.html&apos;,</span><br><span class="line">        minify:&#123;</span><br><span class="line">            collapseWhitespace:true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="LOADERS"><a href="#LOADERS" class="headerlink" title="LOADERS"></a>LOADERS</h4><p>在webpack中专门有一些东西用来编译文件、处理文件，这些东西就叫loader，loader的使用就是在配置项中，设置module，在module中设置rules值为数组，在数组里放入多个匹配规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;test:/\.css$/,use:&apos;css-loader&apos;&#125;</span><br><span class="line">    ],</span><br><span class="line">    //before</span><br><span class="line">        loaders:[</span><br><span class="line">            &#123;test:/\.css$/,loader:&apos;css-loader&apos;&#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test为此次匹配要匹配的文件正则规则，use代表要使用的loader</p><p>使用url-loader可以将css中引入的图片（背景图）、js中生成的img图片处理一下，生成到打包目录里</p><p>视图html-withimg-loader可以将html中img标签引入的img图片打包到打包目录</p><p>file-loader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:/\.(png|jpe?g|svg|gif)$/,</span><br><span class="line">    // use:&apos;url-loader?limit=1000&amp;name=images/[hash:8].[name].[ext]&apos;</span><br><span class="line">    use:[</span><br><span class="line">        &#123;</span><br><span class="line">            loader:&apos;url-loader&apos;,</span><br><span class="line">            options:&#123;</span><br><span class="line">                limit:1000,</span><br><span class="line">                name:&apos;/static/images/assets/[hash:8].[name].[ext]&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test:/\.html$/,</span><br><span class="line">    use:&apos;html-withimg-loader&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理css:</p><p>cnpm i css-loader style-loader –save-dev</p><p>配置：</p><p>{<br>​    test:/.css$/,<br>​    use:[‘style-loader’,’css-loader’]<br>}</p><p>注意。webpack中loader的使用是从后往前的</p><p>css-loader可以将引入到js中的css代码给抽离出来，style-loader可以将抽离出来的css代码放入到style标签中</p><p>处理sass</p><p>{<br>test:/.scss$/,<br>use:[‘style-loader’,’css-loader’,’sass-loader’]<br>},</p><h2 id="postcss-loader兼容前缀"><a href="#postcss-loader兼容前缀" class="headerlink" title="postcss-loader兼容前缀"></a>postcss-loader兼容前缀</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React框架学习&quot;&gt;&lt;a href=&quot;#React框架学习&quot; class=&quot;headerlink&quot; title=&quot;React框架学习&quot;&gt;&lt;/a&gt;React框架学习&lt;/h1&gt;&lt;h3 id=&quot;开发依赖devDependenvies与运行依赖dependencies&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianjiec.top/2019/01/08/react_02/"/>
    <id>https://tianjiec.top/2019/01/08/react_02/</id>
    <published>2019-01-08T09:33:42.410Z</published>
    <updated>2019-01-08T03:03:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React框架学习"><a href="#React框架学习" class="headerlink" title="React框架学习"></a>React框架学习</h1><h5 id="React中的事件对象"><a href="#React中的事件对象" class="headerlink" title="React中的事件对象"></a>React中的事件对象</h5><p>react中对于事件进行了处理，解决了一些兼容性问题，react事件对象上面挂载着nativeEvent，这个就是原生的事件对象</p><p>react对事件对象做了优化，如果不取值的话，值都是null</p><h5 id="React中组件通信方式"><a href="#React中组件通信方式" class="headerlink" title="React中组件通信方式"></a>React中组件通信方式</h5><p>父组件与子组件通信</p><ol><li><p>父组件将自己的状态传递给子组件，子组件当做属性来接收，当父组件更改自己状态的时候，子组件接收到的属性就会发生改变</p></li><li><p>父组件利用ref对子组件做标记，通过调用子组件的方法以更改子组件的状态..</p></li></ol><p>子组件与父组件通信</p><p>父组件将自己的某个方法传递给子组件，在方法里可以做任意操作，比如可以更改状态，子组件通过this.props接收到父组件的方法后调用。</p><p>兄弟组件通信</p><p>在react没有类似vue中的事件总线来解决这个问题，我们只能借助它们共同的父级组件来实现，将非父子关系装换成多维度的父子关系</p><p>复杂的非父子组件通信在react中很难处理，多组件间的数据共享也不好处理，所以我们会使用flux、redux来实现这样的功能，解决这个问题</p><h5 id="React中表单元素默认值"><a href="#React中表单元素默认值" class="headerlink" title="React中表单元素默认值"></a>React中表单元素默认值</h5><p>在react中，如果需要 给表单元素设置默认value或者checked，需要设置成defaultValue/defaultChecked，否则设置默认值以后，用户无法更改</p><h5 id="React-keys"><a href="#React-keys" class="headerlink" title="React-keys"></a>React-keys</h5><p>我们在react中循环列表数据的时候，需要对循环出来的虚拟jsx节点传入上key这个数据，</p><p>Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。</p><h5 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h5><p>就是如果有多个组件共享一个数据，把这个数据放到共同的父级组件中来管理</p><h5 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h5><p>在vue中有一个内容分发叫slot，在react中也有实现，就是可以在使用组件的时候，在组件标签内部放入一些不固定的内容，在该组件的模板中，只有{this.props.children}来表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//App</span><br><span class="line">&lt;Dialog</span><br><span class="line">close=&#123;this.ToggleDialogShow&#125; isShow=&#123;isDialogShow&#125;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;ContentA/&gt;</span><br><span class="line">    &lt;ContentA/&gt;</span><br><span class="line">    &lt;ContentB/&gt;</span><br><span class="line">&lt;/Dialog&gt;</span><br><span class="line"></span><br><span class="line">//dialog</span><br><span class="line">&lt;div style=&#123;&#123;display:isShow?&apos;block&apos;:&apos;none&apos;&#125;&#125; className=&quot;dialog&quot;&gt;</span><br><span class="line">    &lt;Button handler=&#123;this.props.close&#125; text=&quot;关闭&quot;/&gt;   </span><br><span class="line">    &#123;this.props.children&#125;//这里就是slot</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React框架学习&quot;&gt;&lt;a href=&quot;#React框架学习&quot; class=&quot;headerlink&quot; title=&quot;React框架学习&quot;&gt;&lt;/a&gt;React框架学习&lt;/h1&gt;&lt;h5 id=&quot;React中的事件对象&quot;&gt;&lt;a href=&quot;#React中的事件对象&quot; c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianjiec.top/2019/01/08/react_01/"/>
    <id>https://tianjiec.top/2019/01/08/react_01/</id>
    <published>2019-01-08T09:33:42.381Z</published>
    <updated>2019-01-07T01:33:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React框架学习"><a href="#React框架学习" class="headerlink" title="React框架学习"></a>React框架学习</h1><h3 id="React的起源和发展"><a href="#React的起源和发展" class="headerlink" title="React的起源和发展"></a>React的起源和发展</h3><pre><code>起初facebook在建设instagram（图片分享）的时候嘞，因为牵扯到一个东西叫数据流，那为了处理数据流并且还要考虑好性能方面的问题嘞，Facebook开始对市场上的各种前端MVC框架去进行一个研究，然而并没有看上眼的，于是Facebook觉得，还是自己开发一个才是最棒的，那么他们决定抛开很多所谓的“最佳实践”，重新思考前端界面的构建方式，他们就自己开发了一套，果然大牛创造力还是很强大的。</code></pre><h3 id="React的出发点"><a href="#React的出发点" class="headerlink" title="React的出发点"></a>React的出发点</h3><pre><code>基于HTML的前端界面开发正变得越来越复杂，其本质问题基本都可以归结于如何将来自于服务器端或者用户输入的动态数据高效的反映到复杂的用户界面上。而来自Facebook的React框架正是完全面向此问题的一个解决方案，按官网描述，其出发点为：用于开发数据不断变化的大型应用程序（Building large applications with data that changes over time）。相比传统型的前端开发，React开辟了一个相当另类的途径，实现了前端界面的高性能高效率开发。</code></pre><h3 id="React与传统MVC的关系"><a href="#React与传统MVC的关系" class="headerlink" title="React与传统MVC的关系"></a>React与传统MVC的关系</h3><pre><code>轻量级的视图层框架！React不是一个完整的MVC框架，最多可以认为是MVC中的V（View），甚至React并不非常认可MVC开发模式；</code></pre><h3 id="React高性能的体现：虚拟DOM"><a href="#React高性能的体现：虚拟DOM" class="headerlink" title="React高性能的体现：虚拟DOM"></a>React高性能的体现：虚拟DOM</h3><p>React高性能的原理：</p><p>在Web开发中我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而复杂或频繁的DOM操作通常是性能瓶颈产生的原因（如何进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标）。</p><p>React为此引入了虚拟DOM（Virtual DOM）的机制：在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。而且React能够批处理虚拟DOM的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从A-B,B-A，React会认为A变成B，然后又从B变成A  UI不发生任何变化，而如果通过手动控制，这种逻辑通常是极其复杂的。</p><p>尽管每一次都需要构造完整的虚拟DOM树，但是因为虚拟DOM是内存数据，性能是极高的，部而对实际DOM进行操作的仅仅是Diff分，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体的DOM元素，而只需要关心在任意一个数据状态下，整个界面是如何Render的。数据驱动，声明式</p><h3 id="React的特点和优势"><a href="#React的特点和优势" class="headerlink" title="React的特点和优势"></a>React的特点和优势</h3><ol><li>虚拟DOM</li></ol><p>我们以前操作dom的方式是通过document.getElementById()的方式，这样的过程实际上是先去读取html的dom结构，将结构转换成变量，再进行操作</p><p>而reactjs定义了一套变量形式的dom模型，一切操作和换算直接在变量中，这样减少了操作真实dom，性能真实相当的高，和主流MVC框架有本质的区别，并不和dom打交道</p><ol><li>组件系统</li></ol><p>react最核心的思想是将页面中任何一个区域或者元素都可以看做一个组件 component</p><p>那么什么是组件呢？  .vue  template script style lang=”scss” node-sass sass-loader</p><p>组件指的就是同时包含了html、css、js、image元素的聚合体</p><p>使用react开发的核心就是将页面拆分成若干个组件，并且react一个组件中同时耦合了css、js、image，这种模式整个颠覆了过去的传统的方式</p><ol><li>单向数据流  <father><son name=""></son></father>父子通信  vuex state—&gt;component(this.$store.state) —-&gt; actions（{commit}）(this.$store.dispatch()) —-&gt; mutations(this.$store.commit()) —–&gt; state</li></ol><p>其实reactjs的核心内容就是数据绑定，所谓数据绑定指的是只要将一些服务端的数据和前端页面绑定好，开发者只关注实现业务就行了  </p><ol><li>JSX  语法  </li></ol><p>在vue中，我们使用render函数来构建组件的dom结构性能较高，因为省去了查找和编译模板的过程，但是在render中利用createElement创建结构的时候代码可读性较低，较为复杂，此时可以利用jsx语法来在render中创建dom，解决这个问题，但是前提是需要使用工具来编译jsx</p><h3 id="创建第一个组件-15-16"><a href="#创建第一个组件-15-16" class="headerlink" title="创建第一个组件  15.  16"></a>创建第一个组件  15.  16</h3><p>react开发需要引入多个依赖文件：react.js、react-dom.js，分别又有开发版本和生成版本</p><p>在这里一开始，我们先学习es5的组件写法，React.createClass，需要引入的是15+</p><p>react.js中有React对象，帮助我们创建组件等功能</p><p>react-dom.js中有ReactDOM对象，渲染组件的虚拟dom为真实dom的爆发功能</p><p>在编写react代码的时候会大量的使用到jsx代码，但是需要编译：</p><ol><li>浏览器端编译，通过引入browser、babel等对引入的script内的代码做编译</li><li>利用webpack等开发环境进行编译，将编译好的文件引入到应用中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//创建组件</span><br><span class="line">var Hello = React.createClass(&#123;</span><br><span class="line">    render:function () &#123;</span><br><span class="line">        //render函数和Vue组件里的render完全一样，在vue组件中可以不用编写render函数，这个时候可以使用template模板来编写组件的虚拟dom结构，然后vue组件会自动讲模板compile成虚拟dom结构放入到render中执行，但是react需要编写render函数</span><br><span class="line"></span><br><span class="line">        return (</span><br><span class="line">            //jsx语法</span><br><span class="line">            &lt;div&gt;asdasd&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//利用ReactDOM对象的render方法将组件渲染到某个节点里</span><br><span class="line">ReactDOM.render(&lt;Hello/&gt;,document.getElementById(&quot;app&quot;))</span><br></pre></td></tr></table></figure><p>组件是通过React.createClass创建的（ES5），在es6中直接通过class关键字来创建</p><p>组件其实就是一个构造器,每次使用组件都相当于在实例化组件</p><p>react的组件必须使用render函数来创建组件的虚拟dom结构</p><p>组件需要使用ReactDOM.render方法将其挂载在某一个节点上</p><p>组件的首字母必须大写</p><h3 id="JSX语法糖"><a href="#JSX语法糖" class="headerlink" title="JSX语法糖"></a>JSX语法糖</h3><p>JSX是一种语法，全称：javascript xml</p><p>JSX语法不是必须使用的，但是因为使用了JSX语法之后会降低我们的开发难度，故而这样的语法又被成为语法糖</p><p>在不使用JSX的时候，需要使用React.createElement来创建组件的dom结构，但是这样的写法虽然不需要编译，但是维护和开发的难度很高，且可读性很差</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var world = React.createElement(&apos;h1&apos;,&#123;className:&apos;abc&apos;,id:&apos;haha&apos;&#125;,[</span><br><span class="line">    React.createElement(&apos;span&apos;,null,&apos;Hello&apos;),</span><br><span class="line">    React.createElement(&apos;mark&apos;,null,&apos;React&apos;)</span><br><span class="line">])</span><br><span class="line">            </span><br><span class="line">//利用ReactDOM对象的render方法将组件渲染到某个节点里</span><br><span class="line">ReactDOM.render(world,document.getElementById(&quot;app1&quot;))</span><br></pre></td></tr></table></figure><p>及时使用了JSX语法了之后，也是需要将其编译成原生的createElement的</p><p>JSX就是在js中使用的xml，但是，这里的xml不是真正的xml，只能借鉴了一些xml的语法，例如：</p><p>最外层必须有根节点、标签必须闭合</p><p>jsx借鉴xml的语法而不是html的语法原因：xml要比html严谨，编译更方便</p><h3 id="组件dom添加样式"><a href="#组件dom添加样式" class="headerlink" title="组件dom添加样式"></a>组件dom添加样式</h3><p>在react里表达式的符号是 “{  }”,作用和vue的表达式作用是一样的</p><p>想给虚拟dom添加行内样式，需要使用表达式传入样式对象的方式来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style = &#123; &#123;color:&apos;red&apos;,fontSize:2+&apos;em&apos;&#125; &#125;&gt;Hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>行内样式需要写入一个样式对象，而这个样式对象的位置可以放在很多地方，例如React.createClass的配置项中、render函数里、组件原型上、外链js文件中</p><p>React推荐我们使用行内样式，因为react觉得每一个组件都是一个独立的整体</p><p>其实我们大多数情况下还是大量的在为元素添加类名、id以使用某些样式，但是需要注意的是，class需要写成className（因为毕竟是在写类js代码，会收到js规则的现在，而class是关键字）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p className=&quot;bg-p&quot; id=&quot;myp&quot; style = &#123; this.style &#125;&gt;Hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="React-Event"><a href="#React-Event" class="headerlink" title="React Event"></a>React Event</h3><p>在react中，我们想要给组件的dom添加事件的话，也是 需要在行内添加的方式，事件名字需要写成小驼峰的方式，值利用表达式传入一个函数即可</p><p>注意，在没有渲染的时候，页面中没有真实dom，所以是获取不到dom的</p><p>给虚拟dom结构中的节点添加样式。在行内添加,写成驼峰形式，值是一个函数名，需要用{}包裹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">handleClick:function () &#123;</span><br><span class="line">    alert(1)</span><br><span class="line">&#125;,</span><br><span class="line">render:function () &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick = &#123;this.handleClick&#125; className=&quot;click-btn&quot;&gt;click&lt;/button&gt;</span><br><span class="line">            &lt;button onDoubleClick = &#123;this.handleClick&#125; className=&quot;click-btn&quot;&gt;click&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h3><p>将一个组件渲染到某一个节点里的时候，会将这个节点里原有内容覆盖</p><p>组件嵌套的方式就是将子组件写入到父组件的模板中去，且react没有Vue中的内容分发机制（slot），所以我们在一个组件的模板中只能看到父子关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var Hello = React.createClass(&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;h1&gt;</span><br><span class="line">                Hello </span><br><span class="line">                &lt;World&gt;&lt;/World&gt;</span><br><span class="line">            &lt;/h1&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">var World = React.createClass(&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;mark&gt;</span><br><span class="line">                World-&lt;Person/&gt; </span><br><span class="line">            &lt;/mark&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">//无状态组件</span><br><span class="line">var Person =function()&#123;</span><br><span class="line">    return (&lt;mark&gt;lilei&lt;/mark&gt;)</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;Hello/&gt;,app)</span><br></pre></td></tr></table></figure><blockquote><p>注意，react中jsx里的注释要写成{/<em>  </em>/}的方式</p></blockquote><h3 id="React中的数据承载-Props-State"><a href="#React中的数据承载-Props-State" class="headerlink" title="React中的数据承载-Props/State"></a>React中的数据承载-Props/State</h3><p>数据驱动、声明式渲染：</p><p>任意的视图变化都应该由数据来控制</p><p>//$(“.a”).html(0)</p><p>var num = 0<br>function renderNum () { $(“.a”).html(num) }</p><p>React也是基于数据驱动(声明式)的框架，组件中必然需要承载一些数据，在react中起到这个作用的是属性和状态（props &amp; state）</p><ol><li><p>属性（props）  在组件外部传入，或者内部设置，组件内部通过this.props获得</p></li><li><p>状态（state）  在组件内部设置或者更改，组件内部通过this.state获得</p></li></ol><h5 id="属性-props"><a href="#属性-props" class="headerlink" title="属性(props)"></a>属性(props)</h5><p>属性一般是外部传入的，组件内部也可以通过一些方式来初始化的设置，属性不能被组件自己更改</p><p>属性是描述性质、特点的，组件自己不能随意更改</p><p>使组件拥有属性的方式：</p><ol><li>在装载（mount）组件的时候给组件传入</li></ol><p>传入数据的时候，除了字符串类型，其他的都应该包上表达式，但是为了规整，所有的数据传递，最好都包上{}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var Gouzi = React.createClass(&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;我的名字：&#123;this.props.name&#125;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;我的性别：&#123;this.props.sex&#125;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;我的年龄：&#123;this.props.age&#125;&lt;/p&gt;  </span><br><span class="line">                &lt;p&gt;我的父亲是：&#123;this.props.father&#125;&lt;/p&gt;                                              </span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let info = &#123;</span><br><span class="line">    sex:&apos;male&apos;,</span><br><span class="line">    father:&apos;狗爸&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Gouzi &#123;...info&#125; name=&#123;&quot;大狗子&quot;&#125; age=&#123;26&#125;/&gt;,app)</span><br></pre></td></tr></table></figure><ol><li>父组件给子组件传入</li></ol><p>父组件在嵌套子组件的时候为子组件传入，传入的方式和上面的方式一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//父组件的render函数</span><br><span class="line">render()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;父组件：&lt;/p&gt;</span><br><span class="line">            &lt;hr/&gt;</span><br><span class="line">            &lt;Son name=&#123;&apos;大狗子&apos;&#125;/&gt;</span><br><span class="line">            &lt;Son name=&#123;&apos;二狗子&apos;&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>子组件自己设置</li></ol><p>子组件可以通过getDefaultProps来设置默认的属性</p><p>getDefaultProps的值是函数，这个函数会返回一个对象，我们在这里对象里为组件设置默认属性</p><p>这种方式设置的属性优先级低，会被外部传入的属性值所覆盖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getDefaultProps:function () &#123;</span><br><span class="line">    console.log(&apos;getDefaultProps&apos;)</span><br><span class="line">    return &#123;</span><br><span class="line">        name:&apos;狗爸&apos;,</span><br><span class="line">        sonname:&apos;二狗子&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">//render</span><br><span class="line">&lt;p&gt;我是&#123;this.props.sonname&#125;的父亲-&#123;this.props.name&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>根据属性或状态，我们可以在render中的表达式里做一些逻辑判断，可以使用||、三元表达式、子执行函数等等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">getName()&#123;</span><br><span class="line">    return this.props.name || &apos;野狗子&apos;</span><br><span class="line">&#125;,</span><br><span class="line">render:function () &#123;</span><br><span class="line">    let &#123;name&#125; = this.props</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;我是子组件-&#123;this.props.name || &apos;野狗子&apos;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;我是子组件-&#123;this.props.name?this.props.name:&apos;野狗子&apos;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;我是子组件-&#123;this.getName()&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;我是子组件-&#123;(function (obj) &#123;</span><br><span class="line">            return obj.props.name || &apos;野狗子&apos;</span><br><span class="line">        &#125;)(this)&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="状态-state"><a href="#状态-state" class="headerlink" title="状态(state)"></a>状态(state)</h5><p>状态就是组件描述某种显示情况的数据，由组件自己设置和更改，也就是说由组件自己维护，使用状态的目的就是为了在不同的状态下使组件的显示不同(自己管理)</p><p>在组件中只能通过getInitialState的钩子函数来给组件挂载初始状态,在组件内部通过this.state获取</p><p>this.props和this.state是纯js对象,在vue中，$data属性是利用Object.defineProperty处理过的，更改$data的数据的时候会触发数据的getter和setter，但是react中没有做这样的处理，如果直接更改的话，react是无法得知的，所以，需要使用特殊的更改状态的方法：</p><p>setState(params)</p><p>在setState中传入一个对象，就会将组件的状态中键值对的部分更改，还可以传入一个函数，这个回调函数必须返回像上面方式一样的一个对象，函数可以接收prevState和props</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//1.</span><br><span class="line">let doing = this.state.doing==&apos;学习&apos;+props.knowledge?&apos;玩游戏&apos;:&apos;学习&apos;+props.knowledge</span><br><span class="line">this.setState(&#123;doing&#125;)</span><br><span class="line"></span><br><span class="line">//2.</span><br><span class="line">this.setState((prevState,props)=&gt;&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        doing:prevState.doing==&apos;学习&apos;+props.knowledge?&apos;玩游戏&apos;:&apos;学习&apos;+props.knowledge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="实现下拉菜单的方式"><a href="#实现下拉菜单的方式" class="headerlink" title="实现下拉菜单的方式"></a>实现下拉菜单的方式</h5><ol><li>通过数据来控制元素的行内样式中display的值，或者去控制类名</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul style=&#123;&#123;display:isMenuShow?&apos;block&apos;:&apos;none&apos;&#125;&#125;&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;</span><br><span class="line">...</span><br><span class="line">&lt;ul className=&#123;isMenuShow?&apos;show&apos;:&apos;hide&apos;&#125;&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;</span><br></pre></td></tr></table></figure><ol><li><p>根据数据控制是否渲染改节点、组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    isMenuShow?&lt;ul&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;:&apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过ref对dom、组件进行标记，在组件内部通过this.refs获取到之后，进行操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul ref=&apos;content&apos;&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;</span><br><span class="line">...</span><br><span class="line">this.refs.content.style.display = this.state.isMenuShow?&apos;block&apos;:&apos;none&apos;</span><br></pre></td></tr></table></figure></li></ol><h5 id="属性和状态的对比"><a href="#属性和状态的对比" class="headerlink" title="属性和状态的对比"></a>属性和状态的对比</h5><p>相似点：都是纯js对象，都会触发render更新，都具有确定性（状态/属性相同，结果相同）</p><p>不同点： </p><ol><li>属性能从父组件获取，状态不能</li><li>属性可以由父组件修改，状态不能</li><li>属性能在内部设置默认值 ，状态也可以</li><li>属性不在组件内部修改   ，状态要改</li></ol><p>状态只和自己相关，由自己维护</p><p>属性不要自己修改，可以从父组件获取，也可以给子组件设置</p><p>组件在运行时自己需要修改的数据其实就是状态而已</p><h4 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h4><p>react中组件也有生命周期，也就是说也有很多钩子函数供我们使用，下面是生命周期的图示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./life.jpg" alt="生命周期" title="">                </div>                <div class="image-caption">生命周期</div>            </figure><p>组件是一个构造器，每一次使用组件都相当于在实例化组件，在这个时候，组件就会经历一次生命周期，从实例化实例开始到这个实例销毁的时候，都是一次完整的生命周期</p><p>组件的生命周期，我们会分为三个阶段，初始化、运行中、销毁</p><h5 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h5><ol><li><p>实例化组件之后，组件的getDefaultProps钩子函数会执行</p><p> 这个钩子函数的目的是为组件的实例挂载默认的属性</p><p> 这个钩子函数只会执行一次，也就是说，只在第一次实例化的时候执行，创建出所有实例共享的默认属性，后面再实例化的时候，不会执行getDefaultProps，直接使用已有的共享的默认属性</p><p> 理论上来说，写成函数返回对象的方式，是为了防止实例共享，但是react专门为了让实例共享，只能让这个函数只执行一次</p><p> 组件间共享默认属性会减少内存空间的浪费，而且也不需要担心某一个实例更改属性后其他的实例也会更改的问题，因为组件不能自己更改属性，而且默认属性的优先级低。</p></li><li><p>执行getInitialState为实例挂载初始状态，且每次实例化都会执行，也就是说，每一个组件实例都拥有自己独立的状态呢</p></li><li><p>执行componentWillMount，相当于Vue里的created+beforeMount，这里是在渲染之前最后一次更改数据的机会，在这里更改的话是不会触发render的重新执行</p><p> 多做一些初始数据的获取</p></li><li><p>执行render，渲染dom</p></li><li><p>执行componentDidMount ，相当于Vue里的mounted,多用于操作真实dom</p></li></ol><h5 id="运行中阶段"><a href="#运行中阶段" class="headerlink" title="运行中阶段"></a>运行中阶段</h5><p>当组件mount到页面中之后，就进入了运行中阶段，在这里有5个钩子函数，但是这5个函数只有在数据（属性、状态）发送改变的时候才会执行</p><ol><li>componentWillReceiveProps</li></ol><p>当父组件给子组件传入的属性改变的时候，子组件的这个函数才会执行</p><p>当执行的时候，函数接收的参数是子组件接收到的新参数，这个时候，新参数还没有同步到this.props上,多用于判断新属性和原有属性的变化后更改组件的状态</p><ol><li><p>接下来就会执行shouldComponentUpdate,这个函数的作用：</p><p> 当属性或状态发生改变后控制组件是否要更新，提高性能,返回true就更新，否则不更新，默认返回true</p><p> 接收nextProp、nextState，根据根据新属性状态和原属性状态作出对比、判断后控制是否更新</p></li><li><p>componentWillUpdate,在这里，组件马上就要重新render了，多做一些准备工作，千万千万，不要在这里修改状态，否则会死循环<br> 相当于Vue中的beforeUpdate</p></li><li><p>render，重新渲染dom</p></li><li><p>componentDidUpdate，在这里，新的dom结构已经诞生了,相当于Vue里的updated</p></li></ol><h5 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h5><p>当组件被销毁之前的一刹那，会触发componentWillUnmount，临死前的挣扎</p><p>相当于Vue里的beforeDestroy，所以说一般会做一些擦屁股的事情</p><p>为什么Vue中有destroyed，而react却没有componentDidUnmount</p><p>Vue在调用$destroy方法的时候就会执行beforeDestroy，然后组件被销毁，这个时候组件的dom结构还存在于页面结构中，也就说如果想要对残留的dom结构进行处理必须在destroyed处理，但是react执行完componentWillUnmount之后把事件、数据、dom都全部处理掉了，所以根本不需要其他的钩子函数了</p><p>怎么样就算组件被销毁：</p><ol><li><p>当父组件从渲染这个子组件变成不渲染这个子组件的时候，子组件相当于被销毁</p></li><li><p>调用ReactDOM.unmountComponentAtNode(node) 方法来将某节点中的组件销毁</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React框架学习&quot;&gt;&lt;a href=&quot;#React框架学习&quot; class=&quot;headerlink&quot; title=&quot;React框架学习&quot;&gt;&lt;/a&gt;React框架学习&lt;/h1&gt;&lt;h3 id=&quot;React的起源和发展&quot;&gt;&lt;a href=&quot;#React的起源和发展&quot; c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vuex</title>
    <link href="https://tianjiec.top/2019/01/08/vuex/"/>
    <id>https://tianjiec.top/2019/01/08/vuex/</id>
    <published>2019-01-08T09:18:59.000Z</published>
    <updated>2019-01-08T09:20:59.079Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>是vue提供的一个全局的状态管理工具，主要处理项目中多组件间状态共享</p><p>当你不知道该不该使用vuex的时候，你就不需要使用vuex</p><p>整个vuex的使用都是从创建store开始的</p><p>store中包含了这样的几个部分：</p><p>state（存储状态的）</p><p>getters （用来派生新状态）</p><p>mutations （负责更改state）</p><p>actions （负责做异步操作）</p><p>在这里以一个购物车的小例子来学习，因为没有后端，所以数据交互只能与localStorage交互了</p><p>路由组件： 列表组件、购物车组件</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li><p>创建一个store</p></li><li><p>将创建好的store注入到根实例里,目的就是在任意组件中都可以使用到$store的api，用以使用vuex</p></li><li><p>创建state交由store来管理</p></li><li><p>在组件中使用state中的数据</p><p>组件可以直接从$store.state中得到vuex管理的状态，但是，不要这么用！</p><p>如果在视图中直接使用$store.state.num，num更改后组件的视图会更改，但是我们一般使用的时候都是在data里挂载，或者说直接this.num去使用，这样的话，当num更改的时候，组件无法得到更新</p><p>所以。vuex规定，我们要利用计算属性来使用vuex中的数据</p><p>其实大部分情况下，我们都会使用mapState这个辅助函数（作用：将vuex中state管理的状态通过计算属性放入到组件中）</p></li><li><p>如果需要从现有的状态派生出一个新的状态，使用getters，例如，已经有了一个num，现在需要再来一个doubleNum</p><p>getters里的数据，在组件中，我们也需要使用计算属性来接收，在这里也可以使用mapGetters的辅助函数，注意，mapGetters的使用方法和mapState一模一样</p></li><li><p>mutations是专门更改state的，也就是说，想要改state必须通过mutations才能改<br>mutations里有很多方法，方法被调用的时候，更改state，而且，注意一定要很谨慎的使用mutations，所以，建议大家，给mutations挂载方法的时候，方法名字使用常量</p><p>在组件中通过this.$store.commit(methodname,params)</p><p>使用mapMutations辅助函数可以将mutations中的方法与组件的方法耦合起来，使用方法与mapState、mapGetters一样，只是要放入在methods</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意，要让mutations纯粹！！！！。里面只有数据的更改，没有其他的逻辑代码</span><br></pre></td></tr></table></figure><ol><li><p>当我们想要像后端发送请求，根据结果再来更改state，这个时候，注意，不能把获取数据的异步逻辑写在mutations，也不要写在组件里，不方便维护和复用，所以，需要把他们写在actions，也就是说，vuex中的actions专门负责异步操作</p><p>actions里面有很多方法，这些方法里面可以进行异步操作</p></li></ol><p>// vuex的模块处理</p><p>在vuex中，我们可以配置一些模块，在每一个模块中都去创建自己的state、mutations、actions、getters，这样的话，每一个部分，或者说每一个开发者，去管理自己的一个模块，方便于维护</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分开模块之后，注意，state中的数据在组件中使用的时候需要this.$store.statea.modulenme.num</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vuex&quot;&gt;&lt;a href=&quot;#Vuex&quot; class=&quot;headerlink&quot; title=&quot;Vuex&quot;&gt;&lt;/a&gt;Vuex&lt;/h3&gt;&lt;p&gt;是vue提供的一个全局的状态管理工具，主要处理项目中多组件间状态共享&lt;/p&gt;
&lt;p&gt;当你不知道该不该使用vuex的时候，你就
      
    
    </summary>
    
    
      <category term="vue学习" scheme="https://tianjiec.top/tags/vue%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vue学习6</title>
    <link href="https://tianjiec.top/2019/01/08/vue%E5%AD%A6%E4%B9%A06/"/>
    <id>https://tianjiec.top/2019/01/08/vue学习6/</id>
    <published>2019-01-08T09:18:41.000Z</published>
    <updated>2019-01-08T09:19:47.368Z</updated>
    
    <content type="html"><![CDATA[<h5 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h5><p>每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cn.vuejs.org/images/lifecycle.png" alt="生命周期图示" title="">                </div>                <div class="image-caption">生命周期图示</div>            </figure><ol><li>实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候，数据还没有挂载ね，只是一个空壳，无法访问到数据和真实的dom，一般不做操作</li><li>挂载数据，绑定事件等等，然后执行created函数，这个时候已经可以使用到数据，也可以更改数据,在这里同步更改数据不会触发updated函数，一般可以在这里做初始数据的获取</li><li>接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</li><li>接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情…</li><li>当组件或实例的数据更改之后，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿</li><li>当更新完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的dom</li><li>当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等</li><li>组件的数据绑定、监听…去掉后只剩下dom空壳，这个时候，执行destroyed，在这里做善后工作也可以</li></ol><p>//0-20k的小图片（图标等），可以放在src/assets文件夹中，让其转成base64<br>//base64是不需要http请求，<br>//虽然页面体积变大了，但是比请求的时间要短！ </p><p>//如果是大于20k的图片，导致页面体积太大，就没有必要转base64<br>// img src=”/static/…”</p><h5 id="vue-cli脚手架"><a href="#vue-cli脚手架" class="headerlink" title="vue-cli脚手架"></a>vue-cli脚手架</h5><p>现在使用前端工程化开发项目是主流的趋势，也就是说，我们需要使用一些工具来搭建vue的开发环境，一般情况下我们使用webpack来搭建，在这里我们直接使用vue官方提供的，基于webpack的脚手架工具：vue-cli</p><p>安装方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装 vue-cli</span><br><span class="line">cnpm install -g vue-cli</span><br><span class="line">cnpm install -g webpack</span><br><span class="line"></span><br><span class="line">cnpm install -g yarn</span><br><span class="line"></span><br><span class="line"># 创建一个基于 webpack 模板的新项目</span><br><span class="line">vue init webpack my-project</span><br><span class="line"></span><br><span class="line">n</span><br><span class="line"></span><br><span class="line"># 安装依赖，走你</span><br><span class="line">cd my-project</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>模板类型：<br>webpack 在配置的时候可以选择是否需要vue-router</p><p>注意的是，模板创建的时候会询问使用需要使用ESLINT来标准化我们的代码</p><p>在脚手架中，开发目录是src文件夹，build负责打包的，config是负责配置（内置服务器的端口、proxy代理），static是静态目录，test是测试</p><p>src中main.js是入口文件，在里面创建了一个根实例，根实例的模板就是根组件App的模板，其他的组件都在根组件里面进行嵌套实现。</p><p>每一个组件都是一个单文件组件，这种文件会被webpack利用vue-loader的工具进行编译</p><p>template部分负责写组件的模板内容，script中创建组件。style里写组件的样式</p><p>assets目录也是静态目录，在这个目标中的文件我们使用相对路径引入,而static目录中的文件使用绝对地址来引入</p><p>在style上添加scoped能使这个style里的样式只作用于当前的组件，不加scoped就是全局样式</p><p>习惯于在App.vue根组件的style里写全局样式，而每个组件的style最好都是局部的</p><p>配置sass编译环境</p><ol><li>下载对应工具：node-sass(4.0.0) sass-loader</li><li>在需要使用scss代码的组件的style标签中添加 lang=’scss’</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;组件的生命周期&quot;&gt;&lt;a href=&quot;#组件的生命周期&quot; class=&quot;headerlink&quot; title=&quot;组件的生命周期&quot;&gt;&lt;/a&gt;组件的生命周期&lt;/h5&gt;&lt;p&gt;每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
    
      <category term="vue学习" scheme="https://tianjiec.top/tags/vue%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vue学习5</title>
    <link href="https://tianjiec.top/2019/01/08/vue%E5%AD%A6%E4%B9%A05/"/>
    <id>https://tianjiec.top/2019/01/08/vue学习5/</id>
    <published>2019-01-08T09:18:36.000Z</published>
    <updated>2019-01-08T09:19:18.531Z</updated>
    
    <content type="html"><![CDATA[<h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><p>vue中可以设置filter(过滤器)来实现数据格式化，双花括号插值和 v-bind 表达式中使用</p><p>vue1.0的有默认的过滤器，但是在2.0的时候全部给去掉了</p><p>所以在vue中如果想要使用过滤器就需要自定义</p><p>自定义的方法有两种：全局定义和局部定义，全局定义的过滤器在任意的实例、组件中都可以使用，局部定义就是在实例、组件中定义，只能在这个实例或组件中使用</p><ol><li><p>全局定义</p><p>Vue.filter(name,handler)</p><p>name是过滤器的名字，handler是数据格式化处理函数，接收的第一个参数就是要处理的数据，返回什么数据，格式化的结果就是什么</p><p>在模板中通过 | (管道符) 来使用,在过滤器名字后面加（）来传参，参数会在handler函数中第二个及后面的形参来接收</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123;msg | firstUpper(3,2)&#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">Vue.filter(&apos;firstUpper&apos;,function (value,num=1,num2) &#123;</span><br><span class="line">    console.log(num2)</span><br><span class="line">    return value.substr(0,num).toUpperCase()+value.substr(num).toLowerCase()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li><p>局部定义</p><p>在实例、组件的配置项中设置 filters，键名为过滤器名，值为handler</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filters:&#123;</span><br><span class="line">    firstUpper:function (value,num=1,num2) &#123;</span><br><span class="line">    console.log(num2)</span><br><span class="line">    return value.substr(0,num).toUpperCase()+value.substr(num).toLowerCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h5><p>在Vue中可以使用v-if来控制模板里元素的显示和隐藏，值为true就显示，为false就隐藏</p><p>v-if控制的是是否渲染这个节点</p><p>当我们需要控制一组元素显示隐藏的时候，可以用template标签将其包裹，将指令设置在template上，等等vm渲染这一组元素的时候，不会渲染template</p><p>当有else分支逻辑的时候，可以给该元素加上v-else指令来控制，v-else会根据上面的那个v-if来控制，效果与v-if相反，注意，一定要紧挨着</p><p>还有v-else-if指令可以实现多分支逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;mode&quot;&gt;  </span><br><span class="line">  &lt;template  v-if=&quot;mode==&apos;A&apos;&quot;&gt;</span><br><span class="line">    &lt;h1&gt;1.title&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;我的第一个P标签&lt;/p&gt;  </span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"> &lt;template  v-else-if=&quot;mode==&apos;B&apos;&quot;&gt;</span><br><span class="line">    &lt;h1&gt;2.title&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;我的第二个P标签&lt;/p&gt;</span><br><span class="line"> &lt;/template&gt;</span><br><span class="line"> &lt;template  v-else-if=&quot;mode==&apos;C&apos;&quot;&gt;</span><br><span class="line">    &lt;h1&gt;3.title&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;我的第三个P标签&lt;/p&gt;</span><br><span class="line"> &lt;/template&gt;</span><br><span class="line"> &lt;template  v-else&gt;</span><br><span class="line">   </span><br><span class="line">    &lt;p&gt;不好意思，输入有误&lt;/p&gt;</span><br><span class="line"> &lt;/template&gt;</span><br></pre></td></tr></table></figure><p>需要注意的另一个地方是：Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这样确实能使Vue变得更快，性能更高，但是有的时候我们需要让实例去更新dom而不是复用，就需要给dom加上不同的key属性，因为vue在判断到底渲染什么的时候，包括哪些dom可以复用，都会参考key值，如果dom表现基本一致，符合复用的条件，但是key值不同，依然不会复用</p><p>Vue还提供了v-show指令，用法和v-if基本一样，控制的是元素的css中display属性，从而控制元素的显示和隐藏 ， 不能和v-else配合使用,且不能使用在template标签上，因为template不会渲染，再更改它的css属性也不会渲染，不会生效</p><h6 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h6><p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。<br>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p><h5 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h5><p>频繁且复杂的dom操作通常是前端性能瓶颈的产生点，Vue提供了虚拟dom的解决办法</p><p>虚拟的DOM的核心思想是：对复杂的文档DOM结构，提供一种方便的工具，进行最小化地DOM操作。这句话，也许过于抽象，却基本概况了虚拟DOM的设计思想</p><p>(1) 提供一种方便的工具，使得开发效率得到保证<br>(2) 保证最小化的DOM操作，使得执行效率得到保证</p><p>也就是说，虚拟dom的框架/工具都是这么做的：</p><ol><li>根据现有的虚拟dom来渲染真实dom树结构</li><li>当数据变化，或者说是页面需要重新渲染的时候，会重新生成一个新的完整的虚拟dom</li><li>拿新的虚拟dom来和旧的虚拟dom做对比（使用diff算法），。得到需要更新的地方之后，更新内容</li></ol><p>这样的话，就能大量减少真实dom的操作,提高性能</p><h5 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h5><p>模块化就是将系统功能分离成独立的功能部分的方法，一般指的是单个的某一种东西，例如js、css</p><p>而组件化针对的是页面中的整个完整的功能模块划分，组件是一个html、css、js、image等外链资源，这些部分组成的一个聚合体</p><p>优点：代码复用，便于维护</p><p>划分组件的原则：复用率高的，独立性强的</p><p>组件应该拥有的特性：可组合，可重用，可测试，可维护</p><h5 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h5><p> <hello></hello>   Vue.component(“hello”,{template:””})</p><p>在vue中，我们通过Vue.extend来创建Vue的子类，这个东西其实就是组件</p><p>也就是说Vue实例和组件的实例有差别但是差别不带，因为毕竟一个是父类一个是子类</p><p>一般的应用，会拥有一个根实例，在根实例里面都是一个一个的组件</p><p>因为组件是要嵌入到实例或者父组件里的，也就是说，组件可以互相嵌套，而且，所有的组件最外层必须有一个根实例，所以组件分为：全局组件和局部组件</p><p>全局组件在任意的实例、父级组件中都能使用，局部组件只能在创建自己的父级组件或者实例中使用</p><p>组件通过不同的注册方法成为全局、局部组件</p><p>创建组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.extend(options)</span><br></pre></td></tr></table></figure><p>全局注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var App = Vue.extend(&#123;</span><br><span class="line">    template:&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(&apos;my-app&apos;,App)</span><br></pre></td></tr></table></figure><p>简便写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建组件构造器和注册组件合并一起  </span><br><span class="line"> Vue.component(&apos;hello&apos;,&#123;//Vue会自动的将此对象给Vue.extend</span><br><span class="line">     template:&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>组件通过template来确定自己的模板,template里的模板必须有根节点，标签必须闭合</p><p>组件的属性挂载通过：data方法来返回一个对象作为组件的属性，这样做的目的是为了每一个组件实例都拥有独立的data属性</p><p>局部注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el:&quot;#app&quot;,</span><br><span class="line">    filters:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        &apos;my-app&apos;:App</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简便写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">    &apos;hello&apos;:&#123;</span><br><span class="line">        template:&quot;&lt;h1&gt;asdasdasdasdasdas&lt;/h1&gt;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实例或者组件中注册另一个组件，这个时候，被注册的组件只能在注册它的实例或组件的模板中使用，一个组件可以被多个组件或实例注册</p><h6 id="注意浏览器规则"><a href="#注意浏览器规则" class="headerlink" title="注意浏览器规则"></a>注意浏览器规则</h6><p>因为vue在解析模板的时候会根据某些html的规则，例如，在table里只能放tr,td,th..，如果放入组件不会解析 这个时候我们可以放入tr使用is方式来标识这个tr其实是组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;tr is=&quot;hello&quot;&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h6 id="template"><a href="#template" class="headerlink" title="template"></a>template</h6><p>我们可以在html的某个地方通过template标签来定义组件的模板，在组件的template属性中通过选择器指定对应的template标签内容就可以了,注意，需要给template标签加id来指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=&quot;my-hello&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;hello world&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;hahahah&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">//组件中</span><br><span class="line">Vue.component(&quot;hello&quot;,&#123;</span><br><span class="line">    template:&quot;#my-hello&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">###### is切换</span><br><span class="line"></span><br><span class="line">在实例、组件的模板中的某一个标签上，可以通过is属性来指定为另一个目标的组件，这个时候我们一般会使用component标签来占位、设置is属性来指定目标组件</span><br></pre></td></tr></table></figure><p><button @click="type=type==='aaa'?'bbb':'aaa"></button></p><component :is="type"></component><p>//组件中</p><p>data:{<br>​    type:’aaa’<br>},<br>components:{<br>​    ‘aaa’:{template:”</p><h1>AAAAAAAAAAAAA</h1>“},<br>​    ‘bbb’:{template:”<h1>BBBBBBBBBBBBB</h1>“}<br>}<p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###### 组件嵌套</span><br><span class="line"></span><br><span class="line">应用中划分的组件可能会很多，为了更好的实现代码复用，所以必然会存在组件的嵌套关系</span><br><span class="line"></span><br><span class="line">组件设计初衷就是要配合使用的，最常见的就是形成父子组件的关系：组件 A 在它的模板中使用了组件 B。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### prop 传递数据</span><br><span class="line"></span><br><span class="line">组件实例的作用域是孤立的,父组件不能直接使用子组件的数据，子组件也不能直接使用父组件的数据</span><br><span class="line"></span><br><span class="line">父组件在模板中使用子组件的时候可以给子组件传递数据</span><br></pre></td></tr></table></figure>  <bbb money="2"></bbb><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子组件需要通过props属性来接收后才能使用</span><br></pre></td></tr></table></figure><p>‘bbb’:{<br>​    props:[‘money’]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果父组件传递属性给子组件的时候键名有&apos;-&apos;，子组件接收的时候写成小驼峰的模式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bbb clothes-logo=&apos;amani&apos; clothes-price=&quot;16.58&quot;&gt;&lt;/bbb&gt;</span><br><span class="line">////</span><br><span class="line">props:[&apos;clothesLogo&apos;,&apos;clothesPrice&apos;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">我们可以用 v-bind 来动态地将 prop 绑定到父组件的数据。每当父组件的数据变化时，该变化也会传导给子组件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### 单向数据流</span><br><span class="line"></span><br><span class="line">Prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。</span><br><span class="line"></span><br><span class="line">另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### prop验证</span><br><span class="line"></span><br><span class="line">我们可以为组件的 prop 指定验证规则。如果传入的数据不符合要求，Vue 会发出警告。这对于开发给他人使用的组件非常有用</span><br><span class="line"></span><br><span class="line">验证主要分为：类型验证、必传验证、默认值设置、自定义验证</span><br></pre></td></tr></table></figure><p>props:{<br>​    //类型验证:<br>​    str:String,<br>​    strs:[String,Number],<br>​    //必传验证<br>​    num:{<br>​        type:Number,<br>​        required:true<br>​    },<br>​    //默认数据<br>​    bool:{<br>​        type:Boolean,<br>​        // default:true,<br>​        default:function(){</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">//自定义验证函数</span><br><span class="line">nums:&#123;</span><br><span class="line">    type:Number,</span><br><span class="line">    validator: function (value) &#123;</span><br><span class="line">        return value %2 == 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当父组件传递数据给子组件的时候，子组件不接收，这个数据就会挂载在子组件的模板的根节点上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### slot</span><br><span class="line"></span><br><span class="line">vue里提供了一种将父组件的内容和子组件的模板整合的方法：内容分发，通过slot插槽来实现</span><br><span class="line"></span><br><span class="line">1. 匿名插槽</span><br></pre></td></tr></table></figure><aaa>abc</aaa><p>template:”</p><h1><slot></slot></h1>“<p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在父组件中使用子组件的时候，在子组件标签内部写的内容，在子组件的模板中可以通过&lt;slot&gt;&lt;/slot&gt;来使用</span><br><span class="line"></span><br><span class="line">2. 具名插槽</span><br><span class="line"></span><br><span class="line">父组件在子组件标签内写的多个内容我们可以给其设置slot属性来命名，在子组件的模板通过通过使用带有name属性的slot标签来放置对应的slot，当slot不存在的时候，slot标签内写的内容就出现</span><br></pre></td></tr></table></figure><p><my-button>提交</my-button></p><p><my-button>重置</my-button></p><p><my-button></my-button></p><p>template:”<button><slot>按钮</slot></button>“</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">##### transition</span><br><span class="line"></span><br><span class="line">Vue提供了transition组件来帮助我们实现过渡效果，依据就是在控制元素显示隐藏的时候为dom在指定的时刻添加上对应的类名</span><br><span class="line"></span><br><span class="line">而我们只要在这些类名里写上对应的css样式</span><br><span class="line"></span><br><span class="line">在进入/离开的过渡中，会有 6 个 class 切换(v代表的是transition的name属性的值)。</span><br><span class="line"></span><br><span class="line">v-enter：定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。</span><br><span class="line"></span><br><span class="line">v-enter-active：定义过渡的状态。在元素整个过渡过程中作用，在元素被插入时生效，在 transition/animation 完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。</span><br><span class="line"></span><br><span class="line">v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入一帧后生效 (于此同时 v-enter 被删除)，在 transition/animation 完成之后移除。</span><br><span class="line"></span><br><span class="line">v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。</span><br><span class="line"></span><br><span class="line">v-leave-active：定义过渡的状态。在元素整个过渡过程中作用，在离开过渡被触发后立即生效，在 transition/animation 完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。</span><br><span class="line"></span><br><span class="line">v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发一帧后生效 (于此同时 v-leave 被删除)，在 transition/animation 完成之后移除。</span><br><span class="line"></span><br><span class="line">![className](https://cn.vuejs.org/images/transition.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果有多个元素需要用transition-group包裹，并且需要有key值做标记</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">animate.css:</span><br><span class="line"></span><br><span class="line">引入animate.css之后，按照下面的写法：</span><br></pre></td></tr></table></figure><transition ​="" leave-active-class="animated fadeOut" enter-active-class="animated slideInLeft"><br>​        <p v-if="isShow" class="box"></p><br></transition><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">##### Vue里组件的通信</span><br><span class="line"></span><br><span class="line">通信：传参、控制（A操控B做一个事件）、数据共享</span><br><span class="line"></span><br><span class="line">模式：父子组件间、非父子组件</span><br><span class="line"></span><br><span class="line">1. 父组件可以将一条数据传递给子组件，这条数据可以是动态的，父组件的数据更改的时候，子组件接收的也会变化</span><br><span class="line"></span><br><span class="line">    子组件被动的接收父组件的数据,子组件不要再更改这条数据了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 父组件如果将一个引用类型的动态数据传递给子组价的时候，数据会变成双向控制的，子组件改数据的时候父组件也能接收到数据变化,因为子组件改的时候不是在改数据(地址)，而是在改数据里的内容，也就是说引用类型数据的地址始终没有变化，不算改父组件数据</span><br><span class="line"></span><br><span class="line">    父子间数据共享（双向控制）,基本不会使用，违背了单向数据流</span><br><span class="line"></span><br><span class="line">3. 父组件可以将一个方法传递给子组件，子组件调用这个方法的时候，就可以给父组件传递数据</span><br><span class="line"></span><br><span class="line">    父组件被动的接收子组件的数据</span><br><span class="line"></span><br><span class="line">4. 父组件可以将一个事件绑定在子组件的身上，这个事件的处理程序是父组件某一个方法，当子组件触发自己的这个被绑定的事件的时候，相当于触发了父组件的方法</span><br><span class="line"></span><br><span class="line">    父组件被动的接收子组件的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5. 在组件间可以用过ref形成ref链，组件还拥有一个关系链（$parent,$children,$root）,通过这两种链；理论来说，任意的两个组件都可以互相访问，互相进行通信</span><br><span class="line"></span><br><span class="line">    任意组件通信，用的少...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6. event bus  事件总线  小天使  专注于非父子组件的通信，其实父子组件也可以使用，只是没有必要</span><br><span class="line"></span><br><span class="line">    在B组件的某个钩子函数为event_bus绑定一个事件，事件的处理程序是B想做的事情</span><br><span class="line"></span><br><span class="line">    在A组件的某一个操作里，触发event_bus绑定的事件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7. 大量组件间数据共享的时候  vuex</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;过滤器&quot;&gt;&lt;a href=&quot;#过滤器&quot; class=&quot;headerlink&quot; title=&quot;过滤器&quot;&gt;&lt;/a&gt;过滤器&lt;/h5&gt;&lt;p&gt;vue中可以设置filter(过滤器)来实现数据格式化，双花括号插值和 v-bind 表达式中使用&lt;/p&gt;
&lt;p&gt;vue1.0的有默
      
    
    </summary>
    
    
      <category term="vue学习" scheme="https://tianjiec.top/tags/vue%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vue学习4</title>
    <link href="https://tianjiec.top/2019/01/08/vue%E5%AD%A6%E4%B9%A04/"/>
    <id>https://tianjiec.top/2019/01/08/vue学习4/</id>
    <published>2019-01-08T09:16:56.000Z</published>
    <updated>2019-01-08T09:18:20.288Z</updated>
    
    <content type="html"><![CDATA[<h5 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h5><p>模块化就是将系统功能分离成独立的功能部分的方法，一般指的是单个的某一种东西，例如js、css</p><p>而组件化针对的是页面中的整个完整的功能模块划分，组件是一个html、css、js、image等外链资源，这些部分组成的一个聚合体</p><p>优点：代码复用，便于维护</p><p>划分组件的原则：复用率高的，独立性强的</p><p>组件应该拥有的特性：可组合，可重用，可测试，可维护</p><h5 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h5><p>在vue中，我们通过Vue.extend来创建Vue的子类，这个东西其实就是组件</p><p>也就是说Vue实例和组件的实例有差别但是差别不带，因为毕竟一个是父类一个是子类</p><p>一般的应用，会拥有一个根实例，在根实例里面都是一个一个的组件</p><p>因为组件是要嵌入到实例或者父组件里的，也就是说，组件可以互相嵌套，而且，所有的组件最外层必须有一个根实例，所以组件分为：全局组件和局部组件</p><p>全局组件在任意的实例、父级组件中都能使用，局部组件只能在创建自己的父级组件或者实例中使用</p><p>组件通过不同的注册方法成为全局、局部组件</p><p>创建组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.extend(options)</span><br></pre></td></tr></table></figure><p>全局注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var App = Vue.extend(&#123;</span><br><span class="line">    template:&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(&apos;my-app&apos;,App)</span><br></pre></td></tr></table></figure><p>简便写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建组件构造器和注册组件合并一起  </span><br><span class="line"> Vue.component(&apos;hello&apos;,&#123;//Vue会自动的将此对象给Vue.extend</span><br><span class="line">     template:&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>组件通过template来确定自己的模板,template里的模板必须有根节点，标签必须闭合</p><p>组件的属性挂载通过：data方法来返回一个对象作为组件的属性，这样做的目的是为了每一个组件实例都拥有独立的data属性</p><p>局部注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el:&quot;#app&quot;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        &apos;my-app&apos;:App</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简便写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">    &apos;hello&apos;:&#123;</span><br><span class="line">        template:&quot;&lt;h1&gt;asdasdasdasdasdas&lt;/h1&gt;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实例或者组件中注册另一个组件，这个时候，被注册的组件只能在注册它的实例或组件的模板中使用，一个组件可以被多个组件或实例注册</p><h6 id="注意浏览器规则"><a href="#注意浏览器规则" class="headerlink" title="注意浏览器规则"></a>注意浏览器规则</h6><p>因为vue在解析模板的时候会根据某些html的规则，例如，在table里只能放tr,td,th..，如果放入组件不会解析 这个时候我们可以放入tr使用is方式来标识这个tr其实是组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;tr is=&quot;hello&quot;&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h6 id="template"><a href="#template" class="headerlink" title="template"></a>template</h6><p>我们可以在html的某个地方通过template标签来定义组件的模板，在组件的template属性中通过选择器指定对应的template标签内容就可以了,注意，需要给template标签加id来指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=&quot;my-hello&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;hello world&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;hahahah&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">//组件中</span><br><span class="line">template:&quot;#my-hello&quot;</span><br></pre></td></tr></table></figure><h6 id="is切换"><a href="#is切换" class="headerlink" title="is切换"></a>is切换</h6><p>在实例、组件的模板中的某一个标签上，可以通过is属性来指定为另一个目标的组件，这个时候我们一般会使用component标签来占位、设置is属性来指定目标组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;component :is=&quot;type&quot;&gt;&lt;/component&gt;</span><br><span class="line"></span><br><span class="line">//组件中</span><br><span class="line">data:&#123;</span><br><span class="line">    type:&apos;aaa&apos;</span><br><span class="line">&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">    &apos;aaa&apos;:&#123;template:&quot;&lt;h1&gt;AAAAAAAAAAAAA&lt;/h1&gt;&quot;&#125;,</span><br><span class="line">    &apos;bbb&apos;:&#123;template:&quot;&lt;h1&gt;BBBBBBBBBBBBB&lt;/h1&gt;&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h6><p>应用中划分的组件可能会很多，为了更好的实现代码复用，所以必然会存在组件的嵌套关系</p><p>组件设计初衷就是要配合使用的，最常见的就是形成父子组件的关系：组件 A 在它的模板中使用了组件 B。</p><h6 id="prop-传递数据"><a href="#prop-传递数据" class="headerlink" title="prop 传递数据"></a>prop 传递数据</h6><p>组件实例的作用域是孤立的,父组件不能直接使用子组件的数据，子组件也不能直接使用父组件的数据</p><p>父组件在模板中使用子组件的时候可以给子组件传递数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bbb money=&quot;2&quot;&gt;&lt;/bbb&gt;</span><br></pre></td></tr></table></figure><p>子组件需要通过props属性来接收后才能使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;bbb&apos;:&#123;</span><br><span class="line">    props:[&apos;money&apos;]</span><br></pre></td></tr></table></figure><p>如果父组件传递属性给子组件的时候键名有’-‘，子组件接收的时候写成小驼峰的模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bbb clothes-logo=&apos;amani&apos; clothes-price=&quot;16.58&quot;&gt;&lt;/bbb&gt;</span><br><span class="line">////</span><br><span class="line">props:[&apos;clothesLogo&apos;,&apos;clothesPrice&apos;]</span><br></pre></td></tr></table></figure><p>我们可以用 v-bind 来动态地将 prop 绑定到父组件的数据。每当父组件的数据变化时，该变化也会传导给子组件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;组件化&quot;&gt;&lt;a href=&quot;#组件化&quot; class=&quot;headerlink&quot; title=&quot;组件化&quot;&gt;&lt;/a&gt;组件化&lt;/h5&gt;&lt;p&gt;模块化就是将系统功能分离成独立的功能部分的方法，一般指的是单个的某一种东西，例如js、css&lt;/p&gt;
&lt;p&gt;而组件化针对的是页面中的
      
    
    </summary>
    
    
      <category term="vue学习" scheme="https://tianjiec.top/tags/vue%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vue学习3</title>
    <link href="https://tianjiec.top/2019/01/08/vue%E5%AD%A6%E4%B9%A03/"/>
    <id>https://tianjiec.top/2019/01/08/vue学习3/</id>
    <published>2019-01-08T09:16:51.000Z</published>
    <updated>2019-01-08T09:24:31.907Z</updated>
    
    <content type="html"><![CDATA[<h5 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h5><p>这是一个指令，只要有v-的就是指令（directive 操作dom ）</p><p>在vue中可以通过v-for来循环数据的通知循环dom，语法是item in/of items，接收第二个参数是索引 (item,index) of items,还可以循环键值对，第一个参数是value，第二个是key，第三个依然是索引</p><h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h5><p>在vue中还有v-on来为dom绑定事件，在v-on：后面加上要绑定的事件类型，值里可以执行一些简单javascript表达式：++ – = …</p><p>可以将一些方法设置在methods里，这样就可以在v-on:click的值里直接写方法名字可以，默认会在方法中传入事件对象，当写方法的时候加了()就可以传参，这个时候如果需要事件对象，那就主动传入$event</p><p>v-on绑定的事件可以是任意事件,v-on:可以缩写为@</p><p>为什么在 HTML 中监听事件?</p><p>你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处：</p><ol><li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li><li>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</li><li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。</li></ol><h5 id="计算属性、监听"><a href="#计算属性、监听" class="headerlink" title="计算属性、监听"></a>计算属性、监听</h5><p>有的时候我们需要在模板中使用数据a，这个时候就需要用到表达式，但是有的地方我们需要对a数据进行一些简单的处理后才能使用，那么我们就会在表达式中写一些js逻辑运算</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样我们的维护就会非常困难，也不便于阅读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我们就可以在methods里设置一个方法，在模板的表达式中使用这个方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">// 在组件中</span><br><span class="line">methods: &#123;</span><br><span class="line">reversedMessage: function () &#123;</span><br><span class="line">    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">但是这个时候，只要vm中有数据变化，这个变化的数据可能和我们关注的数据无关，但是vm都会重新渲染模板，这个时候表达式中的方法就会重新执行，大大的影响性能</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个时候其实我们可以使用监听器里完成：</span><br><span class="line"></span><br><span class="line">在vm实例中设置watch属性，在里面通过键值对来设置一些监听，键名为数据名，值可以是一个函数，这个函数在数据改变之后才会执行，两个参数分别是性格前的值和更改后的值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a: function (val, oldVal) &#123;</span><br><span class="line">    console.log(&apos;new: %s, old: %s&apos;, val, oldVal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">值还可以是一个方法名字，当数据改变的时候这个方法会执行</span><br><span class="line"></span><br><span class="line">当数据为object的时候，object的键值对改变不会被监听到（数组的push等方法可以）,这个时候需要设置深度监听：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c: &#123;</span><br><span class="line">    deep:true,</span><br><span class="line">    handler:function (val, oldVal) &#123;</span><br><span class="line">        console.log(&apos;new: %s, old: %s&apos;, val, oldVal)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">监听的handler函数前面的这几种写法都是在数据变化的时候才会执行，初始化的时候不会执行，但是如果设置immediate为true就可以了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num:&#123;</span><br><span class="line">    immediate:true,</span><br><span class="line">    handler:function(val)&#123;</span><br><span class="line">        this.nums = val*2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在回到上面的问题，用监听器加上immediate属性就可以做到该效果，但是大家可以看到的是逻辑稍稍有点复杂</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我们一般都会用到一个叫计算属性的东西来解决：</span><br><span class="line"></span><br><span class="line">计算属性就是在实例配置项中通过computed来为vm设置一个新的数据，而这个新数据会拥有一个依赖（一条已经存在的数据），当依赖发生变化的时候，新数据也会发生变化</span><br><span class="line"></span><br><span class="line">与方法的方式相比，它性能更高，计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</span><br><span class="line"></span><br><span class="line">与watch相比，写起来简单，逻辑性更清晰，watch一般多用于，根据数据的变化而执行某些动作，而至于这些动作是在干什么其实无所谓，而计算属性更有针对性，根据数据变化而更改另一个数据</span><br><span class="line"></span><br><span class="line">计算属性也拥有getter和setter，默认写的是getter，设置setter可以当此计算属性数据更改的时候去做其他的一些事情，相当于watch这个计算属性</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xm:&#123;</span><br><span class="line">    get:function()&#123;//getter 当依赖改变后设置值的时候</span><br><span class="line">        return this.xing+&apos;丶&apos;+this.ming</span><br><span class="line">    &#125;,</span><br><span class="line">    set:function(val)&#123;//setter 当自身改变后执行</span><br><span class="line">        this.xing = val.split(&apos;丶&apos;)[0]</span><br><span class="line">        this.ming = val.split(&apos;丶&apos;)[1]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;v-for&quot;&gt;&lt;a href=&quot;#v-for&quot; class=&quot;headerlink&quot; title=&quot;v-for&quot;&gt;&lt;/a&gt;v-for&lt;/h5&gt;&lt;p&gt;这是一个指令，只要有v-的就是指令（directive 操作dom ）&lt;/p&gt;
&lt;p&gt;在vue中可以通过v-for来
      
    
    </summary>
    
    
      <category term="vue学习" scheme="https://tianjiec.top/tags/vue%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vue学习2</title>
    <link href="https://tianjiec.top/2019/01/08/vue%E5%AD%A6%E4%B9%A02/"/>
    <id>https://tianjiec.top/2019/01/08/vue学习2/</id>
    <published>2019-01-08T09:16:45.000Z</published>
    <updated>2019-01-08T09:23:53.147Z</updated>
    
    <content type="html"><![CDATA[<h5 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h5><p>这是一个指令，只要有v-的就是指令（directive 操作dom ）</p><p>在vue中可以通过v-for来循环数据的通知循环dom，语法是item in/of items，接收第二个参数是索引 (item,index) of items,还可以循环键值对，第一个参数是value，第二个是key，第三个依然是索引</p><h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h5><p>在vue中还有v-on来为dom绑定事件，在v-on：后面加上要绑定的事件类型，值里可以执行一些简单javascript表达式：++ – = …</p><p>可以将一些方法设置在methods里，这样就可以在v-on:click的值里直接写方法名字可以，默认会在方法中传入事件对象，当写方法的时候加了()就可以传参，这个时候如果需要事件对象，那就主动传入$event</p><p>v-on绑定的事件可以是任意事件,v-on:可以缩写为@</p><p>为什么在 HTML 中监听事件?</p><p>你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处：</p><ol><li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li><li>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</li><li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。</li></ol><h5 id="计算属性、监听"><a href="#计算属性、监听" class="headerlink" title="计算属性、监听"></a>计算属性、监听</h5><p>有的时候我们需要在模板中使用数据a，这个时候就需要用到表达式，但是有的地方我们需要对a数据进行一些简单的处理后才能使用，那么我们就会在表达式中写一些js逻辑运算</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样我们的维护就会非常困难，也不便于阅读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我们就可以在methods里设置一个方法，在模板的表达式中使用这个方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">// 在组件中</span><br><span class="line">methods: &#123;</span><br><span class="line">reversedMessage: function () &#123;</span><br><span class="line">    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">但是这个时候，只要vm中有数据变化，这个变化的数据可能和我们关注的数据无关，但是vm都会重新渲染模板，这个时候表达式中的方法就会重新执行，大大的影响性能</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个时候其实我们可以使用监听器里完成：</span><br><span class="line"></span><br><span class="line">在vm实例中设置watch属性，在里面通过键值对来设置一些监听，键名为数据名，值可以是一个函数，这个函数在数据改变之后才会执行，两个参数分别是性格前的值和更改后的值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a: function (val, oldVal) &#123;</span><br><span class="line">    console.log(&apos;new: %s, old: %s&apos;, val, oldVal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">值还可以是一个方法名字，当数据改变的时候这个方法会执行</span><br><span class="line"></span><br><span class="line">当数据为object的时候，object的键值对改变不会被监听到（数组的push等方法可以）,这个时候需要设置深度监听：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c: &#123;</span><br><span class="line">    deep:true,</span><br><span class="line">    handler:function (val, oldVal) &#123;</span><br><span class="line">        console.log(&apos;new: %s, old: %s&apos;, val, oldVal)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">监听的handler函数前面的这几种写法都是在数据变化的时候才会执行，初始化的时候不会执行，但是如果设置immediate为true就可以了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num:&#123;</span><br><span class="line">    immediate:true,</span><br><span class="line">    handler:function(val)&#123;</span><br><span class="line">        this.nums = val*2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在回到上面的问题，用监听器加上immediate属性就可以做到该效果，但是大家可以看到的是逻辑稍稍有点复杂</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我们一般都会用到一个叫计算属性的东西来解决：</span><br><span class="line"></span><br><span class="line">计算属性就是在实例配置项中通过computed来为vm设置一个新的数据，而这个新数据会拥有一个依赖（一条已经存在的数据），当依赖发生变化的时候，新数据也会发生变化</span><br><span class="line"></span><br><span class="line">与方法的方式相比，它性能更高，计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</span><br><span class="line"></span><br><span class="line">与watch相比，写起来简单，逻辑性更清晰，watch一般多用于，根据数据的变化而执行某些动作，而至于这些动作是在干什么其实无所谓，而计算属性更有针对性，根据数据变化而更改另一个数据</span><br><span class="line"></span><br><span class="line">计算属性也拥有getter和setter，默认写的是getter，设置setter可以当此计算属性数据更改的时候去做其他的一些事情，相当于watch这个计算属性</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xm:&#123;</span><br><span class="line">    get:function()&#123;//getter 当依赖改变后设置值的时候</span><br><span class="line">        return this.xing+&apos;丶&apos;+this.ming</span><br><span class="line">    &#125;,</span><br><span class="line">    set:function(val)&#123;//setter 当自身改变后执行</span><br><span class="line">        this.xing = val.split(&apos;丶&apos;)[0]</span><br><span class="line">        this.ming = val.split(&apos;丶&apos;)[1]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;v-for&quot;&gt;&lt;a href=&quot;#v-for&quot; class=&quot;headerlink&quot; title=&quot;v-for&quot;&gt;&lt;/a&gt;v-for&lt;/h5&gt;&lt;p&gt;这是一个指令，只要有v-的就是指令（directive 操作dom ）&lt;/p&gt;
&lt;p&gt;在vue中可以通过v-for来
      
    
    </summary>
    
    
      <category term="vue学习" scheme="https://tianjiec.top/tags/vue%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vue学习1</title>
    <link href="https://tianjiec.top/2019/01/08/vue%E5%AD%A6%E4%B9%A01/"/>
    <id>https://tianjiec.top/2019/01/08/vue学习1/</id>
    <published>2019-01-08T09:15:53.000Z</published>
    <updated>2019-01-08T09:16:29.005Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><blockquote><p>Vue是一个前端js框架，由尤雨溪开发，是个人项目</p></blockquote><p>Vue近几年来特别的受关注，三年前的时候angularJS霸占前端JS框架市场很长时间，接着react框架横空出世，因为它有一个特性是虚拟DOM，从性能上碾轧angularJS，这个时候，vue1.0悄悄的问世了，它的优雅，轻便也吸引了一部分用户，开始收到关注，16年中旬，VUE2.0问世，这个时候vue不管从性能上，还是从成本上都隐隐超过了react，火的一塌糊涂，这个时候，angular开发团队也开发了angular2.0版本，并且更名为angular，吸收了react、vue的优点，加上angular本身的特点，也吸引到很多用户，目前已经迭代到5.0了。</p><p>学习vue是现在前端开发者必须的一个技能。</p><h5 id="前端js框架到底在干嘛，为什么要用"><a href="#前端js框架到底在干嘛，为什么要用" class="headerlink" title="前端js框架到底在干嘛，为什么要用"></a>前端js框架到底在干嘛，为什么要用</h5><p>js框架帮助开发者写js逻辑代码，在开发应用的时候js的功能划分为如下几点：</p><ol><li>渲染数据</li><li>操作dom（写一些效果）</li><li>操作cookie等存储机制api</li></ol><p>在前端开发中，如何高效的操作dom、渲染数据是一个前端工程师需要考虑的问题，而且当数据量大，流向较乱的时候，如何正确使用数据，操作数据也是一个问题</p><p>而js框架对上述的几个问题都有自己趋于完美的解决方案，开发成本降低。高性能高效率。唯一的缺点就是需要使用一定的成本来学习。</p><h5 id="Vue官网介绍"><a href="#Vue官网介绍" class="headerlink" title="Vue官网介绍"></a>Vue官网介绍</h5><p>vue是渐进式JavaScript框架</p><p>vue的主张较弱</p><p>“渐进式框架”和“自底向上增量开发的设计”是Vue开发的两个概念</p><p>Vue可以在任意其他类型的项目中使用，使用成本较低，更灵活，主张较弱，在Vue的项目中也可以轻松融汇其他的技术来开发，并且因为Vue的生态系统特别庞大，可以找到基本所有类型的工具在vue项目中使用</p><p>特点：易用（使用成本低），灵活（生态系统完善，适用于任何规模的项目），高效（体积小，优化好，性能好）</p><p>Vue是一个MVVM的js框架，但是，Vue 的核心库只关注视图层，开发者关注的只是m-v的映射关系</p><h3 id="Vue的使用"><a href="#Vue的使用" class="headerlink" title="Vue的使用"></a>Vue的使用</h3><p>Vue不支持IE8，因为使用了ES5的很多特性  //Object.defineProperty(_data,”msg”,{get(),set()})  _data.msg</p><p>可以直接通过script标签来引入vue.js，有开发版本和生产版本，开发版本一般我们在开发项目的时候引入，当最后开发完成上线的时候引入生产版本，开发版本没有压缩的，并且有很多提示，而生产版本全部删掉了</p><p>在Vue中提供了一个脚手架（命令行工具）可以帮我们快速的搭建基于webpack的开发环境…</p><h4 id="Vue的实例"><a href="#Vue的实例" class="headerlink" title="Vue的实例"></a>Vue的实例</h4><p>每一个应用都有一个根实例，在根实例里我们通过组件嵌套来实现大型的应用</p><p>也就是说组件不一定是必须的，但是实例是必须要有的</p><p>在实例化实例的时候我们可以传入一个；配置项，在配置项中设置很多属性方法可以实现复杂的功能</p><p>在配置中可以设置el（挂载点）的属性，el属性代表的是此实例的作用范围</p><p>在配置中同过设置data属性来为实例绑定数据</p><h3 id="mvc-mvvm"><a href="#mvc-mvvm" class="headerlink" title="mvc/mvvm"></a>mvc/mvvm</h3><p><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">阮大神博客</a></p><p>mvc 分为三层，其实M层是数据模型层，它是真正的后端数据在前端js中的一个映射模型，他们的关系是：数据模型层和视图层有映射关系，model改变，view展示也会更改，当view产生用户操作或会反馈给controller，controller更改model，这个时候view又会进行新的数据渲染</p><p>view可以直接操作model （数据双向绑定）</p><p>MVVM：</p><p><a href="http://image.beekka.com/blog/2015/bg2015020110.png" target="_blank" rel="noopener">mvvm</a></p><p>MVVM和MVP及其相似，只是view和viewmodel的通信是双向绑定，view的操作会自动的像viewmodel通过</p><h5 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h5><p>这是一个指令，只要有v-的就是指令（directive 操作dom ）</p><p>在vue中可以通过v-for来循环数据的通知循环dom，语法是item in/of items，接收第二个参数是索引 (item,index) of items,还可以循环键值对，第一个参数是value，第二个是key，第三个依然是索引</p><h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h5><p>在vue中还有v-on来为dom绑定事件，在v-on：后面加上要绑定的事件类型，值里可以执行一些简单javascript表达式：++ – = …</p><p>可以将一些方法设置在methods里，这样就可以在v-on:click的值里直接写方法名字可以，默认会在方法中传入事件对象，当写方法的时候加了()就可以传参，这个时候如果需要事件对象，那就主动传入$event</p><p>v-on绑定的事件可以是任意事件,v-on:可以缩写为@</p><p>为什么在 HTML 中监听事件?</p><p>你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处：</p><ol><li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</li><li>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</li><li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vue&quot;&gt;&lt;a href=&quot;#Vue&quot; class=&quot;headerlink&quot; title=&quot;Vue&quot;&gt;&lt;/a&gt;Vue&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Vue是一个前端js框架，由尤雨溪开发，是个人项目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vue近几年
      
    
    </summary>
    
    
      <category term="vue学习" scheme="https://tianjiec.top/tags/vue%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>vue项目-豆瓣</title>
    <link href="https://tianjiec.top/2019/01/04/vue%E9%A1%B9%E7%9B%AE-%E8%B1%86%E7%93%A3/"/>
    <id>https://tianjiec.top/2019/01/04/vue项目-豆瓣/</id>
    <published>2019-01-04T09:51:43.000Z</published>
    <updated>2019-01-04T09:52:49.648Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="vue" scheme="https://tianjiec.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>export default</title>
    <link href="https://tianjiec.top/2019/01/03/export-default/"/>
    <id>https://tianjiec.top/2019/01/03/export-default/</id>
    <published>2019-01-03T02:11:51.000Z</published>
    <updated>2019-01-03T02:45:20.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;footer&quot;&gt;</span><br><span class="line">        &#123;&#123;text&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/ecmascript-6&quot;&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                text: &apos;我是footer&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;css&quot;&gt;</span><br><span class="line">    .footer &#123;</span><br><span class="line">        width:100%;</span><br><span class="line">        height:40px;</span><br><span class="line">        line-height:40px;</span><br><span class="line">        background:rgba(0,0,0,.8);</span><br><span class="line">        color:#fff;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>export default{}返回的是VueComponent的实例对象，</p><h4 id="export-default是es6的用法，那为什么返回的是VueComponent的实例对象？"><a href="#export-default是es6的用法，那为什么返回的是VueComponent的实例对象？" class="headerlink" title="export default是es6的用法，那为什么返回的是VueComponent的实例对象？"></a>export default是es6的用法，那为什么返回的是VueComponent的实例对象？</h4><p>因为用到了vue-loader。vue-loader把.vue文件编译成.js文件，产出的js导出了一个符合vue组件component定义的object对象</p><p><strong>export default中为啥可以使用vue原型Vue.prototype.xx的方法？</strong></p><p>因为<strong>VueComponent通过原型链继承Vue原型上的属性和方法。</strong></p><h2 id="export"><a href="#export" class="headerlink" title="export"></a>export</h2><p>ES6之前已经出现了js模块加载方案，最主要的是CommonJS和AMD规范。commonjs主要应用于服务器，实现同步加载，如nodejs。AMD规范应用于浏览器，如require.js，为异步加载。同时还有CMD规范，为同步加载方案seaJS</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;export-default&quot;&gt;&lt;a href=&quot;#export-default&quot; class=&quot;headerlink&quot; title=&quot;export default&quot;&gt;&lt;/a&gt;export default&lt;/h2&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
      <category term="vue es6" scheme="https://tianjiec.top/tags/vue-es6/"/>
    
  </entry>
  
  <entry>
    <title>meta标签的作用及整理</title>
    <link href="https://tianjiec.top/2019/01/02/meta%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E6%95%B4%E7%90%86/"/>
    <id>https://tianjiec.top/2019/01/02/meta标签的作用及整理/</id>
    <published>2019-01-02T12:34:57.000Z</published>
    <updated>2019-01-02T12:35:45.468Z</updated>
    
    <content type="html"><![CDATA[<p>meta的标签的使用是我在前端学习中曾经困惑过一段时间的问题。一方面不是很了解meta标签的用途，另一方面是对于meta标签里的属性和值不是懂，也不知道从哪里冒出来的，所以这篇文章专门整理下meta标签，一个必用且关键的标签。</p><p>什么是meta标签？<br>引自下W3school的定义说明一下。</p><p>元数据（metadata）是关于数据的信息。</p><p>标签提供关于 HTML 文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。</p><p>典型的情况是，meta 元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。</p><p>标签始终位于 head 元素中。</p><p>元数据可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p><p>其实对上面的概念简单总结下就是：<meta> 标签提供关于 HTML 文档的元数据。它不会显示在页面上，但是对于机器是可读的。可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p><p>meta的作用<br>meta里的数据是供机器解读的，告诉机器该如何解析这个页面，还有一个用途是可以添加服务器发送到浏览器的http头部内容，例如我们为页面中添加如下meta标签：</p><p><meta http-equiv="charset" content="iso-8859-1"></p><p><meta http-equiv="expires" content="31 Dec 2008"><br>1<br>2<br>那么浏览器的头部就会包括这些:</p><p>charset:iso-8859-1<br>expires:31 Dec 2008<br>1<br>2<br>当然，只有浏览器可以接受这些附加的头部字段，并能以适当的方式使用它们时，这些字段才有意义。</p><p>meta的必需属性和可选属性<br>必需属性content<br>meta的必需属性是content，当然并不是说meta标签里一定要有content，而是当有http-equiv或name属性的时候，一定要有content属性对其进行说明。例如：</p><meta name="keywords" content="HTML,ASP,PHP,SQL"><p>这里面content里的属性就是对keywords进行的说明，所以呢也可以理解成一个键值对吧，就是{keywords:”HTML,ASP,PHP,SQL”}。</p><p>可选属性<br>在W3school中，对于meta的可选属性说到了三个，分别是http-equiv、name和scheme。考虑到scheme不是很常用，所以就只说下前两个属性吧。</p><p>http-equiv<br>http-equiv属性是添加http头部内容，对一些自定义的，或者需要额外添加的http头部内容，需要发送到浏览器中，我们就可以是使用这个属性。在上面的meta作用中也有简单的说明，那么现在再举个例子。例如我们不想使用js来重定向，用http头部内容控制，那么就可以这样控制：</p><p><meta http-equiv="Refresh" content="5;url=http://blog.yangchen123h.cn"><br>1<br>在页面中加入这个后，5秒钟后就会跳转到指定页面啦，效果可看W3school的例子</p><p>name<br>第二个可选属性是name，这个属性是供浏览器进行解析，对于一些浏览器兼容性问题，name属性是最常用的，当然有个前提就是浏览器能够解析你写进去的name属性才可以，不然就是没有意义的。还是举个例子吧:</p><p><meta name="renderer" content="webkit"><br>1<br>这个meta标签的意思就是告诉浏览器，用webkit内核进行解析，当然前提是浏览器有webkit内核才可以，不然就是没有意义的啦。当然看到这个你可能会有疑问，这个renderer是从哪里冒出来的，我要怎么知道呢？这个就是在对应的浏览器的开发文档里就会有表明的，例如这个renderer是在360浏览器里说明的。360浏览器内核控制Meta标签说明文档</p><p>常用meta标签大总结<br>接下来就是常用的meta标签大总结啦，我会尽可能的做到全</p><p>charset<br>charset是声明文档使用的字符编码，解决乱码问题主要用的就是它，值得一提的是，这个charset一定要写第一行，不然就可能会产生乱码了。</p><p>charset有两种写法</p><p><meta charset="utf-8"></p><p><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><br>1<br>2<br>两个都是等效的。</p><p>百度禁止转码<br>百度会自动对网页进行转码，这个标签是禁止百度的自动转码</p><p><meta http-equiv="Cache-Control" content="no-siteapp"><br>1<br>SEO 优化部分<br><!-- 页面标题<title>标签(head 头部必须) --></p><p><title>your title</title><br><!-- 页面关键词 keywords --></p><p><meta name="keywords" content="your keywords"><br><!-- 页面描述内容 description --></p><p><meta name="description" content="your description"><br><!-- 定义网页作者 author --></p><p><meta name="author" content="author,email address"><br><!-- 定义网页搜索引擎索引方式，robotterms 是一组使用英文逗号「,」分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。 --></p><p><meta name="robots" content="index,follow"><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>viewport<br>viewport主要是影响移动端页面布局的，例如：</p><meta name="viewport" content="width=device-width, initial-scale=1.0"><p>1<br>2<br>3<br>content 参数：</p><p>width viewport 宽度(数值/device-width)<br>height viewport 高度(数值/device-height)<br>initial-scale 初始缩放比例<br>maximum-scale 最大缩放比例<br>minimum-scale 最小缩放比例<br>user-scalable 是否允许用户缩放(yes/no)<br>各浏览器平台<br>Microsoft Internet Explorer<br><!-- 优先使用最新的ie版本 --></p><p><meta http-equiv="x-ua-compatible" content="ie=edge"><br><!-- 是否开启cleartype显示效果 --></p><p><meta http-equiv="cleartype" content="on"></p><meta name="skype_toolbar" content="skype_toolbar_parser_compatible"><!-- Pinned Site --><!-- IE 10 / Windows 8 --><p><meta name="msapplication-TileImage" content="pinned-tile-144.png"></p><p><meta name="msapplication-TileColor" content="#009900"><br><!-- IE 11 / Windows 9.1 --></p><p><meta name="msapplication-config" content="ieconfig.xml"><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>Google Chrome<br><!-- 优先使用最新的chrome版本 --></p><p><meta http-equiv="X-UA-Compatible" content="chrome=1"><br><!-- 禁止自动翻译 --></p><p><meta name="google" value="notranslate"><br>1<br>2<br>3<br>4<br>360浏览器<br><!-- 选择使用的浏览器解析内核 --></p><p><meta name="renderer" content="webkit|ie-comp|ie-stand"><br>1<br>2<br>UC手机浏览器<br><!-- 将屏幕锁定在特定的方向 --></p><p><meta name="screen-orientation" content="landscape/portrait"><br><!-- 全屏显示页面 --></p><p><meta name="full-screen" content="yes"><br><!-- 强制图片显示，即使是"text mode" --></p><p><meta name="imagemode" content="force"><br><!-- 应用模式，默认将全屏，禁止长按菜单，禁止手势，标准排版，强制图片显示。 --></p><p><meta name="browsermode" content="application"><br><!-- 禁止夜间模式显示 --></p><p><meta name="nightmode" content="disable"><br><!-- 使用适屏模式显示 --></p><p><meta name="layoutmode" content="fitscreen"><br><!-- 当页面有太多文字时禁止缩放 --></p><p><meta name="wap-font-scale" content="no"><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>UCBrowser_U3_API</p><p>QQ手机浏览器<br><!-- 锁定屏幕在特定方向 --></p><p><meta name="x5-orientation" content="landscape/portrait"><br><!-- 全屏显示 --></p><p><meta name="x5-fullscreen" content="true"><br><!-- 页面将以应用模式显示 --></p><p><meta name="x5-page-mode" content="app"><br>1<br>2<br>3<br>4<br>5<br>6<br>Apple iOS<br><!-- Smart App Banner --></p><meta name="apple-itunes-app" content="app-id=APP_ID,affiliate-data=AFFILIATE_ID,app-argument=SOME_TEXT"><!-- 禁止自动探测并格式化手机号码 --><meta name="format-detection" content="telephone=no"><!-- Add to Home Screen添加到主屏 --><!-- 是否启用 WebApp 全屏模式 --><p><meta name="apple-mobile-web-app-capable" content="yes"><br><!-- 设置状态栏的背景颜色,只有在 “apple-mobile-web-app-capable” content=”yes” 时生效 --></p><p><meta name="apple-mobile-web-app-status-bar-style" content="black"><br><!-- 添加到主屏后的标题 --></p><p><meta name="apple-mobile-web-app-title" content="App Title"><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>Google Android</p><p><meta name="theme-color" content="#E64545"><br><!-- 添加到主屏 --></p><p><meta name="mobile-web-app-capable" content="yes"><br><!-- More info: https://developer.chrome.com/multidevice/android/installtohomescreen --><br>1<br>2<br>3<br>4<br>App Links<br><!-- iOS --></p><p><meta property="al:ios:url" content="applinks://docs"></p><p><meta property="al:ios:app_store_id" content="12345"></p><p><meta property="al:ios:app_name" content="App Links"><br><!-- Android --></p><p><meta property="al:android:url" content="applinks://docs"></p><p><meta property="al:android:app_name" content="App Links"></p><p><meta property="al:android:package" content="org.applinks"><br><!-- Web Fallback --></p><p><meta property="al:web:url" content="http://applinks.org/documentation"><br><!-- More info: http://applinks.org/documentation/ --><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>最后——移动端常用的meta</p><p><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"></p><p><meta name="apple-mobile-web-app-capable" content="yes"></p><p><meta name="apple-mobile-web-app-status-bar-style" content="black"></p><p><meta name="format-detection" content="telephone=no, email=no"></p><p><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"></p><p><meta name="apple-mobile-web-app-capable" content="yes"><!-- 删除苹果默认的工具栏和菜单栏 --></p><p><meta name="apple-mobile-web-app-status-bar-style" content="black"><!-- 设置苹果工具栏颜色 --></p><p><meta name="format-detection" content="telphone=no, email=no"><!-- 忽略页面中的数字识别为电话，忽略email识别 --><br><!-- 启用360浏览器的极速模式(webkit) --></p><p><meta name="renderer" content="webkit"><br><!-- 避免IE使用兼容模式 --></p><p><meta http-equiv="X-UA-Compatible" content="IE=edge"><br><!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --></p><p><meta name="HandheldFriendly" content="true"><br><!-- 微软的老式浏览器 --></p><p><meta name="MobileOptimized" content="320"><br><!-- uc强制竖屏 --></p><p><meta name="screen-orientation" content="portrait"><br><!-- QQ强制竖屏 --></p><p><meta name="x5-orientation" content="portrait"><br><!-- UC强制全屏 --></p><p><meta name="full-screen" content="yes"><br><!-- QQ强制全屏 --></p><p><meta name="x5-fullscreen" content="true"><br><!-- UC应用模式 --></p><p><meta name="browsermode" content="application"><br><!-- QQ应用模式 --></p><p><meta name="x5-page-mode" content="app"><br><!-- windows phone 点击无高光 --></p><p><meta name="msapplication-tap-highlight" content="no"></p><h2 id=""><a href="#" class="headerlink" title=""></a><!-- 适应移动端end --></h2><p>作者：阿Q虾米<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/yc123h/article/details/51356143" target="_blank" rel="noopener">https://blog.csdn.net/yc123h/article/details/51356143</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;meta的标签的使用是我在前端学习中曾经困惑过一段时间的问题。一方面不是很了解meta标签的用途，另一方面是对于meta标签里的属性和值不是懂，也不知道从哪里冒出来的，所以这篇文章专门整理下meta标签，一个必用且关键的标签。&lt;/p&gt;
&lt;p&gt;什么是meta标签？&lt;br&gt;引自
      
    
    </summary>
    
    
      <category term="js" scheme="https://tianjiec.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ES6模块的import和export用法总结</title>
    <link href="https://tianjiec.top/2019/01/02/ES6%E6%A8%A1%E5%9D%97%E7%9A%84import%E5%92%8Cexport%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://tianjiec.top/2019/01/02/ES6模块的import和export用法总结/</id>
    <published>2019-01-02T12:33:21.000Z</published>
    <updated>2019-01-02T12:36:04.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6模块的import和export用法总结"><a href="#ES6模块的import和export用法总结" class="headerlink" title="ES6模块的import和export用法总结"></a><a href="https://www.cnblogs.com/dupd/p/5951311.html" target="_blank" rel="noopener">ES6模块的import和export用法总结</a></h1><p>ES6之前已经出现了js模块加载的方案，最主要的是CommonJS和AMD规范。commonjs主要应用于服务器，实现同步加载，如nodejs。AMD规范应用于浏览器，如requirejs，为异步加载。同时还有CMD规范，为同步加载方案如seaJS。</p><p>ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6模块主要有两个功能：export和import</p><p>export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口</p><p>import用于在一个模块中加载另一个含有export接口的模块。</p><p>也就是说使用<code>export</code>命令定义了模块的对外接口以后，其他JS文件就可以通过<code>import</code>命令加载这个模块（文件）。如下图(假设a和b文件在同一目录下)</p><p>按 Ctrl+C 复制代码</p><p>按 Ctrl+C 复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// b.js</span><br><span class="line">通过import获取a.js文件的内部变量，&#123;&#125;括号内的变量来自于a.js文件export出的变量标识符。</span><br><span class="line">import &#123;sex,echo&#125; from &quot;./a.js&quot; </span><br><span class="line">console.log(sex)   // boy</span><br><span class="line">echo(sex) // boy</span><br></pre></td></tr></table></figure><p>a.js文件也可以按如下export语法写，但不如上边直观，不太推荐。</p><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="javascript:void(0);" alt="复制代码](https://common.cnblogs.com/images/copycode.gif)" title="">                </div>                <div class="image-caption">复制代码](https://common.cnblogs.com/images/copycode.gif)</div>            </figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">export var sex=&quot;boy&quot;;</span><br><span class="line">export var echo=function(value)&#123;</span><br><span class="line">　　console.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//因为function echo()&#123;&#125;等价于 var echo=function()&#123;&#125;所以也可以写成</span><br><span class="line">export function echo(value)&#123;</span><br><span class="line">　　　console.log(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="javascript:void(0);" alt="复制代码](https://common.cnblogs.com/images/copycode.gif)" title="">                </div>                <div class="image-caption">复制代码](https://common.cnblogs.com/images/copycode.gif)</div>            </figure></p><p><strong>以上是export与module的基本用法，再进行拓展学习</strong></p><p>前面的例子可以看出，b.js使用<code>import</code>命令的时候，用户需要知道a.js所暴露出的变量标识符，否则无法加载。可以使用<strong>export default</strong>命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//a.js</span><br><span class="line">var sex=&quot;boy&quot;;</span><br><span class="line">export default sex（sex不能加大括号）</span><br><span class="line">//原本直接export sex外部是无法识别的，加上default就可以了.但是一个文件内最多只能有一个export default。</span><br><span class="line">其实此处相当于为sex变量值&quot;boy&quot;起了一个系统默认的变量名default，自然default只能有一个值，所以一个文件内不能有多个export default。</span><br></pre></td></tr></table></figure><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="javascript:void(0);" alt="复制代码](https://common.cnblogs.com/images/copycode.gif)" title="">                </div>                <div class="image-caption">复制代码](https://common.cnblogs.com/images/copycode.gif)</div>            </figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// b.js</span><br><span class="line">本质上，a.js文件的export default输出一个叫做default的变量，然后系统允许你为它取任意名字。所以可以为import的模块起任何变量名，且不需要用大括号包含</span><br><span class="line">import any from &quot;./a.js&quot;</span><br><span class="line">import any12 from &quot;./a.js&quot; </span><br><span class="line">console.log(any,any12)   // boy,boy</span><br></pre></td></tr></table></figure><p>原文：<a href="https://www.cnblogs.com/dupd/p/5951311.html" target="_blank" rel="noopener">https://www.cnblogs.com/dupd/p/5951311.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6模块的import和export用法总结&quot;&gt;&lt;a href=&quot;#ES6模块的import和export用法总结&quot; class=&quot;headerlink&quot; title=&quot;ES6模块的import和export用法总结&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://
      
    
    </summary>
    
    
      <category term="es6" scheme="https://tianjiec.top/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>移动端开发</title>
    <link href="https://tianjiec.top/2018/12/30/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    <id>https://tianjiec.top/2018/12/30/移动端开发/</id>
    <published>2018-12-30T12:40:46.000Z</published>
    <updated>2018-12-30T12:57:51.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移动端开发"><a href="#移动端开发" class="headerlink" title="移动端开发"></a>移动端开发</h1><h3 id="Viewport视口的作用："><a href="#Viewport视口的作用：" class="headerlink" title="Viewport视口的作用："></a>Viewport视口的作用：</h3><p>通俗的讲，移动设备上的viewport就是设备屏幕上能用来显示我们网页的那一块区域，再具体一点，就是浏览器上（也可能是一个app中的webview）用来显示网页的那部分区域，但viewport又不局限与浏览器的可视区域大小，它可能比浏览器的可视区域要大，也可能比浏览器可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是比大于浏览器可视区域的，这是因为考虑到移动设备分辨率相对于桌面电脑来说都比较小，所以为了能够在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或者1024px（也可能是其它值，有设备决定），但带来的后果是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。</p><h5 id="网页不是直接放到浏览器中，而是先放到视口中，然后等比例缩放到浏览器中。当浏览器宽度小于980时，浏览器宽度就为980"><a href="#网页不是直接放到浏览器中，而是先放到视口中，然后等比例缩放到浏览器中。当浏览器宽度小于980时，浏览器宽度就为980" class="headerlink" title="网页不是直接放到浏览器中，而是先放到视口中，然后等比例缩放到浏览器中。当浏览器宽度小于980时，浏览器宽度就为980"></a>网页不是直接放到浏览器中，而是先放到视口中，然后等比例缩放到浏览器中。当浏览器宽度小于980时，浏览器宽度就为980</h5><h5 id="浏览器宽度大于980时，宽度为视口此时的宽度"><a href="#浏览器宽度大于980时，宽度为视口此时的宽度" class="headerlink" title="浏览器宽度大于980时，宽度为视口此时的宽度"></a>浏览器宽度大于980时，宽度为视口此时的宽度</h5><h5 id="document-documentElement-clientWidth-获取视口宽度"><a href="#document-documentElement-clientWidth-获取视口宽度" class="headerlink" title="document.documentElement.clientWidth 获取视口宽度"></a>document.documentElement.clientWidth 获取视口宽度</h5><h5 id="user-scalable-none-：-用户不能缩放"><a href="#user-scalable-none-：-用户不能缩放" class="headerlink" title="user-scalable=none ： 用户不能缩放"></a>user-scalable=none ： 用户不能缩放</h5><h5 id="dpr：设备像素比：设备像素-物理-逻辑-2"><a href="#dpr：设备像素比：设备像素-物理-逻辑-2" class="headerlink" title="dpr：设备像素比：设备像素 = 物理/逻辑 = 2"></a>dpr：设备像素比：设备像素 = 物理/逻辑 = 2</h5><h5 id="现有手机dpr-一般为2-，-也就是四个像素点-当做一个像素点去用。"><a href="#现有手机dpr-一般为2-，-也就是四个像素点-当做一个像素点去用。" class="headerlink" title="现有手机dpr 一般为2 ， 也就是四个像素点 当做一个像素点去用。"></a>现有手机dpr 一般为2 ， 也就是四个像素点 当做一个像素点去用。</h5><h4 id="我们一般以iPhone5-iPhone6-为例制作设计稿"><a href="#我们一般以iPhone5-iPhone6-为例制作设计稿" class="headerlink" title="我们一般以iPhone5 / iPhone6 为例制作设计稿"></a>我们一般以iPhone5 / iPhone6 为例制作设计稿</h4><p>且以两倍图设计</p><p>因为如果不按照两倍图去设计 会先被放大，再等比例缩小放入浏览器。在放大的过程中会失真</p><h3 id="rem布局"><a href="#rem布局" class="headerlink" title="rem布局"></a>rem布局</h3><h4 id="以iphone5设计稿为例-640px-在设计稿当中宽度为320px，那么手机端应该是160px"><a href="#以iphone5设计稿为例-640px-在设计稿当中宽度为320px，那么手机端应该是160px" class="headerlink" title="//以iphone5设计稿为例  640px 在设计稿当中宽度为320px，那么手机端应该是160px"></a>//以iphone5设计稿为例  640px 在设计稿当中宽度为320px，那么手机端应该是160px</h4><h5 id="1、设置htmlfont-size"><a href="#1、设置htmlfont-size" class="headerlink" title="//1、设置htmlfont-size"></a>//1、设置htmlfont-size</h5><h4 id="document-documentELement-style-fontSIze-document-documentElement-clientWidth-3-2-“px”"><a href="#document-documentELement-style-fontSIze-document-documentElement-clientWidth-3-2-“px”" class="headerlink" title="document.documentELement.style.fontSIze = document.documentElement.clientWidth / 3.2 + “px”"></a>document.documentELement.style.fontSIze = document.documentElement.clientWidth / 3.2 + “px”</h4><h5 id="2、其他元素宽度"><a href="#2、其他元素宽度" class="headerlink" title="//2、其他元素宽度"></a>//2、其他元素宽度</h5><p>rem= width px/fontSIze</p><p>设计稿上面 宽度320px占一半=》在逻辑稿里面宽度为160px  然后根据上述计算的出 比例</p><p>rem为1.6rem</p><h4 id="以iphone6来设计-750设计稿-逻辑宽度为375px"><a href="#以iphone6来设计-750设计稿-逻辑宽度为375px" class="headerlink" title="//以iphone6来设计   750设计稿 逻辑宽度为375px"></a>//以iphone6来设计   750设计稿 逻辑宽度为375px</h4><p>document.documentELement.style.fontSIze = document.documentElement.clientWidth / 3.75 + “px”</p><p>#### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;移动端开发&quot;&gt;&lt;a href=&quot;#移动端开发&quot; class=&quot;headerlink&quot; title=&quot;移动端开发&quot;&gt;&lt;/a&gt;移动端开发&lt;/h1&gt;&lt;h3 id=&quot;Viewport视口的作用：&quot;&gt;&lt;a href=&quot;#Viewport视口的作用：&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="html" scheme="https://tianjiec.top/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>rem</title>
    <link href="https://tianjiec.top/2018/12/29/rem/"/>
    <id>https://tianjiec.top/2018/12/29/rem/</id>
    <published>2018-12-29T07:12:14.000Z</published>
    <updated>2018-12-30T12:34:42.461Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：</p><p><a href="http://caibaojian.com/web-app-rem.html" target="_blank" rel="noopener">http://caibaojian.com/web-app-rem.html</a></p><h2 id="rem是什么？"><a href="#rem是什么？" class="headerlink" title="rem是什么？"></a>rem是什么？</h2><p>rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。<a href="http://caibaojian.com/web-app-rem.html" target="_blank" rel="noopener">·</a></p><p>摘要：<a href="http://caibaojian.com/t/rem" target="_blank" rel="noopener">rem</a>是相对于根元素<html>，这样就意味着，我们只需要在根元素确定一个px字号，则可以来算出元素的宽高。本文讲的是如何使用<a href="http://caibaojian.com/t/rem" target="_blank" rel="noopener">rem</a>实现自适应。<a href="http://caibaojian.com/web-app-rem.html" target="_blank" rel="noopener">·</a></html></p><p>rem这是个低调的css单位，近一两年开始崭露头角，有许多同学对rem的评价不一，有的在尝试使用，有的在使用过程中遇到坑就弃用了。但是我对rem综合评价是用来做<a href="http://caibaojian.com/c/web" target="_blank" rel="noopener">web</a> app它绝对是最合适的人选之一。</p><h2 id="为什么web-app要使用rem？"><a href="#为什么web-app要使用rem？" class="headerlink" title="为什么web app要使用rem？"></a>为什么web app要使用rem？</h2><p>这里我特别强调web app，web page就不能使用rem吗，其实也当然可以，不过出于兼容性的考虑在web app下使用更加能突显这个单位的价值和能力，接下来我们来看看目前一些企业的web app是怎么做屏幕适配的。</p><h3 id="1、实现强大的屏幕适配布局："><a href="#1、实现强大的屏幕适配布局：" class="headerlink" title="1、实现强大的屏幕适配布局："></a>1、实现强大的屏幕适配布局：</h3><p>最近iphone6一下出了两款尺寸的手机，导致的移动端的屏幕种类更加的混乱，记得一两年前做web app有一种做法是以320宽度为标准去做适配，超过320的大小还是以320的规格去展示，这种实现方式以淘宝web app为代表作，但是近期手机淘宝首页进行了改版，采用了rem这个单位，首页以内依旧是和以前一样各种混乱，有定死宽度的页面，也有那种流式布局的页面。</p><p>我们现在在切页面布局的使用常用的单位是px，这是一个绝对单位，web app的屏幕适配有很多中做法，例如：流式布局、限死宽度，还有就是通过<a href="http://caibaojian.com/356.html" target="_blank" rel="noopener">响应式</a>来做，但是这些方案都不是最佳的解决方法。<a href="http://caibaojian.com/web-app-rem.html" target="_blank" rel="noopener">·</a></p><p>例如流式布局的解决方案有不少弊端，它虽然可以让各种屏幕都适配，但是显示的效果极其的不好，因为只有几个尺寸的手机能够完美的显示出视觉设计师和交互最想要的效果，但是目前行业里用流式布局切web app的公司还是挺多的，看看下面我收集的一些案例：</p><p>1.亚马逊：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pic.caibaojian.com/uploads/2015/12/1418896965.jpeg" alt="1418896965" title="">                </div>                <div class="image-caption">1418896965</div>            </figure><p>2.携程：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pic.caibaojian.com/uploads/2015/12/1418891322.jpeg" alt="原文来自http://caibaojian.com/web-app-rem.html" title="">                </div>                <div class="image-caption">原文来自http://caibaojian.com/web-app-rem.html</div>            </figure><p>3.兰亭</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pic.caibaojian.com/uploads/2015/12/1418891825.jpeg" alt="1418891825" title="">                </div>                <div class="image-caption">1418891825</div>            </figure><p>上面的网站都是采用的流式布局的技术实现的，他们在页面布局的时候都是通过百分比来定义宽度，但是高度大都是用px来固定住，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度还是和原来一样，实际显示非常的不协调，这就是流式布局的最致命的缺点，往往只有几个尺寸的手机下看到的效果是令人满意的，其实很多视觉设计师应该无法接受这种效果，因为他们的设计图在大屏幕手机下看到的效果相当于是被横向拉长来一样。</p><p>流式布局并不是最理想的实现方式，通过大量的百分比布局，会经常出现许多兼容性的问题，还有就是对设计有很多的限制，因为他们在设计之初就需要考虑流式布局对元素造成的影响，只能设计横向拉伸的元素布局，设计的时候存在很多局限性。</p><h3 id="2-固定宽度做法"><a href="#2-固定宽度做法" class="headerlink" title="2.固定宽度做法"></a>2.固定宽度做法</h3><p>还有一种是固定页面宽度的做法，早期有些网站把页面设置成320的宽度，超出部分留白，这样做视觉，前端都挺开心，视觉在也不用被流式布局限制自己的设计灵感了，前端也不用在搞坑爹的流式布局。但是这种解决方案也是存在一些问题，例如在大屏幕手机下两边是留白的，还有一个就是大屏幕手机下看起来页面会特别小，操作的按钮也很小，手机淘宝首页起初是这么做的，但近期改版了，采用了rem。</p><h3 id="3-响应式做法"><a href="#3-响应式做法" class="headerlink" title="3.响应式做法"></a>3.响应式做法</h3><p>响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是工作大，维护性难，所以一般都是中小型的门户或者博客类站点会采用响应式的方法从web page到web app直接一步到位，因为这样反而可以节约成本，不用再专门为自己的网站做一个web app的版本。</p><h3 id="4-设置viewport进行缩放"><a href="#4-设置viewport进行缩放" class="headerlink" title="4.设置viewport进行缩放"></a>4.设置viewport进行缩放</h3><p>天猫的web app的首页就是采用这种方式去做的，以320宽度为基准，进行缩放，最大缩放为320*1.3 = 416，基本缩放到416都就可以兼容iphone6 plus的屏幕了，这个方法简单粗暴，又高效。说实话我觉得他和用接下去我们要讲的rem都非常高效，不过有部分同学使用过程中反应缩放会导致有些页面元素会糊的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=320,maximum-scale=1.3,user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="rem能等比例适配所有屏幕"><a href="#rem能等比例适配所有屏幕" class="headerlink" title="rem能等比例适配所有屏幕"></a>rem能等比例适配所有屏幕</h2><p>上面讲了一大堆目前大部分公司主流的一些web app的适配解决方案，接下来讲下rem是如何工作的。</p><p>上面说过rem是通过根元素进行适配的，网页中的根元素指的是html我们通过设置html的字体大小就可以控制rem的大小。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">html&#123;</span><br><span class="line">    font-size:20px;</span><br><span class="line">&#125;</span><br><span class="line">.btn &#123;</span><br><span class="line">    width: 6rem;</span><br><span class="line">    height: 3rem;</span><br><span class="line">    line-height: 3rem;</span><br><span class="line">    font-size: 1.2rem;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    background: #06c;</span><br><span class="line">    color: #fff;</span><br><span class="line">    border-radius: .5rem;</span><br><span class="line">    text-decoration: none;</span><br><span class="line">    text-align: center;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo 上面代码结果按钮大小如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pic.caibaojian.com/uploads/2015/12/1418899506.jpeg" alt="1418899506" title="">                </div>                <div class="image-caption">1418899506</div>            </figure><p>我把html设置成10px是为了方便我们计算，为什么6rem等于60px。如果这个时候我们的.btn的样式不变，我们再改变html的font-size的值，看看按钮发生上面变化:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//code from http://caibaojian.com/web-app-rem.html</span><br><span class="line">html&#123;</span><br><span class="line">    font-size:40px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo</p><p>按钮大小结果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pic.caibaojian.com/uploads/2015/12/1418898055.jpeg" alt="1418898055" title="">                </div>                <div class="image-caption">1418898055</div>            </figure><p>上面的width，height变成了上面结果的两倍，我们只改变了html的font-size，但.btn样式的width,height的rem设置的属性不变的情况下就改变了按钮在web中的大小。</p><p>其实从上面两个案例中我们就可以计算出1px多少rem:</p><p>第一个例子：</p><p>120px = 6rem * 20px(根元素设置大值)</p><p>第二个例子：</p><p>240px = 6rem * 40px(根元素设置大值)</p><p>推算出：</p><p>10px  = 1rem 在根元素（font-size = 10px的时候）；</p><p>20px  = 1rem 在根元素（font-size = 20px的时候）；</p><p>40px  = 1rem 在根元素（font-size = 40px的时候）；</p><p>在上面两个例子中我们发现第一个案例按钮是等比例放大到第二个按钮，html font-size的改变就会导致按钮的大小发生改变，我们并不需要改变先前给按钮设置的宽度和高度，其实这就是我们最想看到的，为什么这么说？接下来我们再来看一个例子：</p><p>Demo</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pic.caibaojian.com/uploads/2015/12/1418873132.jpeg" alt="1418873132" title="">                </div>                <div class="image-caption">1418873132</div>            </figure><p>由上面两个的demo中我们知道改变html的font-size可以等比改变所有用了rem单位的元素，所以大家可以通过chrome浏览器的调试工具去切换第三个的demo在不同设备下的展示效果，或者通过缩放浏览器的宽度来查看效果，我们可以看到不管在任何分辨率下，页面的排版都是按照等比例进行切换，并且布局没有乱。我只是通过一段js根据浏览器当前的分辨率改变font-size的值，就简单的实现了上面的效果，页面的所有元素都不需要进行任何改变。</p><p><strong>到这里肯定有很多人会问我是怎么计算出不同分辨率下font-size的值？</strong></p><p>首先假设我上面的页面设计稿给我时候是按照640的标准尺寸给我的前提下，（当然这个尺寸肯定不一定是640，可以是320，或者480，又或是375）来看一组表格。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pic.caibaojian.com/uploads/2015/12/1418903956.jpeg" alt="1418903956" title="">                </div>                <div class="image-caption">1418903956</div>            </figure><p>上面的表格蓝色一列是Demo3中页面的尺寸，页面是以640的宽度去切的，怎么计算不同宽度下font-site的值，大家看表格上面的数值变化应该能明白。举个例子：384/640 = 0.6，384是640的0.6倍，所以384页面宽度下的font-size也等于它的0.6倍，这时384的font-size就等于12px。在不同设备的宽度计算方式以此类推。</p><p>Demo3中我是通过<a href="http://caibaojian.com/javascript/" target="_blank" rel="noopener">JS</a>去动态计算根元素的font-size，这样的好处是所有设备分辨率都能兼容适配，淘宝首页目前就是用的JS计算。但其实不用JS我们也可以做适配，一般我们在做web app都会先统计自己网站有哪些主流的屏幕设备，然后去针对那些设备去做media query设置也可以实现适配，例如下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">    font-size : 20px;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 401px)&#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 25px !important;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 428px)&#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 26.75px !important;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 481px)&#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 30px !important; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 569px)&#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 35px !important; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 641px)&#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 40px !important; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的做的设置当然是不能所有设备全适配，但是用JS是可以实现全适配。具体用哪个就要根据自己的实际工作场景去定了。</p><p>下面推荐两个国内用了rem技术的移动站，大家可以上去参考看看他们的做法，手机淘宝目前只有首页用了rem，淘宝native app的首页是内嵌的web app首页。</p><p><strong>淘宝首页</strong>：m.taobao.com</p><p><strong>D X</strong>：m.dx.com</p><h3 id="最后我们再来看一看他的兼容性："><a href="#最后我们再来看一看他的兼容性：" class="headerlink" title="最后我们再来看一看他的兼容性："></a>最后我们再来看一看他的兼容性：</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pic.caibaojian.com/uploads/2015/12/1418894538.png" alt="1418894538" title="">                </div>                <div class="image-caption">1418894538</div>            </figure><h3 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h3><p>@blinkcat，rem是可以合并雪碧图的，viewport设置确实简洁，但是过于粗暴，全局都进行缩放，有时候我布局并不希望全局缩放，部分布局希望不用缩放，所以使用rem，不过具体使用什么方法大家都可以根据实际情况衡量。并不是每个人都喜欢使用sass，所以在px转rem这块我做了一个在线转换工具：<a href="http://520ued.com/tools/rem" target="_blank" rel="noopener">http://520ued.com/tools/rem</a></p><h3 id="REM自适应JS"><a href="#REM自适应JS" class="headerlink" title="REM自适应JS"></a>REM<a href="http://caibaojian.com/t/自适应" target="_blank" rel="noopener">自适应</a>JS</h3><p>具体使用方法请参考这篇文章：<a href="http://caibaojian.com/simple-flexible.html" target="_blank" rel="noopener">Rem精简版实现自适应-优化flexible.js</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//designWidth:设计稿的实际宽度值，需要根据实际设置</span><br><span class="line">//maxWidth:制作稿的最大宽度值，需要根据实际设置</span><br><span class="line">//这段js的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为750，最大宽度为750，则为(750,750)</span><br><span class="line">;(function(designWidth, maxWidth) &#123;</span><br><span class="line">var doc = document,</span><br><span class="line">win = window,</span><br><span class="line">docEl = doc.documentElement,</span><br><span class="line">remStyle = document.createElement(&quot;style&quot;),</span><br><span class="line">tid;</span><br><span class="line"></span><br><span class="line">function refreshRem() &#123;</span><br><span class="line">var width = docEl.getBoundingClientRect().width;</span><br><span class="line">maxWidth = maxWidth || 540;</span><br><span class="line">width&gt;maxWidth &amp;&amp; (width=maxWidth);</span><br><span class="line">var rem = width * 100 / designWidth;</span><br><span class="line">remStyle.innerHTML = &apos;html&#123;font-size:&apos; + rem + &apos;px;&#125;&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (docEl.firstElementChild) &#123;</span><br><span class="line">docEl.firstElementChild.appendChild(remStyle);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">var wrap = doc.createElement(&quot;div&quot;);</span><br><span class="line">wrap.appendChild(remStyle);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://caibaojian.com/web-app-rem.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://caibaojian.com/web-app-rem.html&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="html" scheme="https://tianjiec.top/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>vue脚手架各文件意义</title>
    <link href="https://tianjiec.top/2018/12/29/vue%E8%84%9A%E6%89%8B%E6%9E%B6%E5%90%84%E6%96%87%E4%BB%B6%E6%84%8F%E4%B9%89/"/>
    <id>https://tianjiec.top/2018/12/29/vue脚手架各文件意义/</id>
    <published>2018-12-29T02:40:36.000Z</published>
    <updated>2018-12-30T12:32:36.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue2全家桶之一：vue-cli（vue脚手架）超详细教程"><a href="#Vue2全家桶之一：vue-cli（vue脚手架）超详细教程" class="headerlink" title="Vue2全家桶之一：vue-cli（vue脚手架）超详细教程"></a>Vue2全家桶之一：vue-cli（vue脚手架）超详细教程</h1><blockquote><p>vue.js有著名的全家桶系列，包含了vue-router，vuex， vue-resource，再加上构建工具vue-cli，就是一个完整的vue项目的核心构成。</p></blockquote><h4 id="1-安装vue-cli"><a href="#1-安装vue-cli" class="headerlink" title="1.安装vue-cli"></a>1.安装vue-cli</h4><p><strong>①</strong> 使用npm（需要安装node环境）<strong>全局安装webpack</strong>，打开命令行工具输入：<code>npm install webpack -g</code>或者（<code>npm install -g webpack</code>），安装完成之后输入 <code>webpack -v</code>，如下图，如果出现相应的版本号，则说明安装成功。</p><p><strong>②</strong> <strong>全局安装vue-cli</strong>，在cmd中输入命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global vue-cli</span><br></pre></td></tr></table></figure><p>（我已经安装过，为了更直观我在电脑上重新演示下）</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-12cb0bef236c50fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/675/format/webp" alt="img"></p><p>安装成功：</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-ac2a13a62505d1ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/671/format/webp" alt="img"></p><p> 安装完成之后输入 vue -V（注意这里是大写的“V”），如下图，如果出现相应的版本号，则说明安装成功。</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-d8e864620a0b5aef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/292/format/webp" alt="img"></p><p>打开C:\Users\Andminster\AppData\Roaming\npm目录下可以看到：</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-9d5e131d9681c0d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/765/format/webp" alt="img"></p><p> 打开node_modules也可以看到：</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-6e55eb6b7d70ac91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550/format/webp" alt="img"></p><h4 id="2-用vue-cli来构建项目"><a href="#2-用vue-cli来构建项目" class="headerlink" title="2.用vue-cli来构建项目"></a>2.用vue-cli来构建项目</h4><p><strong>①</strong> 我首先在D盘新建一个文件夹（dxl_vue）作为项目存放地，然后使用命令行cd进入到项目目录输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack baoge</span><br></pre></td></tr></table></figure><p>baoge是自定义的项目名称，命令执行之后，会在当前目录生成一个以该名称命名的项目文件夹。</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-22cf1a5dc4cda33d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/659/format/webp" alt="img"></p><p>输入命令后，会跳出几个选项让你回答：</p><ul><li>Project name (baoge)：     —–项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，如果有会报错Sorry, name can no longer contain capital letters），阮一峰老师博客<a href="https://link.jianshu.com?t=http://www.ruanyifeng.com/blog/2017/02/filename-should-be-lowercase.html" target="_blank" rel="noopener">为什么文件名要小写</a> ，可以参考一下。</li><li>Project description (A Vue.js project)：  —-项目描述，也可直接点击回车，使用默认名字</li><li>Author ()：       —-作者，输入dongxili<br> 接下来会让用户选择：</li><li>Runtime + Compiler: recommended for most users    运行加编译，既然已经说了推荐，就选它了<br> Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere   仅运行时，已经有推荐了就选择第一个了</li><li>Install vue-router? (Y/n)    是否安装vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。</li><li>Use ESLint to lint your code? (Y/n)      是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。<br> 接下来也是选择题Pick an ESLint preset (Use arrow keys)            选择一个ESLint预设，编写vue项目时的代码风格，直接y回车</li><li>Setup unit tests with Karma + Mocha? (Y/n)  是否安装单元测试，我选择安装y回车</li><li>Setup e2e tests with Nightwatch(Y/n)?     是否安装e2e测试 ，我选择安装y回车</li></ul><p>回答完毕后上图就开始构建项目了。</p><p><strong>②</strong> 配置完成后，可以看到目录下多出了一个项目文件夹baoge，然后cd进入这个文件夹：<br> <strong>安装依赖</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p> ( 如果安装速度太慢。可以安装淘宝镜像，打开命令行工具，输入：<br>  <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code><br>  然后使用<code>cnpm</code>来安装 )</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-a5701c92e10ce959.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/664/format/webp" alt="img"></p><p>npm install ：安装所有的模块，如果是安装具体的哪个个模块，在install 后面输入模块的名字即可。而只输入install就会按照项目的根目录下的package.json文件中依赖的模块安装（这个文件里面是不允许有任何注释的），每个使用npm管理的项目都有这个文件，是npm操作的入口文件。因为是初始项目，还没有任何模块，所以我用npm install 安装所有的模块。安装完成后，目录中会多出来一个node_modules文件夹，这里放的就是所有依赖的模块。</p><p> 然后现在，baoge文件夹里的目录是这样的：</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-84cb6c247eba4438.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/615/format/webp" alt="img"></p><p> 解释下每个文件夹代表的意思(仔细看一下这张图）：</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-01a038fa573b22c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/443/format/webp" alt="img"></p><p>image.png</p><h4 id="3-启动项目"><a href="#3-启动项目" class="headerlink" title="3.启动项目"></a>3.启动项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p> 如果浏览器打开之后，没有加载出页面，有可能是本地的 8080 端口被占用，需要修改一下配置文件 config里的index.js</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-3a6a5874d3e8d445.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/596/format/webp" alt="img"></p><p>还有，如果本地调试项目时，建议将build 里的<code>assetsPublicPath</code>的路径前缀修改为 ‘ ./ ‘（开始是 ‘ / ‘），因为打包之后，外部引入 js 和 css 文件时，如果路径以 ‘ / ‘ 开头，在本地是无法找到对应文件的（服务器上没问题）。所以<strong>如果需要在本地打开打包后的文件</strong>，就得修改文件路径。<br> 我的端口没有被占用，直接成功（服务启动成功后浏览器会默认打开一个“欢迎页面”）：</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-77b13bb61a67b83f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p><p>注意：在进行vue页面调试时，一定要去谷歌商店下载一个vue-tool扩展程序。</p><h4 id="4-vue-cli的webpack配置分析"><a href="#4-vue-cli的webpack配置分析" class="headerlink" title="4.vue-cli的webpack配置分析"></a>4.vue-cli的webpack配置分析</h4><ul><li><p>从</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package.json</span><br></pre></td></tr></table></figure><p>可以看到开发和生产环境的入口。</p></li></ul><p>  <img src="https:////upload-images.jianshu.io/upload_images/10868449-255932a94e033291.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/775/format/webp" alt="img"></p><ul><li><p>可以看到dev中的设置，<strong>build/webpack.dev.conf.js</strong>，该文件是开发环境中webpack的配置入口。</p></li><li><p>在webpack.dev.conf.js中出现<strong>webpack.base.conf.js</strong>，这个文件是开发环境和生产环境，甚至测试环境，这些环境的公共webpack配置。可以说，这个文件相当重要。</p></li><li><p>还有<strong>config/index.js 、build/utils.js  、build/build.js</strong>等，具体请看这篇介绍：<br> <a href="https://link.jianshu.com?t=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000008644830" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008644830</a> </p></li></ul><h4 id="5-打包上线"><a href="#5-打包上线" class="headerlink" title="5.打包上线"></a>5.打包上线</h4><p>注意，自己的项目文件都需要放到 src 文件夹下。<br> 在项目开发完成之后，可以输入 <code>npm run build</code> 来进行打包工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>另：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.npm 开启了npm run dev以后怎么退出或关闭？</span><br><span class="line">ctrl+c</span><br><span class="line">2.--save-dev</span><br><span class="line">自动把模块和版本号添加到模块配置文件package.json中的依赖里devdependencies部分</span><br><span class="line">3. --save-dev 与 --save 的区别</span><br><span class="line">--save     安装包信息将加入到dependencies（生产阶段的依赖）</span><br><span class="line">--save-dev 安装包信息将加入到devDependencies（开发阶段的依赖），所以开发阶段一般使用它</span><br></pre></td></tr></table></figure><p>打包完成后，会生成 dist 文件夹，如果已经修改了文件路径，可以直接打开本地文件查看。<br> 项目上线时，只需要将 dist 文件夹放到服务器就行了。</p><p>好了，史上最详细版vue2脚手架出炉了，由于是全家桶第一篇，所以过于详细，后面我只会写关键步骤，多加入点实例。[微笑]</p><p>作者：东西里</p><p>链接：<a href="https://www.jianshu.com/p/32beaca25c0d" target="_blank" rel="noopener">https://www.jianshu.com/p/32beaca25c0d</a></p><p>來源：简书</p><p>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue2全家桶之一：vue-cli（vue脚手架）超详细教程&quot;&gt;&lt;a href=&quot;#Vue2全家桶之一：vue-cli（vue脚手架）超详细教程&quot; class=&quot;headerlink&quot; title=&quot;Vue2全家桶之一：vue-cli（vue脚手架）超详细教程&quot;&gt;
      
    
    </summary>
    
    
      <category term="vue" scheme="https://tianjiec.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>package.json理解</title>
    <link href="https://tianjiec.top/2018/12/29/package-json%E7%90%86%E8%A7%A3/"/>
    <id>https://tianjiec.top/2018/12/29/package-json理解/</id>
    <published>2018-12-29T02:39:22.000Z</published>
    <updated>2018-12-30T12:39:08.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对package-json的理解和学习"><a href="#对package-json的理解和学习" class="headerlink" title="对package.json的理解和学习"></a><a href="https://www.cnblogs.com/whkl-m/p/6617540.html" target="_blank" rel="noopener">对package.json的理解和学习</a></h1><p><strong>一、初步理解</strong></p><p>\1. npm安装package.json时  直接转到当前项目目录下用命令npm install 或npm install –save-dev安装即可，自动将package.json中的模块安装到node-modules文件夹下</p><p>\2. package.json 中添加中文注释会编译出错</p><p>\3. 每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install 命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。</p><p>\4. package.json文件可以手工编写，也可以使用<strong>npm init</strong>命令自动生成。</p><p>注意：npm init 时，用户需回答一些问题，然后在当前目录生成一个基本的package.json文件。所有问题之中，只有项目名称（name）和项目版本（version）是必填的，其他都是选填的。</p><p><strong>二、进一步理解 （完整的字段说明：<a href="http://www.mujiang.info/translation/npmjs/files/package.json.html" target="_blank" rel="noopener">http://www.mujiang.info/translation/npmjs/files/package.json.html</a>  中文版）</strong></p><p>以下是根据 创建vue项目的时候 npm init自动生成的package.json做详细的理解</p><p>1.下面是最简单的的一个package.json 文件（只有两个数据，项目名称和项目版本，他们都是必须的，如果没有就无法install）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&#123;``  ``&quot;name&quot;``: ``&quot;kocla_test&quot;``,``  ``&quot;version&quot;``: ``&quot;1.0.0&quot;``,``&#125;`</span><br></pre></td></tr></table></figure><p>2.scripts</p><p>指定了运行脚本命令的npm命令行缩写，比如start指定了运行npm run start时，所要执行的命令。</p><p>下面的设置指定了npm run dev、npm run bulid、npm run unit、npm run test<em>、npm run lint</em>时，所要执行的命令。　</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`"scripts"`</span><span class="string">`: &#123;`</span><span class="string">`    `</span><span class="string">`"dev"`</span><span class="string">`: `</span><span class="string">`"node build/dev-server.js"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"build"`</span><span class="string">`: `</span><span class="string">`"node build/build.js"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"unit"`</span><span class="string">`: `</span><span class="string">`"cross-env BABEL_ENV=test karma start test/unit/karma.conf.js --single-run"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"test"`</span><span class="string">`: `</span><span class="string">`"npm run unit"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"lint"`</span><span class="string">`: `</span><span class="string">`"eslint --ext .js,.vue src test/unit/specs"`</span><span class="string">`  `</span><span class="string">`&#125;,`</span></span><br></pre></td></tr></table></figure><h3 id="3-dependencies，devDependencies"><a href="#3-dependencies，devDependencies" class="headerlink" title="3  dependencies，devDependencies"></a>3  <em>dependencies，devDependencies</em></h3><h6 id="dependencies和devDependencies两项，分别指定了项目运行所依赖的模块、项目开发所需要的模块。它们都指向一个对象，该对象的各个成员，分别由模块名和对应的版本要去组成，表示依赖的模块及其版本范围"><a href="#dependencies和devDependencies两项，分别指定了项目运行所依赖的模块、项目开发所需要的模块。它们都指向一个对象，该对象的各个成员，分别由模块名和对应的版本要去组成，表示依赖的模块及其版本范围" class="headerlink" title="dependencies和devDependencies两项，分别指定了项目运行所依赖的模块、项目开发所需要的模块。它们都指向一个对象，该对象的各个成员，分别由模块名和对应的版本要去组成，表示依赖的模块及其版本范围"></a>dependencies和devDependencies两项，分别指定了项目运行所依赖的模块、项目开发所需要的模块。它们都指向一个对象，该对象的各个成员，分别由模块名和对应的版本要去组成，表示依赖的模块及其版本范围</h6><h6 id="–save参数表示将该模块写入dependencies属性，"><a href="#–save参数表示将该模块写入dependencies属性，" class="headerlink" title="–save参数表示将该模块写入dependencies属性，"></a>–save参数表示将该模块写入dependencies属性，</h6><h6 id="–save-dev表示将该模块写入devDependencies属性。"><a href="#–save-dev表示将该模块写入devDependencies属性。" class="headerlink" title="–save-dev表示将该模块写入devDependencies属性。"></a>–save-dev表示将该模块写入devDependencies属性。</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`"dependencies"`</span><span class="string">`: &#123;`</span><span class="string">`    `</span><span class="string">`"vue"`</span><span class="string">`: `</span><span class="string">`"^2.2.2"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"vue-router"`</span><span class="string">`: `</span><span class="string">`"^2.2.0"`</span><span class="string">`  `</span><span class="string">`&#125;,`</span><span class="string">`  `</span><span class="string">`"devDependencies"`</span><span class="string">`: &#123;`</span><span class="string">`    `</span><span class="string">`"autoprefixer"`</span><span class="string">`: `</span><span class="string">`"^6.7.2"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"babel-core"`</span><span class="string">`: `</span><span class="string">`"^6.22.1"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"babel-eslint"`</span><span class="string">`: `</span><span class="string">`"^7.1.1"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"babel-loader"`</span><span class="string">`: `</span><span class="string">`"^6.2.10"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"babel-plugin-transform-runtime"`</span><span class="string">`: `</span><span class="string">`"^6.22.0"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"babel-preset-env"`</span><span class="string">`: `</span><span class="string">`"^1.2.1"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"babel-preset-stage-2"`</span><span class="string">`: `</span><span class="string">`"^6.22.0"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"babel-register"`</span><span class="string">`: `</span><span class="string">`"^6.22.0"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"chalk"`</span><span class="string">`: `</span><span class="string">`"^1.1.3"`</span><span class="string">`,`</span><span class="string">`&#125;`</span></span><br></pre></td></tr></table></figure><h2 id="4、config字段"><a href="#4、config字段" class="headerlink" title="4、config字段"></a>4、config字段</h2><p>config字段用于向环境变量输出值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`&#123; `</span><span class="string">`  `</span><span class="string">`"name"`</span> <span class="string">`: `</span><span class="string">`"foo"`</span><span class="string">`, `</span><span class="string">`  `</span><span class="string">`"config"`</span> <span class="string">`: &#123; `</span><span class="string">`"port"`</span> <span class="string">`: `</span><span class="string">`"8080"`</span> <span class="string">`&#125;, `</span><span class="string">`  `</span><span class="string">`"scripts"`</span> <span class="string">`: &#123; `</span><span class="string">`"start"`</span> <span class="string">`: `</span><span class="string">`"node server.js"`</span> <span class="string">`&#125; `</span><span class="string">`&#125; `</span></span><br></pre></td></tr></table></figure><p>　　</p><p>5.engines 字段</p><p>指明了该项目所需要的node.js版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&quot;engines&quot;``: &#123;``   ``&quot;node&quot;``: ``&quot;&gt;= 4.0.0&quot;``,``   ``&quot;npm&quot;``: ``&quot;&gt;= 3.0.0&quot;`` ``&#125;,`</span><br></pre></td></tr></table></figure><p>　　</p><p><strong>6.bin</strong></p><p>许多包有一个或多个可执行文件希望被安装到系统路径。在npm下要这么做非常容易(事实上，npm就是这么运行的)。</p><p>这需要在你的package.json中提供一个bin字段，它是一个命令名和本地文件名的映射。在安装时，如果是全局安装，npm将会使用符号链接把这些文件链接到prefix/bin，如果是本地安装，会链接到./node_modules/.bin/。</p><p>比如，要使用myapp作为命令时可以这么做：</p><h3 id="“bin”-“myapp”-“-cli-js”"><a href="#“bin”-“myapp”-“-cli-js”" class="headerlink" title="{ “bin” : { “myapp” : “./cli.js” } }"></a>{ “bin” : { “myapp” : “./cli.js” } }</h3><p>这么一来，当你安装myapp，npm会从cli.js文件创建一个到/usr/local/bin/myapp的符号链接(这使你可以直接在命令行执行myapp)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对package-json的理解和学习&quot;&gt;&lt;a href=&quot;#对package-json的理解和学习&quot; class=&quot;headerlink&quot; title=&quot;对package.json的理解和学习&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>函数加不加括号的区别</title>
    <link href="https://tianjiec.top/2018/12/28/%E5%87%BD%E6%95%B0%E5%8A%A0%E4%B8%8D%E5%8A%A0%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://tianjiec.top/2018/12/28/函数加不加括号的区别/</id>
    <published>2018-12-28T12:10:53.000Z</published>
    <updated>2018-12-28T12:17:50.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于vue-，v-on-绑定事件时，函数名加括号和不加括号的区别"><a href="#关于vue-，v-on-绑定事件时，函数名加括号和不加括号的区别" class="headerlink" title="关于vue ，v-on 绑定事件时，函数名加括号和不加括号的区别"></a><a href="https://www.cnblogs.com/huqiuwei/p/6401851.html" target="_blank" rel="noopener">关于vue ，v-on 绑定事件时，函数名加括号和不加括号的区别</a></h2><p>从官方的文档 <a href="https://link.zhihu.com/?target=https%3A//vuefe.cn/v2/guide/events.html" target="_blank" rel="noopener">事件处理器 — Vue.js</a> 中可以看出通过 <code>v-on</code> 中既可以执行一段代码、一个方法、内联 JavaScript 语句，根据不同的情况 Vue 会做不同的处理，具体可以从源码中可以看出（2.1.10版本），在编译阶段，会根据抽象HTML语法树生成代码，从 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/codegen/index.js%23L194" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/v2.1.10/src/compiler/codegen/index.js#L194</a> 可以看出如果此时包含了事件处理，则会调用 <code>genHandlers</code> 生成事件处理代码，最终走到 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/codegen/events.js%23L46" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/v2.1.10/src/compiler/codegen/events.js#L46</a> ，这里有两个正则判断，判断是函数正则以及属性访问正则，如果两个正则匹配成功则直接返回当前的值，否则用 <code>function($event){${handler.value}}</code> 包裹一次。 针对于你的疑问来说，如果说你是直接给定的 <code>greet</code> 的话，则属性访问正则匹配成功，如果是<code>greet()</code> 或者 <code>x+=1</code> 来说，则两个正则都匹配失败，利用函数包裹一层；而额外的第一种判断函数的正则则只有是你写的是函数的时候才会匹配成功，也就是类似于 <code>function () {xxx}</code> 或者 <code>() =&gt; dsf</code> 也就是一个匿名函数或者箭头函数。</p><p>最后，到底需不需要加括号的话，一般就是要看参数的情况了： 1、不需要参数或者默认参数的情况下，用一个定义的方法名即可。此时有一个需要注意的就是默认参数的情况，对于原生的事件处理的话，参数就只有一个：事件对象event；而对于自定义事件的话，则是在 emit 的时候传入的参数是什么，这个定义的方法被调用的时候的参数也是一一对应的。 2、自定义参数，这个参数有可能是你在HTML上直接写的<code>greet(&#39;xx&#39;)</code>，也有可能是在特殊上下文中得到的，例如说在 <code>v-for</code> 内部，可以传入当前循环项；这种情况下则是当一段代码片段来执行的，此时正是因为包裹的函数是有<code>$event</code>参数的，所以可以使用这个；你可能还会发现此时还可以这样写：<code>greet(arguments)</code>，传入的就是<code>arguments</code>对象，把调用定义方法的参数在形式上是可以由多个变为一个的。</p><p>函数名其实就是指向函数体的指针 </p><p>不加括号， 可以认为是查看该函数的完整信息， </p><p>不加括号传参，相当于传入函数整体 </p><p>加括号 表示立即调用（执行）这个函数里面的代码（花括号部分的代码）</p><p>应该是 Vue 对函数调用表达式额外用了一个函数做了层包装。<br>加与不加括号的区别在于事件对象参数 event 的处理。不加括号时，函数第一个参数为 event，加了括号后，需要手动传入 $event 才能获得事件对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"click($event)"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line"><span class="undefined">            methods: &#123;</span></span><br><span class="line"><span class="undefined">                click(e)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(e)</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于vue-，v-on-绑定事件时，函数名加括号和不加括号的区别&quot;&gt;&lt;a href=&quot;#关于vue-，v-on-绑定事件时，函数名加括号和不加括号的区别&quot; class=&quot;headerlink&quot; title=&quot;关于vue ，v-on 绑定事件时，函数名加括号和不加括
      
    
    </summary>
    
    
      <category term="vue" scheme="https://tianjiec.top/tags/vue/"/>
    
  </entry>
  
</feed>
