<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chentj&#39;s Blog</title>
  
  <subtitle>Inflexible thinking, bad humor</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tianjiec.top/"/>
  <updated>2018-12-28T09:52:55.595Z</updated>
  <id>https://tianjiec.top/</id>
  
  <author>
    <name>chentj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>swiper-component</title>
    <link href="https://tianjiec.top/2018/12/28/swiper-component/"/>
    <id>https://tianjiec.top/2018/12/28/swiper-component/</id>
    <published>2018-12-28T09:40:07.000Z</published>
    <updated>2018-12-28T09:52:55.595Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.swiper.com.cn/" target="_blank" rel="noopener">https://www.swiper.com.cn/</a></p><h2 id="Swiper常用于移动端网站的内容触摸滑动"><a href="#Swiper常用于移动端网站的内容触摸滑动" class="headerlink" title="Swiper常用于移动端网站的内容触摸滑动"></a>Swiper常用于移动端网站的内容触摸滑动</h2><h3 id="Swiper4-x使用方法"><a href="#Swiper4-x使用方法" class="headerlink" title="Swiper4.x使用方法"></a>Swiper4.x使用方法</h3><p>1.首先加载插件，需要用到的文件有swiper.min.js和swiper.min.css文件。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./swiper.min.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./swiper.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./base/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue-resource/1.5.1/vue-resource.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">my-banner</span>&gt;</span><span class="tag">&lt;/<span class="name">my-banner</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"my-banner"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        //2.HTML内容。</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-container banner"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-wrapper"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">v-for</span>=<span class="string">"banner in banners"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">:key</span>=<span class="string">"banner.id"</span></span></span><br><span class="line"><span class="tag">                &gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">:src</span>=<span class="string">"banner.image"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果需要分页器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-pagination"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;div&gt;&lt;input type="text" v-model="msg" name="" id=""&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//全局注册组件my-banner</span></span></span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">"my-banner"</span>,&#123;</span></span><br><span class="line"><span class="javascript">            template:<span class="string">"#my-banner"</span>,</span></span><br><span class="line"><span class="undefined">            data()&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="undefined">                    banners:[],</span></span><br><span class="line"><span class="javascript">                    msg:<span class="string">""</span></span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            methods:&#123;</span></span><br><span class="line"><span class="undefined">                getBanners()&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.$http.get(<span class="string">"./banners.json"</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                       <span class="comment">//console.log(res.body.bannerList)</span></span></span><br><span class="line"><span class="javascript">                        <span class="keyword">this</span>.banners = res.body.bannerList; </span></span><br><span class="line"><span class="undefined">                        </span></span><br><span class="line"><span class="javascript">                        <span class="comment">//4.初始化Swiper：最好是挨着&lt;/body&gt;标签</span></span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> mySwiper = <span class="keyword">new</span> Swiper (<span class="string">'.swiper-container'</span>, &#123;</span></span><br><span class="line"><span class="javascript">                            direction: <span class="string">'vertical'</span>, <span class="comment">// 垂直切换选项</span></span></span><br><span class="line"><span class="javascript">                            loop: <span class="literal">true</span>, <span class="comment">// 循环模式选项</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">                            <span class="comment">// 如果需要分页器</span></span></span><br><span class="line"><span class="undefined">                            pagination: &#123;</span></span><br><span class="line"><span class="javascript">                              el: <span class="string">'.swiper-pagination'</span>,</span></span><br><span class="line"><span class="undefined">                            &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">                            <span class="comment">// 如果需要前进后退按钮</span></span></span><br><span class="line"><span class="undefined">                            navigation: &#123;</span></span><br><span class="line"><span class="javascript">                              nextEl: <span class="string">'.swiper-button-next'</span>,</span></span><br><span class="line"><span class="javascript">                              prevEl: <span class="string">'.swiper-button-prev'</span>,</span></span><br><span class="line"><span class="undefined">                            &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">                            <span class="comment">// 如果需要滚动条</span></span></span><br><span class="line"><span class="undefined">                            scrollbar: &#123;</span></span><br><span class="line"><span class="javascript">                              el: <span class="string">'.swiper-scrollbar'</span>,</span></span><br><span class="line"><span class="undefined">                            &#125;,</span></span><br><span class="line"><span class="undefined">                         &#125;)        </span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">               &#125;</span></span><br><span class="line"><span class="undefined">           &#125;,</span></span><br><span class="line"><span class="undefined">           created()&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.getBanners()</span></span><br><span class="line"><span class="undefined">           &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span></span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.swiper.com.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.swiper.com.cn/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Swiper常用于移动端网站的内容触摸滑动&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="vue swiper" scheme="https://tianjiec.top/tags/vue-swiper/"/>
    
  </entry>
  
  <entry>
    <title>setTimeout</title>
    <link href="https://tianjiec.top/2018/12/28/setTimeout/"/>
    <id>https://tianjiec.top/2018/12/28/setTimeout/</id>
    <published>2018-12-28T08:04:23.000Z</published>
    <updated>2018-12-28T09:38:58.198Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇的文章中介绍了js异步原理，有的小伙伴可能还有些云里雾里，在本篇文章中将以新手很容易用错的setTimeout为例来解释js的异步原理。</p><p>首先我们看一个例子</p><script>  console.log(1);  setTimeout(function(){    console.log(2);  },500);  console.log(3);  // 运行结果  // 1  // 3  // 2</script><p>这里通过setTimeout延迟500毫秒执行，所以结果是1，3，2。这看起来明明就是异步操作啊，为什么说是同步呢？我们接着看下一个例子。</p><script>  var date = new Date();  console.log('first time: ' + date.getTime());  setTimeout(function(){      var date1 = new Date();      console.log('second time: ' + date1.getTime() );      console.log( date1.getTime() - date.getTime() );  },1000);  for(var i=0; i < 10000 ; i++){      console.log(1);  }  // 运行结果  // first time: 1524540272462  // （10000）1  // second time: 1524540274346  // 1884</script><p>神奇的事情出现了，假设js是异步，那么结果应该是这样的：<br>// first time: 1524540272462</p><p>//（x）1</p><p>// second time: 1524540273462</p><p>// 1000</p><p>//（10000-x）1</p><p>x为一秒内打印的1的数量。</p><p>但是实际结果settimeout并非是1000毫秒后执行的，而是1884毫秒。其原因是js是单线程，在打印完first time: 1524540272462后settimeout内的操作进入了“任务队列”，而1000毫秒到了以后，因为当前js正在执行打印1的操作，故js会在1打印完之后，才将settimeout内操作压进执行栈里。所以实际上我们看到的结果1884毫秒的原因就在于次。</p><p>这个例子说明js仍旧是单线程而非多线程，在同一时间内js只能做一件事情。</p><p>下面我们通过下面的简单例子也能够看出js是单线程的。</p><script>  console.log('1');  setTimeout(function(){      console.log('2');  },10);  while(true){};  // 运行结果  // 1</script><p>浏览器打印出1后就卡死了，并没有打印出2来。因为执行栈必须把当前任务完成，任务队列里的操作才能进入执行栈。而执行栈内的操作是死循环，所以浏览器卡死，2也不会被打印出来。</p><p>下面来看一种特殊情况，当setTimeout的时间为0的时候是不是立即执行的。</p><p>  console.log(1);<br>  setTimeout(function(){<br>​      console.log(2);<br>  },0);<br>  console.log(3);<br>  // 运行结果<br>  // 1<br>  // 3<br>  // 2</p><p>结果证明即便延迟设为0，也不是立即执行的。因为setTimeout有一个最小执行时间，当指定的时间小于该时间时，浏览器会用最小允许的时间作为setTimeout的时间间隔，也就是说即使我们把setTimeout的毫秒数设置为0，被调用的程序也没有马上启动。</p><h6 id="setTimeout的最小时间间隔和浏览器及操作系统有关。在John-Resig的《Javascript忍者的秘密》一书中提到–Browsers-all-have-a-10ms-minimum-delay-on-OSX-and-a-approximately-15ms-delay-on-Windows-（在苹果机上的最小时间间隔是10毫秒，在Windows系统上的最小时间间隔大约是15毫秒），另外，MDC中关于setTimeout的介绍中也提到，Firefox中定义的最小时间间隔（DOM-MIN-TIMEOUT-VALUE）是10毫秒，HTML5定义的最小时间间隔是4毫秒。"><a href="#setTimeout的最小时间间隔和浏览器及操作系统有关。在John-Resig的《Javascript忍者的秘密》一书中提到–Browsers-all-have-a-10ms-minimum-delay-on-OSX-and-a-approximately-15ms-delay-on-Windows-（在苹果机上的最小时间间隔是10毫秒，在Windows系统上的最小时间间隔大约是15毫秒），另外，MDC中关于setTimeout的介绍中也提到，Firefox中定义的最小时间间隔（DOM-MIN-TIMEOUT-VALUE）是10毫秒，HTML5定义的最小时间间隔是4毫秒。" class="headerlink" title="setTimeout的最小时间间隔和浏览器及操作系统有关。在John Resig的《Javascript忍者的秘密》一书中提到–Browsers all have a 10ms minimum delay on OSX and a(approximately) 15ms delay on Windows.（在苹果机上的最小时间间隔是10毫秒，在Windows系统上的最小时间间隔大约是15毫秒），另外，MDC中关于setTimeout的介绍中也提到，Firefox中定义的最小时间间隔（DOM_MIN_TIMEOUT_VALUE）是10毫秒，HTML5定义的最小时间间隔是4毫秒。"></a>setTimeout的最小时间间隔和浏览器及操作系统有关。在John Resig的《Javascript忍者的秘密》一书中提到–Browsers all have a 10ms minimum delay on OSX and a(approximately) 15ms delay on Windows.（在苹果机上的最小时间间隔是10毫秒，在Windows系统上的最小时间间隔大约是15毫秒），另外，MDC中关于setTimeout的介绍中也提到，Firefox中定义的最小时间间隔（DOM_MIN_TIMEOUT_VALUE）是10毫秒，HTML5定义的最小时间间隔是4毫秒。</h6><h6 id="作者：Tomhs3000"><a href="#作者：Tomhs3000" class="headerlink" title="作者：Tomhs3000"></a>作者：Tomhs3000</h6><p>来源：CSDN<br>原文：<a href="https://blog.csdn.net/Tomhs3000/article/details/80061501" target="_blank" rel="noopener">https://blog.csdn.net/Tomhs3000/article/details/80061501</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一篇的文章中介绍了js异步原理，有的小伙伴可能还有些云里雾里，在本篇文章中将以新手很容易用错的setTimeout为例来解释js的异步原理。&lt;/p&gt;
&lt;p&gt;首先我们看一个例子&lt;/p&gt;
&lt;script&gt;
  console.log(1);
  setTimeout(fun
      
    
    </summary>
    
    
      <category term="js" scheme="https://tianjiec.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>实例生命周期钩子</title>
    <link href="https://tianjiec.top/2018/12/28/%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/"/>
    <id>https://tianjiec.top/2018/12/28/实例生命周期钩子/</id>
    <published>2018-12-28T01:59:32.000Z</published>
    <updated>2018-12-28T03:46:46.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实例生命周期钩子"><a href="#实例生命周期钩子" class="headerlink" title="实例生命周期钩子"></a>实例生命周期钩子</h1><blockquote><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p></blockquote><p>比如 <a href="https://cn.vuejs.org/v2/api/#created" target="_blank" rel="noopener"><code>created</code></a> 钩子可以用来在一个实例被创建之后执行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a is: '</span> + <span class="keyword">this</span>.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt; "a is: 1"</span></span><br></pre></td></tr></table></figure><p>也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 <a href="https://cn.vuejs.org/v2/api/#mounted" target="_blank" rel="noopener"><code>mounted</code></a>、<a href="https://cn.vuejs.org/v2/api/#updated" target="_blank" rel="noopener"><code>updated</code></a> 和 <a href="https://cn.vuejs.org/v2/api/#destroyed" target="_blank" rel="noopener"><code>destroyed</code></a>。生命周期钩子的 <code>this</code> 上下文指向调用它的 Vue 实例。</p><p>ps:</p><blockquote><p>不要在选项属性或回调上使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>，比如 <code>created: () =&gt; console.log(this.a)</code> 或 <code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code>。因为箭头函数是和父级上下文绑定在一起的，<code>this</code> 不会是如你所预期的 Vue 实例，经常导致 <code>Uncaught TypeError: Cannot read property of undefined</code>或 <code>Uncaught TypeError: this.myMethod is not a function</code>之类的错误</p></blockquote><h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">生命周期图示</a></h2><p>下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。</p><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue 实例生命周期"></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>每个 Vue 实例在从创建到销毁的一系列过程，</p><p>vue在整个生命周期中为我们提供了很多的一些钩子函数</p><p>钩子函数特点就是会在生命周期某一时刻进行触发。</p><blockquote><p>组件从创建到销毁的一系列过程就叫做组建的生命周期</p><p>vue在整个生命周期中为我们提供了很多的一些钩子函数</p><p>钩子函数的特点就是会在生命周期某一时刻进行触发</p><p><strong>组件的生命周期可以分为三个过程</strong> </p><p><strong>初始化、运行中、 销毁</strong></p><p><strong>初始化阶段</strong>：beforeCreate、 created、beforeMount、mounted</p><p><strong>运行中阶段</strong>：beforeUpdate、updated</p><p><strong>销毁阶段</strong>：beforeDestory、destoryed</p><p>初始化阶段</p><p>1、一个示例/组件的生命周期是从new 开始</p><p>2、实例化之后，会初始化一些事件和生命周期相关的配置</p></blockquote><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">"my-component"</span>,&#123;</span><br><span class="line">template: <span class="string">"#my-component"</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            message: <span class="string">"component"</span>,</span><br><span class="line">            num: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        destory()&#123;</span><br><span class="line">            <span class="keyword">this</span>.$destory();<span class="comment">//销毁组件/实例</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//初始化阶段</span></span><br><span class="line">    <span class="comment">//1.一个组件的生命周期是从new开始</span></span><br><span class="line">    <span class="comment">//2.实例化之后，会初始化一些事件和生命周期相关的配置</span></span><br><span class="line">    beforeCreate()&#123;</span><br><span class="line">       <span class="comment">//3.在这里，数据还没有进行挂载，dom也没有进行渲染。此钩子函数基本无用</span></span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">     <span class="comment">//4.在这里，数据已经挂载完毕，但是dom还是没有进行渲染</span></span><br><span class="line">         <span class="comment">//在这个函数里面，如果同步的更改数据，则不会触发其他运行中钩子函数的执行</span></span><br><span class="line">         <span class="comment">//做一些初始化数据的配置  掉接口就可以在这里写</span></span><br><span class="line">        <span class="keyword">this</span>.message = <span class="keyword">this</span>.message.toUpperCase();</span><br><span class="line">        <span class="comment">//想要this.num进行累计操作</span></span><br><span class="line">        <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">1111</span>)</span><br><span class="line">            <span class="keyword">this</span>.num++</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//ps：</span></span><br><span class="line">        <span class="comment">//同步：执行完这些代码之后才会继续向后执行</span></span><br><span class="line">        <span class="comment">//异步：此处继续执行，但后面的代码也继续执行，不阻塞</span></span><br><span class="line">        <span class="comment">//此处为一示例</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">window</span>.onscroll = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">111111111</span>)</span><br><span class="line">            <span class="keyword">this</span>.num++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//接下来过程是我们的组建或实例去查找对应的模板，然后将编译成虚拟dom放入rander函数中</span></span><br><span class="line">    beforeMount()&#123;</span><br><span class="line">        <span class="comment">//5代表dom马上将要被渲染，但是还没有真正的渲染出来！</span></span><br><span class="line">        <span class="comment">//做一些初始化数据的配置</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"beforeMount"</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.message, <span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// render()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log(11111111)</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    mounted()&#123;</span><br><span class="line">        <span class="comment">//6.当mounted执行完毕的时候，说明组件生命周期的初始化阶段已经结束了</span></span><br><span class="line">        <span class="comment">//这个函数是初始化阶段的最后一个函数，在这里可以获取到真实dom结构</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"mounted"</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.message, <span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeUpdate()&#123;</span><br><span class="line">        <span class="comment">//7.这里数据刚刚更改，dom还是没有进行渲染</span></span><br><span class="line">        <span class="comment">//在这个钩子函数里面，我们不会做任何的操作</span></span><br><span class="line">        <span class="comment">//this.message+=2;</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"beforeUpdate"</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>).innerHTML)</span><br><span class="line">    &#125;,</span><br><span class="line">    updated()&#123;</span><br><span class="line">        <span class="comment">//8在这里可以获取到更新之后的dom,我们不会做任何的操作</span></span><br><span class="line">        <span class="comment">//当数据更改之后，引起dom重新渲染之后，此钩子函数才会执行</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"updated"</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>).innerHTML)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy()&#123;</span><br><span class="line">        <span class="comment">//组件即将要被销毁，但是还没有被销毁</span></span><br><span class="line">        <span class="comment">//在这个钩子函数里面，我们可以做一些善后的操作</span></span><br><span class="line">        <span class="comment">//例如清空定时器、清空绑定的事件</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"beforeDestroy"</span>)</span><br><span class="line">        clearInterval(<span class="keyword">this</span>.timer)</span><br><span class="line">        <span class="built_in">window</span>.onscroll = <span class="literal">null</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed()&#123;</span><br><span class="line">        <span class="comment">//组件已经被销毁了，生命周期已经结束了！</span></span><br><span class="line">        <span class="comment">//组件把数据绑定、事件监听都给去掉，但是组件的dom结构还是存在的！</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"destroyed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">new</span> Vue(&#123;&#125;).$mount(<span class="string">"#app"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实例生命周期钩子&quot;&gt;&lt;a href=&quot;#实例生命周期钩子&quot; class=&quot;headerlink&quot; title=&quot;实例生命周期钩子&quot;&gt;&lt;/a&gt;实例生命周期钩子&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需
      
    
    </summary>
    
    
      <category term="vue" scheme="https://tianjiec.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>组件传值</title>
    <link href="https://tianjiec.top/2018/12/27/%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    <id>https://tianjiec.top/2018/12/27/组件传值/</id>
    <published>2018-12-27T08:21:14.000Z</published>
    <updated>2018-12-27T12:58:46.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="父组件——》子组件"><a href="#父组件——》子组件" class="headerlink" title="父组件——》子组件"></a>父组件——》子组件</h2><p>在父组件 global</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是父组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message.value"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>message: &#123;&#123;message.value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">son</span> <span class="attr">:message</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件 通过props 属性 获取到 父组件闯过来的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">"son"</span>, &#123;</span><br><span class="line">    template: <span class="string">"#son"</span>,</span><br><span class="line">    props:[<span class="string">"message"</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>local：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line">    son:&#123;</span><br><span class="line">        props:[<span class="string">"parentSky"</span>],</span><br><span class="line">            template:<span class="string">"#son"</span>,</span><br><span class="line">                data()&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    sonColor:<span class="string">"red"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            computed:&#123;</span><br><span class="line">               ownColor:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">this</span>.parentSky+<span class="keyword">this</span>.sonColor;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单项数据流："><a href="#单项数据流：" class="headerlink" title="单项数据流："></a>单项数据流：</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<strong>不</strong>应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p><blockquote><p><strong>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。</strong></p></blockquote><p>父组件向子组件传对象 子组件 也可以操作父组件数据</p><p>违背了单项数据流 不推荐使用</p><h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><h2 id="Prop-的大小写-camelCase-vs-kebab-case"><a href="#Prop-的大小写-camelCase-vs-kebab-case" class="headerlink" title="Prop 的大小写 (camelCase vs kebab-case)"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99-camelCase-vs-kebab-case" target="_blank" rel="noopener">Prop 的大小写 (camelCase vs kebab-case)</a></h2><p>HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;blog-post&apos;, &#123;</span><br><span class="line">  // 在 JavaScript 中是 camelCase 的</span><br><span class="line">  props: [&apos;postTitle&apos;],</span><br><span class="line">  template: &apos;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;</span><br><span class="line">&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure><p>重申一次，如果你使用字符串模板，那么这个限制就不存在了。</p><h2 id="Prop-类型"><a href="#Prop-类型" class="headerlink" title="Prop 类型"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">Prop 类型</a></h2><p>到这里，我们只看到了以字符串数组形式列出的 prop：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [&apos;title&apos;, &apos;likes&apos;, &apos;isPublished&apos;, &apos;commentIds&apos;, &apos;author&apos;]</span><br></pre></td></tr></table></figure><p>但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些属性的名称和值分别是 prop 各自的名称和类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: String,</span><br><span class="line">  likes: Number,</span><br><span class="line">  isPublished: Boolean,</span><br><span class="line">  commentIds: Array,</span><br><span class="line">  author: Object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不仅为你的组件提供了文档，还会在它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户。你会在这个页面接下来的部分看到<a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener">类型检查和其它 prop 验证</a>。</p><h2 id="传递静态或动态-Prop"><a href="#传递静态或动态-Prop" class="headerlink" title="传递静态或动态 Prop"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#%E4%BC%A0%E9%80%92%E9%9D%99%E6%80%81%E6%88%96%E5%8A%A8%E6%80%81-Prop" target="_blank" rel="noopener">传递静态或动态 Prop</a></h2><p>像这样，你已经知道了可以像这样给 prop 传入一个静态的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure><p>你也知道 prop 可以通过 <code>v-bind</code> 动态赋值，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 动态赋予一个变量的值 --&gt;</span><br><span class="line">&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态赋予一个复杂表达式的值 --&gt;</span><br><span class="line">&lt;blog-post v-bind:title=&quot;post.title + &apos; by &apos; + post.author.name&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure><p>在上述两个示例中，我们传入的值都是字符串类型的，但实际上<em>任何</em>类型的值都可以传给一个 prop。</p><h3 id="传入一个数字"><a href="#传入一个数字" class="headerlink" title="传入一个数字"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97" target="_blank" rel="noopener">传入一个数字</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span><br><span class="line">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span><br><span class="line">&lt;blog-post v-bind:likes=&quot;42&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 用一个变量进行动态赋值。--&gt;</span><br><span class="line">&lt;blog-post v-bind:likes=&quot;post.likes&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure><h3 id="传入一个布尔值"><a href="#传入一个布尔值" class="headerlink" title="传入一个布尔值"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E5%B8%83%E5%B0%94%E5%80%BC" target="_blank" rel="noopener">传入一个布尔值</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">is-published</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:is-published</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:is-published</span>=<span class="string">"post.isPublished"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="传入一个数组"><a href="#传入一个数组" class="headerlink" title="传入一个数组"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">传入一个数组</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:comment-ids</span>=<span class="string">"[234, 266, 273]"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:comment-ids</span>=<span class="string">"post.commentIds"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="传入一个对象"><a href="#传入一个对象" class="headerlink" title="传入一个对象"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">传入一个对象</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:author</span>=<span class="string">"&#123; name: 'Veronica', company: 'Veridian Dynamics' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:author</span>=<span class="string">"post.author"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="传入一个对象的所有属性"><a href="#传入一个对象的所有属性" class="headerlink" title="传入一个对象的所有属性"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">传入一个对象的所有属性</a></h3><p>如果你想要将一个对象的所有属性都作为 prop 传入，你可以使用不带参数的 <code>v-bind</code>(取代 <code>v-bind:prop-name</code>)。例如，对于一个给定的对象 <code>post</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post: &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  title: <span class="string">'My Journey with Vue'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">"post"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:id</span>=<span class="string">"post.id"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">"post.title"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Prop-验证"><a href="#Prop-验证" class="headerlink" title="Prop 验证"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener">Prop 验证</a></h2><p>我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。</p><p>为了定制 prop 的验证方式，你可以为 <code>props</code> 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 匹配任何类型)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的数字</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="comment">// 对象或数组默认值必须从一个工厂函数获取</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'danger'</span>].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。</p><p>注意那些 prop 会在一个组件实例创建<strong>之前</strong>进行验证，所以实例的属性 (如 <code>data</code>、<code>computed</code> 等) 在 <code>default</code> 或 <code>validator</code> 函数中是不可用的。</p><h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5" target="_blank" rel="noopener">类型检查</a></h3><p><code>type</code> 可以是下列原生构造函数中的一个：</p><ul><li><code>String</code></li><li><code>Number</code></li><li><code>Boolean</code></li><li><code>Array</code></li><li><code>Object</code></li><li><code>Date</code></li><li><code>Function</code></li><li><code>Symbol</code></li></ul><p>额外的，<code>type</code> 还可以是一个自定义的构造函数，并且通过 <code>instanceof</code> 来进行检查确认。例如，给定下列现成的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person (firstName, lastName) &#123;</span><br><span class="line">  this.firstName = firstName</span><br><span class="line">  this.lastName = lastName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;blog-post&apos;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    author: Person</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>来验证 <code>author</code> prop 的值是否是通过 <code>new Person</code> 创建的。</p><h2 id="子组件——》父组件"><a href="#子组件——》父组件" class="headerlink" title="子组件——》父组件"></a>子组件——》父组件</h2><h3 id="1、通过关系链操作父组件数据"><a href="#1、通过关系链操作父组件数据" class="headerlink" title="1、通过关系链操作父组件数据"></a>1、通过关系链操作父组件数据</h3><p>子组件：通过this.$parent  可以找到其父组件</p><p>然后可以 通过 this.$parent.属性 来操作</p><h3 id="2、通过ref链"><a href="#2、通过ref链" class="headerlink" title="2、通过ref链"></a>2、通过ref链</h3><p>在组件实例上加上 ref=”ref名字”</p><p>父 找 子组件：</p><p>可以直接通过this.$refs.ref名 来找到</p><p>兄弟：</p><p>可以通过 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$parent.$refs.ref名来找到</span><br></pre></td></tr></table></figure><h3 id="3、通过父组件向子组件传递方法（常用）"><a href="#3、通过父组件向子组件传递方法（常用）" class="headerlink" title="3、通过父组件向子组件传递方法（常用）"></a>3、通过父组件向子组件传递方法（常用）</h3><p> 子组件通过props接收到这个方法； 子组件通过这个方法将数据 通过 参数传到 父组件</p><h3 id="4、通过自定义事件（常用）"><a href="#4、通过自定义事件（常用）" class="headerlink" title="4、通过自定义事件（常用）"></a>4、通过自定义事件（常用）</h3><p>父组件在子标签上 添加一个自定义事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@tell-dad=<span class="string">"say"</span></span><br><span class="line"></span><br><span class="line">say(word) &#123;</span><br><span class="line">    <span class="comment">// console.log(word)</span></span><br><span class="line">    <span class="keyword">this</span>.parentWord = word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子组件通过</p><p>this.$.emit(“自定义事件名”，参数);</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;button @click="tell"&gt;say&lt;/button&gt; </span></span><br><span class="line">tell()&#123;</span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">"tell-dad"</span>,<span class="keyword">this</span>.word)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;父组件——》子组件&quot;&gt;&lt;a href=&quot;#父组件——》子组件&quot; class=&quot;headerlink&quot; title=&quot;父组件——》子组件&quot;&gt;&lt;/a&gt;父组件——》子组件&lt;/h2&gt;&lt;p&gt;在父组件 global&lt;/p&gt;
&lt;figure class=&quot;highlight h
      
    
    </summary>
    
    
      <category term="vue" scheme="https://tianjiec.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-resource</title>
    <link href="https://tianjiec.top/2018/12/27/vue-resource/"/>
    <id>https://tianjiec.top/2018/12/27/vue-resource/</id>
    <published>2018-12-27T03:27:16.000Z</published>
    <updated>2018-12-27T03:45:15.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Vue.js是数据驱动的，这使得我们并不需要直接操作DOM，如果我们不需要使用jQuery的DOM选择器，就没有必要引入jQuery。vue-resource是Vue.js的一款插件，它可以通过XMLHttpRequest或JSONP发起请求并处理响应。也就是说，$.ajax能做的事情，vue-resource插件一样也能做到，而且vue-resource的API更为简洁。另外，vue-resource还提供了非常有用的inteceptor功能，使用inteceptor可以在请求前和请求后附加一些行为，比如使用inteceptor在ajax请求时显示loading界面。</p><p>本文的主要内容如下：</p><ul><li>介绍vue-resource的特点</li><li>介绍vue-resource的基本使用方法</li><li>基于this.$http的增删查改示例</li><li>基于this.$resource的增删查改示例</li><li>基于inteceptor实现请求等待时的loading画面</li><li>基于inteceptor实现请求错误时的提示画面</li></ul><h1 id="vue-resource特点"><a href="#vue-resource特点" class="headerlink" title="vue-resource特点"></a>vue-resource特点</h1><p>vue-resource插件具有以下特点：</p><p><strong>1. 体积小</strong></p><p>vue-resource非常小巧，在压缩以后只有大约12KB，服务端启用gzip压缩后只有4.5KB大小，这远比jQuery的体积要小得多。</p><p><strong>2. 支持主流的浏览器</strong></p><p>和Vue.js一样，vue-resource除了不支持IE 9以下的浏览器，其他主流的浏览器都支持。</p><p><strong>3. 支持Promise API和URI Templates</strong></p><p>Promise是ES6的特性，Promise的中文含义为“先知”，Promise对象用于异步计算。<br>URI Templates表示URI模板，有些类似于ASP.NET MVC的路由模板。</p><p><strong>4. 支持拦截器</strong></p><p>拦截器是全局的，拦截器可以在请求发送前和发送请求后做一些处理。<br>拦截器在一些场景下会非常有用，比如请求发送前在headers中设置access_token，或者在请求失败时，提供共通的处理方式。</p><h1 id="vue-resource使用"><a href="#vue-resource使用" class="headerlink" title="vue-resource使用"></a>vue-resource使用</h1><h2 id="引入vue-resource"><a href="#引入vue-resource" class="headerlink" title="引入vue-resource"></a>引入vue-resource</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;js/vue-resource.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>引入vue-resource后，可以基于全局的Vue对象使用http，也可以基于某个Vue实例使用http。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 基于全局Vue对象使用http</span><br><span class="line">Vue.http.get(&apos;/someUrl&apos;, [options]).then(successCallback, errorCallback);</span><br><span class="line">Vue.http.post(&apos;/someUrl&apos;, [body], [options]).then(successCallback, errorCallback);</span><br><span class="line"></span><br><span class="line">// 在一个Vue实例内使用$http</span><br><span class="line">this.$http.get(&apos;/someUrl&apos;, [options]).then(successCallback, errorCallback);</span><br><span class="line">this.$http.post(&apos;/someUrl&apos;, [body], [options]).then(successCallback, errorCallback);</span><br></pre></td></tr></table></figure><p>在发送请求后，使用<code>then</code>方法来处理响应结果，<code>then</code>方法有两个参数，第一个参数是响应成功时的回调函数，第二个参数是响应失败时的回调函数。</p><p><code>then</code>方法的回调函数也有两种写法，第一种是传统的函数写法，第二种是更为简洁的ES 6的Lambda写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 传统写法</span><br><span class="line">this.$http.get(&apos;/someUrl&apos;, [options]).then(function(response)&#123;</span><br><span class="line">    // 响应成功回调</span><br><span class="line">&#125;, function(response)&#123;</span><br><span class="line">    // 响应错误回调</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Lambda写法</span><br><span class="line">this.$http.get(&apos;/someUrl&apos;, [options]).then((response) =&gt; &#123;</span><br><span class="line">    // 响应成功回调</span><br><span class="line">&#125;, (response) =&gt; &#123;</span><br><span class="line">    // 响应错误回调</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>PS：做过.NET开发的人想必对Lambda写法有一种熟悉的感觉。</p><h2 id="支持的HTTP方法"><a href="#支持的HTTP方法" class="headerlink" title="支持的HTTP方法"></a>支持的HTTP方法</h2><p>vue-resource 的请求API是按照REST风格设计的， 他提供了7种请求API：</p><ul><li>get（url, [options]）</li><li>post（url, [options]）</li><li>head（url, [options]）</li><li><code>delete(url, [options])</code></li><li><code>jsonp(url, [options])</code></li><li><code>put(url, [body], [options])</code></li><li><code>patch(url, [body], [options])</code></li></ul><p>除了jsonp以外，另外6种的API名称是标准的HTTP方法。当服务端使用REST API时，客户端的编码风格和服务端的编码风格近乎一致，这可以减少前端和后端开发人员的沟通成本。</p><table><thead><tr><th>客户端请求方法</th><th>服务端处理方法</th></tr></thead><tbody><tr><td>this.$http.get(…)</td><td>Getxxx</td></tr><tr><td>this.$http.post(…)</td><td>Postxxx</td></tr><tr><td>this.$http.put(…)</td><td>Putxxx</td></tr><tr><td>this.$http.delete(…)</td><td>Deletexxx</td></tr></tbody></table><h2 id="options对象"><a href="#options对象" class="headerlink" title="options对象"></a>options对象</h2><p>发送请求时的options选项对象包含以下属性：</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>url</td><td><code>string</code></td><td>请求的URL</td></tr><tr><td>method</td><td><code>string</code></td><td>请求的HTTP方法，例如：’GET’, ‘POST’或其他HTTP方法</td></tr><tr><td>body</td><td><code>Object</code>, <code>FormData</code> <code>string</code></td><td>request body</td></tr><tr><td>params</td><td><code>Object</code></td><td>请求的URL参数对象</td></tr><tr><td>headers</td><td><code>Object</code></td><td>request header</td></tr><tr><td>timeout</td><td><code>number</code></td><td>单位为毫秒的请求超时时间 (<code>0</code> 表示无超时时间)</td></tr><tr><td>before</td><td><code>function(request)</code></td><td>请求发送前的处理函数，类似于jQuery的beforeSend函数</td></tr><tr><td>progress</td><td><code>function(event)</code></td><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/ProgressEvent" target="_blank" rel="noopener">ProgressEvent</a>回调处理函数</td></tr><tr><td>credentials</td><td><code>boolean</code></td><td>表示跨域请求时是否需要使用凭证</td></tr><tr><td>emulateHTTP</td><td><code>boolean</code></td><td>发送PUT, PATCH, DELETE请求时以HTTP POST的方式发送，并设置请求头的<code>X-HTTP-Method-Override</code></td></tr><tr><td>emulateJSON</td><td><code>boolean</code></td><td>将request body以<code>application/x-www-form-urlencoded</code> content type发送</td></tr></tbody></table><h3 id="emulateHTTP的作用"><a href="#emulateHTTP的作用" class="headerlink" title="emulateHTTP的作用"></a>emulateHTTP的作用</h3><p>如果Web服务器无法处理PUT, PATCH和DELETE这种REST风格的请求，你可以启用enulateHTTP现象。启用该选项后，请求会以普通的POST方法发出，并且HTTP头信息的<code>X-HTTP-Method-Override</code>属性会设置为实际的HTTP方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.options.emulateHTTP = true;</span><br></pre></td></tr></table></figure><h3 id="emulateJSON的作用"><a href="#emulateJSON的作用" class="headerlink" title="emulateJSON的作用"></a>emulateJSON的作用</h3><p>如果Web服务器无法处理编码为application/json的请求，你可以启用emulateJSON选项。启用该选项后，请求会以<code>application/x-www-form-urlencoded</code>作为MIME type，就像普通的HTML表单一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.options.emulateJSON = true;</span><br></pre></td></tr></table></figure><h2 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a>response对象</h2><p>response对象包含以下属性：</p><table><thead><tr><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>text()</td><td><code>string</code></td><td>以string形式返回response body</td></tr><tr><td>json()</td><td><code>Object</code></td><td>以JSON对象形式返回response body</td></tr><tr><td>blob()</td><td><code>Blob</code></td><td>以二进制形式返回response body</td></tr><tr><td><strong>属性</strong></td><td><strong>类型</strong></td><td><strong>描述</strong></td></tr><tr><td>ok</td><td><code>boolean</code></td><td>响应的HTTP状态码在200~299之间时，该属性为true</td></tr><tr><td>status</td><td><code>number</code></td><td>响应的HTTP状态码</td></tr><tr><td>statusText</td><td><code>string</code></td><td>响应的状态文本</td></tr><tr><td>headers</td><td><code>Object</code></td><td>响应头</td></tr></tbody></table><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h1 id="CURD示例"><a href="#CURD示例" class="headerlink" title="CURD示例"></a>CURD示例</h1><p>提示：以下示例仍然沿用上一篇的组件和WebAPI，组件的代码和页面HTML代码我就不再贴出来了。</p><h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var demo = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        gridColumns: [&apos;customerId&apos;, &apos;companyName&apos;, &apos;contactName&apos;, &apos;phone&apos;],</span><br><span class="line">        gridData: [],</span><br><span class="line">        apiUrl: &apos;http://211.149.193.19:8080/api/customers&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    ready: function() &#123;</span><br><span class="line">        this.getCustomers()</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getCustomers: function() &#123;</span><br><span class="line">            this.$http.get(this.apiUrl)</span><br><span class="line">                .then((response) =&gt; &#123;</span><br><span class="line">                    this.$set(&apos;gridData&apos;, response.data)</span><br><span class="line">                &#125;)</span><br><span class="line">                .catch(function(response) &#123;</span><br><span class="line">                    console.log(response)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这段程序的then方法只提供了successCallback，而省略了errorCallback。<br>catch方法用于捕捉程序的异常，catch方法和errorCallback是不同的，errorCallback只在响应失败时调用，而catch则是在整个请求到响应过程中，只要程序出错了就会被调用。</p><p>在then方法的回调函数内，你也可以直接使用this，this仍然是指向Vue实例的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getCustomers: function() &#123;</span><br><span class="line">    this.$http.get(this.apiUrl)</span><br><span class="line">        .then((response) =&gt; &#123;</span><br><span class="line">            this.$set(&apos;gridData&apos;, response.data)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(function(response) &#123;</span><br><span class="line">            console.log(response)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为了减少作用域链的搜索，建议使用一个局部变量来接收this。</strong></p><h2 id="JSONP请求"><a href="#JSONP请求" class="headerlink" title="JSONP请求"></a>JSONP请求</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getCustomers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$http.jsonp(<span class="keyword">this</span>.apiUrl).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.$set(<span class="string">'gridData'</span>, response.data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">var demo = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        show: false,</span><br><span class="line">        gridColumns: [&#123;</span><br><span class="line">            name: &apos;customerId&apos;,</span><br><span class="line">            isKey: true</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            name: &apos;companyName&apos;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            name: &apos;contactName&apos;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            name: &apos;phone&apos;</span><br><span class="line">        &#125;],</span><br><span class="line">        gridData: [],</span><br><span class="line">        apiUrl: &apos;http://211.149.193.19:8080/api/customers&apos;,</span><br><span class="line">        item: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ready: function() &#123;</span><br><span class="line">        this.getCustomers()</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        closeDialog: function() &#123;</span><br><span class="line">            this.show = false</span><br><span class="line">        &#125;,</span><br><span class="line">        getCustomers: function() &#123;</span><br><span class="line">            var vm = this</span><br><span class="line">            vm.$http.get(vm.apiUrl)</span><br><span class="line">                .then((response) =&gt; &#123;</span><br><span class="line">                    vm.$set(&apos;gridData&apos;, response.data)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        createCustomer: function() &#123;</span><br><span class="line">            var vm = this</span><br><span class="line">            vm.$http.post(vm.apiUrl, vm.item)</span><br><span class="line">                .then((response) =&gt; &#123;</span><br><span class="line">                    vm.$set(&apos;item&apos;, &#123;&#125;)</span><br><span class="line">                    vm.getCustomers()</span><br><span class="line">                &#125;)</span><br><span class="line">            this.show = false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://images2015.cnblogs.com/blog/341820/201607/341820-20160710081835108-205718456.gif" alt="29](https://images2015.cnblogs.com/blog/341820/201607/341820-20160710081836280-560832480.gif)" title="">                </div>                <div class="image-caption">29](https://images2015.cnblogs.com/blog/341820/201607/341820-20160710081836280-560832480.gif)</div>            </figure></p><p><strong>知识来源</strong>：</p><p><a href="https://www.cnblogs.com/chenhuichao/p/8308993.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenhuichao/p/8308993.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Vue.js是数据驱动的，这使得我们并不需要直接操作DOM，如果我们不需要使用jQuery的DOM选择器，就没有必要引入jQuery。vue
      
    
    </summary>
    
    
      <category term="vue" scheme="https://tianjiec.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>组件-Prop</title>
    <link href="https://tianjiec.top/2018/12/27/%E7%BB%84%E4%BB%B6-Prop/"/>
    <id>https://tianjiec.top/2018/12/27/组件-Prop/</id>
    <published>2018-12-27T02:45:16.000Z</published>
    <updated>2018-12-27T03:13:19.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h1><p>Prop的大小写（camelCase vs kebab-case）</p><blockquote><p>HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用DOM中的模板是，calmelCase（驼峰命名法）的prop名需要使用等价的kebab-case（短横线分隔命名）命名：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  <span class="comment">// 在 JavaScript 中是 camelCase 的</span></span><br><span class="line">  props: [<span class="string">'postTitle'</span>],</span><br><span class="line">  template: <span class="string">'&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">post-title</span>=<span class="string">"hello!"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重申一次，如果你使用字符串模板，那么这个限制就不存在了。</p><h2 id="Prop类型"><a href="#Prop类型" class="headerlink" title="Prop类型"></a>Prop类型</h2><p>到这里，我们只看到了以字符串数组形式列出的 prop：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'title'</span>, <span class="string">'likes'</span>, <span class="string">'isPublished'</span>, <span class="string">'commentIds'</span>, <span class="string">'author'</span>]</span><br></pre></td></tr></table></figure><p>但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些属性的名称和值分别是 prop 各自的名称和类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span>,</span><br><span class="line">  isPublished: <span class="built_in">Boolean</span>,</span><br><span class="line">  commentIds: <span class="built_in">Array</span>,</span><br><span class="line">  author: <span class="built_in">Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不仅为你的组件提供了文档，还会在它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户。你会在这个页面接下来的部分看到<a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener">类型检查和其它 prop 验证</a>。</p><p>传递静态或动态得到Prop</p><p>像这样，你已经知道了可以像这样给prop传入一个静态的值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"My journey with Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你也知道 prop 可以通过 <code>v-bind</code> 动态赋值，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 动态赋予一个变量的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:title</span>=<span class="string">"post.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态赋予一个复杂表达式的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:title</span>=<span class="string">"post.title + ' by ' + post.author.name"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述两个示例中，我们传入的值都是字符串类型的，但实际上<em>任何</em>类型的值都可以传给一个 prop。</p><h4 id="传入一个数字"><a href="#传入一个数字" class="headerlink" title="#传入一个数字"></a>#传入一个数字</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:likes</span>=<span class="string">"42"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:likes</span>=<span class="string">"post.likes"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="单项数据流"><a href="#单项数据流" class="headerlink" title="单项数据流"></a>单项数据流</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<strong>不</strong>应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p><p>这里有两种常见的试图改变一个prop的情形：</p><p>1、<strong>这个prop用来传递一个初始值；这个子组件接下来希望将其作为一个本地的prop数据来使用</strong>。在这种情况下，最好定义一个本地的data属性并将这个prop用作初始值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'initialCounter'</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="keyword">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、<strong>这个 prop 以一种原始的值传入且需要进行转换。</strong>在这种情况下，最好使用这个 prop 的值来定义一个计算属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'size'</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。</strong></p></blockquote><h3 id="Prop验证"><a href="#Prop验证" class="headerlink" title="Prop验证"></a>Prop验证</h3><p>我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。</p><p>为了定制 prop 的验证方式，你可以为 <code>props</code> 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">    props:&#123;</span><br><span class="line">        <span class="comment">//基础的类型检查（`null` 匹配任何类型）</span></span><br><span class="line">        propA: <span class="built_in">Number</span>,</span><br><span class="line">        <span class="comment">//多个可能类型</span></span><br><span class="line">        propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">        <span class="comment">//必填的字符串</span></span><br><span class="line">        propC: &#123;</span><br><span class="line">            type: <span class="built_in">String</span>,</span><br><span class="line">            required : <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//带有默认值的数字</span></span><br><span class="line">        propD: &#123;</span><br><span class="line">            type: <span class="built_in">Number</span>,</span><br><span class="line">            <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//带有默认值的对象</span></span><br><span class="line">        propE: &#123;</span><br><span class="line">            type: <span class="built_in">Object</span>,</span><br><span class="line">            <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    message: <span class="string">'hello'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//自定义验证函数</span></span><br><span class="line">        propF: &#123;</span><br><span class="line">            validator: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                <span class="comment">//这里值必须匹配下列字符串中的一个</span></span><br><span class="line">                <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'denger'</span>].indexOf(value)!== <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Prop&quot;&gt;&lt;a href=&quot;#Prop&quot; class=&quot;headerlink&quot; title=&quot;Prop&quot;&gt;&lt;/a&gt;Prop&lt;/h1&gt;&lt;p&gt;Prop的大小写（camelCase vs kebab-case）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTML 中的特
      
    
    </summary>
    
    
      <category term="vue" scheme="https://tianjiec.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>xhr</title>
    <link href="https://tianjiec.top/2018/12/26/xhr/"/>
    <id>https://tianjiec.top/2018/12/26/xhr/</id>
    <published>2018-12-26T11:58:39.000Z</published>
    <updated>2018-12-26T12:11:47.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解ajax——XHR对象"><a href="#深入理解ajax——XHR对象" class="headerlink" title="深入理解ajax——XHR对象"></a>深入理解ajax——XHR对象</h1><h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>　　1999年，微软公司发布IE5，第一次引入新功能：允许javascript脚本向服务器发起HTTP请求。这个功能当时并没有引起注意，直到2004年Gmail发布和2005年Google Map发布，才引起广泛重视。2005年2月，ajax这个词第一次正式提出，指围绕这个功能进行开发的一整套做法。从此，ajax成为脚本发起HTTP通信的代名词，W3C也在2006年发布了它的国际标准。本文是ajax系列的第一篇——XHR对象</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>　　ajax是asynchronous javascript and XML的简写，中文翻译是异步的javascript和XML，这一技术能够向服务器请求额外的数据而无须卸载页面，会带来更好的用户体验。虽然名字中包含XML，但ajax通信与数据格式无关</p><p>　　ajax包括以下几步骤：<strong>1、创建AJAX对象；2、发出HTTP请求；3、接收服务器传回的数据；4、更新网页数据</strong></p><p>　　概括起来，就是一句话，<strong>ajax通过原生的<code>XMLHttpRequest</code>对象发出HTTP请求，得到服务器返回的数据后，再进行处理</strong></p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>　　ajax技术的核心是XMLHttpRequest对象(简称XHR)，这是由微软首先引入的一个特性，其他浏览器提供商后来都提供了相同的实现。XHR为向服务器发送请求和解析服务器响应提供了流畅的接口，能够以异步方式从服务器取得更多信息，意味着用户单击后，可以不必刷新页面也能取得新数据</p><p>　　IE5是第一款引入XHR对象的浏览器。在IE5中，XHR对象是通过MSXML库中的一个ActiveX对象实现的，而IE7+及其他标准浏览器都支持原生的XHR对象</p><p>　　创建一个XHR对象，也叫实例化一个XHR对象，因为XMLHTTPRequest()是一个构造函数。下面是创建XHR对象的兼容写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[注意]如果要建立N个不同的请求，就要使用N个不同的XHR对象。当然可以重用已存在的XHR对象，但这会终止之前通过该对象挂起的任何请求</p><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p><strong>open()</strong></p><p>　　在使用XHR对象时，要调用的第一个方法是open()，如下所示，该方法接受3个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"example.php"</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>1、open()方法的第<strong>一个参数用于指定发送请求的方式</strong>，这个字符串，不区分大小写，但通常使用大写字母。”GET”和”POST”是得到广泛支持的</p><p>　　“GET”用于常规请求，它适用于当URL完全指定请求资源，当请求对服务器没有任何副作用以及当服务器的响应是可缓存的情况下</p><p>　　“POST”方法常用于HTML表单。它在请求主体中包含额外数据且这些数据常存储到服务器上的数据库中。相同URL的重复POST请求从服务器得到的响应可能不同，同时不应该缓存使用这个方法的请求</p><p>　　除了”GET”和”POST”之外，参数还可以是”HEAD”、”OPTIONS”、”PUT”。而由于安全风险的原因，”CONNECT”、”TRACE”、”TRACK”被禁止使用</p><p>　　[注意]关于HTTP协议8种常用方法的详细介绍<a href="http://www.cnblogs.com/xiaohuochai/p/6156435.html#anchor3" target="_blank" rel="noopener">移步至此</a></p><p>　2、open()方法的第<strong>二个参数是URL</strong>，该URL相对于执行代码的当前页面，且只能向同一个域中使用相同端口和协议的URL发送请求。如果URL与启动请求的页面有任何差别，都会引发安全错误</p><p>　　3、open()方法的第<strong>三个参数是表示是否异步发送请求的布尔值</strong>，如果不填写，默认为true，表示异步发送</p><p>　　4、如果请求一个受密码保护的URL，把用于认证的用户名和密码作为第4和第5个参数传递给open()方法</p><p><strong>send()</strong></p><p>send()方法接收一个参数，即要作为请求主体发送的数据。调用send()方法后，请求被分派到服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;get&quot;,&quot;example.txt&quot;, true)</span><br><span class="line">xhr.send(null)</span><br></pre></td></tr></table></figure><h3 id="接收响应"><a href="#接收响应" class="headerlink" title="接收响应"></a>接收响应</h3><p>　　一个完整的HTTP响应由状态码、响应头集合和响应主体组成。在收到响应后，这些都可以通过XHR对象的属性和方法使用，主要有以下4个属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">responseText:作为响应主题被返回的文本（文本形式）</span><br><span class="line">responseXML：如果响应的内容是<span class="string">'text/xml'</span>或者是<span class="string">'application/xml'</span>,这个属性中将保存着相应数据的XML DOM文档（<span class="built_in">document</span>形式）</span><br><span class="line">status: HTTP状态码（数字形式）</span><br><span class="line">statusText：HTTP状态说明（文本形式）</span><br></pre></td></tr></table></figure><p>在接收到响应后，第一步是检查status属性，以确定响应已经成功返回。一般来说，可以将HTTP状态码为200作为成功的标志。此时，responseText属性的内容已经就绪，而且在内容类型正确的情况下，responseXML也可以访问了。此外，状态码为304表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本；当然，也意味着响应是有效的</p><p>　　无论内容类型是什么，响应主体的内容都会保存到responseText属性中，而对于非XML数据而言，responseXML属性的值将为null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((xhr.status &gt;=<span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">    alert(xhr.responseText);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    alert(<span class="string">'request was unsuccessful:'</span> + xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>　　如果接受的是同步响应，则需要将open()方法的第三个参数设置为false，那么send()方法将阻塞直到请求完成。一旦send()返回，仅需要检查XHR对象的status和responseText属性即可</p><p>　　同步请求是吸引人的，但应该避免使用它们。客户端javascript是单线程的，当send()方法阻塞时，它通常会导致整个浏览器UI冻结。如果连接的服务器响应慢，那么用户的浏览器将冻结</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">"btn"</span>&gt;获取信息&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;div id="result"&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//创建xhr对象</span></span><br><span class="line">    <span class="keyword">var</span> xhr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    xhr.open(<span class="string">'get'</span>,<span class="string">'/uploads/rs/26/ddzmgynp/message.xml'</span>,<span class="literal">false</span>);</span><br><span class="line">    xhr.send();</span><br><span class="line">    <span class="comment">//同步接受响应</span></span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">            <span class="comment">//实际操作</span></span><br><span class="line">            result.innerHTML += xhr.responseText;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="javascript:void(0);" alt="复制代码](http://common.cnblogs.com/images/copycode.gif)" title="">                </div>                <div class="image-caption">复制代码](http://common.cnblogs.com/images/copycode.gif)</div>            </figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//message.xml</span><br><span class="line">&lt;p&gt;hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure><h4 id="知识来源：http-www-cnblogs-com-xiaohuochai-p-6036475-html"><a href="#知识来源：http-www-cnblogs-com-xiaohuochai-p-6036475-html" class="headerlink" title="知识来源：http://www.cnblogs.com/xiaohuochai/p/6036475.html"></a>知识来源：<a href="http://www.cnblogs.com/xiaohuochai/p/6036475.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaohuochai/p/6036475.html</a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解ajax——XHR对象&quot;&gt;&lt;a href=&quot;#深入理解ajax——XHR对象&quot; class=&quot;headerlink&quot; title=&quot;深入理解ajax——XHR对象&quot;&gt;&lt;/a&gt;深入理解ajax——XHR对象&lt;/h1&gt;&lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="ajax" scheme="https://tianjiec.top/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>Vue.extend构造器</title>
    <link href="https://tianjiec.top/2018/12/26/Vue-extend%E6%9E%84%E9%80%A0%E5%99%A8/"/>
    <id>https://tianjiec.top/2018/12/26/Vue-extend构造器/</id>
    <published>2018-12-26T09:48:26.000Z</published>
    <updated>2018-12-26T11:51:08.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1.简单介绍"></a>1.简单介绍</h3><p>Vue.extend(options)</p><p>参数：对象</p><p>用法：使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中,data选项中必须是函数</p><blockquote><h5 id="描述：Vue-extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue-component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上"><a href="#描述：Vue-extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue-component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上" class="headerlink" title="描述：Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上"></a>描述：Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上</h5></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> author = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">"&lt;p&gt;&lt;a :href='url'&gt;&#123;&#123;author&#125;&#125;&lt;/a&gt;&lt;/p&gt;"</span>,</span><br><span class="line">  data : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      author : <span class="string">'vamous'</span>,</span><br><span class="line">      url : <span class="string">'http://blog.csdn.net/Dear_Mr/article/details/72614370'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Hello = Vue.extend(&#123;</span><br><span class="line">       template:<span class="string">"&lt;p&gt;header!!!&lt;/p&gt;"</span></span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简单介绍&quot;&gt;&lt;a href=&quot;#1-简单介绍&quot; class=&quot;headerlink&quot; title=&quot;1.简单介绍&quot;&gt;&lt;/a&gt;1.简单介绍&lt;/h3&gt;&lt;p&gt;Vue.extend(options)&lt;/p&gt;
&lt;p&gt;参数：对象&lt;/p&gt;
&lt;p&gt;用法：使用Vue构造器，创建
      
    
    </summary>
    
    
      <category term="vue" scheme="https://tianjiec.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>箭头函数</title>
    <link href="https://tianjiec.top/2018/12/26/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>https://tianjiec.top/2018/12/26/箭头函数/</id>
    <published>2018-12-26T03:27:09.000Z</published>
    <updated>2018-12-26T03:51:45.203Z</updated>
    
    <content type="html"><![CDATA[<p>##### </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个参数</span></span><br><span class="line"><span class="keyword">var</span>fn1 = <span class="function"><span class="params">a</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多个参数</span></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function">(<span class="params">a, b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a+b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有return语句 返回值</span></span><br><span class="line"><span class="keyword">var</span> fn3 = <span class="function">(<span class="params">a</span>)=&gt;</span>a</span><br><span class="line"><span class="keyword">var</span> fn4 = <span class="function">(<span class="params">a, b</span>)=&gt;</span>（a+b）</span><br></pre></td></tr></table></figure><h4 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h4><p>函数自执行（自己执行）</p><p>函数的this指向window</p><p><strong>箭头函数的this指向 其上一层（临近）的对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    username:<span class="string">"张三"</span>,</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    say2:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">json.say();<span class="comment">//&#123;username: "张三", say: ƒ, say2: ƒ&#125;</span></span><br><span class="line">json.say2();<span class="comment">//Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##### &lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/s
      
    
    </summary>
    
    
      <category term="es6 js" scheme="https://tianjiec.top/tags/es6-js/"/>
    
  </entry>
  
  <entry>
    <title>作用域、变量提升、this.js</title>
    <link href="https://tianjiec.top/2018/12/25/%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E3%80%81this-js/"/>
    <id>https://tianjiec.top/2018/12/25/作用域、变量提升、this-js/</id>
    <published>2018-12-25T11:53:29.000Z</published>
    <updated>2018-12-26T03:36:40.406Z</updated>
    
    <content type="html"><![CDATA[<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.log(a);</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">abc();</span><br></pre></td></tr></table></figure><p>function 执行过程是</p><p>查找var let 将声明提前</p><p>然后再在原有位置进行赋值</p><p>var 和 let变量提升区别：</p><p>let 局部 变量提升出现死区例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">"hey I am outside"</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//Uncaught ReferenceError: a is not defined</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">"hey I am inside"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>let变量提升 在死区部分无法访问 ，而我们不能够访问的原因事实上是因为let的死区（temporal dead zone）设计：当前作用域顶部到该变量声明位置中间的部分，都是该let变量的死区，在死区中，禁止访问该变量。由此，我们给出结论，let声明的变量存在变量提升， 但是由于死区我们无法在声明前访问这个变量。<br>原文：<a href="https://blog.csdn.net/triumphs/article/details/80142721" target="_blank" rel="noopener">https://blog.csdn.net/triumphs/article/details/80142721</a> </p><h4 id="函数变量的变量提升："><a href="#函数变量的变量提升：" class="headerlink" title="函数变量的变量提升："></a>函数变量的变量提升：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn();<span class="comment">//1</span></span><br><span class="line"><span class="comment">//声明式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn2();<span class="comment">//fn2 not is a function</span></span><br><span class="line"><span class="comment">//定义式</span></span><br><span class="line"><span class="keyword">var</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="this（有关对象和函数）"><a href="#this（有关对象和函数）" class="headerlink" title="this（有关对象和函数）"></a>this（有关对象和函数）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">username = <span class="string">"lisi"</span></span><br><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    username:<span class="string">"张三"</span>,</span><br><span class="line">    fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = json.fn()</span><br><span class="line"><span class="built_in">console</span>.log(obj.username)<span class="comment">//张三 正常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = json.fn</span><br><span class="line"><span class="built_in">console</span>.log(obj().username) <span class="comment">//lisi  原因：此时obj为一个函数，函数的this指向window</span></span><br></pre></td></tr></table></figure><h4 id="bind-call-applay"><a href="#bind-call-applay" class="headerlink" title="bind call applay"></a>bind call applay</h4><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    username:<span class="string">"张三"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//window对象上面属性不存在就会是undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.username,(a+b))</span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">//undefined NaN</span></span><br><span class="line">fn.call(json,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//张三 3</span></span><br><span class="line">fn.apply(json,[<span class="number">1</span>,<span class="number">2</span>]);<span class="comment">//张三 3</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"box"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>,a)</span><br><span class="line">&#125;.bind(json,<span class="number">100</span>);&#123;<span class="attr">username</span>: <span class="string">"张三"</span>&#125; <span class="number">100</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;变量提升&quot;&gt;&lt;a href=&quot;#变量提升&quot; class=&quot;headerlink&quot; title=&quot;变量提升&quot;&gt;&lt;/a&gt;变量提升&lt;/h4&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
    
      <category term="js" scheme="https://tianjiec.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>todoList</title>
    <link href="https://tianjiec.top/2018/12/25/todoList/"/>
    <id>https://tianjiec.top/2018/12/25/todoList/</id>
    <published>2018-12-25T09:51:57.000Z</published>
    <updated>2018-12-25T12:27:59.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h1><h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><blockquote><p>显示所有任务 ； 已完成任务 ；未完成任务；</p><p>每个任务点击对号记入已完成任务；每个任务有个删除功能；未完成任务在删除的时候弹出确认删除未完成任务的对话框；</p></blockquote><h3 id="技术："><a href="#技术：" class="headerlink" title="技术："></a>技术：</h3><p>SUI Mobile框架</p><p>vue框架</p><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><h4 id="1、借用SUI-Mobile写样式"><a href="#1、借用SUI-Mobile写样式" class="headerlink" title="1、借用SUI Mobile写样式"></a>1、借用SUI Mobile写样式</h4><p><strong>首先将sui的样式css文件引入</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"http://g.alicdn.com/msui/sm/0.6.2/css/sm.min.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ps:这里sui他给的href或src地址要加上http: ， 不然会找不到资源</p><p><strong>然后找到相应的组件</strong></p><p>标题栏、图标、卡片</p><h4 id="2、借助Vue插入数据"><a href="#2、借助Vue插入数据" class="headerlink" title="2、借助Vue插入数据"></a>2、借助Vue插入数据</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span> <span class="attr">v-for</span>=<span class="string">"todo in showTodo"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card-content-inner"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;todo.content&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"> <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">     el: <span class="string">"#app"</span>,</span></span><br><span class="line"><span class="undefined">     data: &#123;</span></span><br><span class="line"><span class="undefined">         todos: [&#123;</span></span><br><span class="line"><span class="undefined">                 id: 1,</span></span><br><span class="line"><span class="javascript">                 content: <span class="string">"hello,今天又是美好的一天"</span>,</span></span><br><span class="line"><span class="javascript">                 isFinished: <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">             &#125;,</span></span><br><span class="line"><span class="undefined">             &#123;</span></span><br><span class="line"><span class="undefined">                  id: 2,</span></span><br><span class="line"><span class="javascript">                  content: <span class="string">"你好"</span>,</span></span><br><span class="line"><span class="javascript">                  isFinished: <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">              &#125;</span></span><br><span class="line"><span class="undefined">          ],</span></span><br><span class="line"><span class="undefined">     &#125;</span></span><br><span class="line"><span class="undefined"> &#125;)</span></span><br><span class="line"><span class="undefined"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、添加完成任务和删除任务按钮"><a href="#3、添加完成任务和删除任务按钮" class="headerlink" title="3、添加完成任务和删除任务按钮"></a>3、添加完成任务和删除任务按钮</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\罗中运\AppData\Roaming\Typora\typora-user-images\1545735525618.png" alt="1545735525618" title="">                </div>                <div class="image-caption">1545735525618</div>            </figure><p>在内容 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br></pre></td></tr></table></figure><p>下添加 sui 的按钮组件</p><p>为button添加 data isFinished: false属性（在每个todo 对象里面）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"button button-round"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">:class</span>=<span class="string">"(todo.isFinished?'active':'')"</span> </span></span><br><span class="line"><span class="tag">@<span class="attr">click</span>=<span class="string">"todo.isFinished=!todo.isFinished"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><p>1、为其添加 vue的 v-bind:class  用isFinished数据控制 它的样式</p><p>2、再为其添加 v-on:click 点击事件 来改变 isFinished的值来间接控制它的样式</p><p><strong>为删除任务添加事件</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"button button-round"</span></span></span><br><span class="line"><span class="tag">@<span class="attr">click</span>=<span class="string">"checkTodo(todo.id,todo.isFinished)"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><p>在任务状态为已完成（isFinished=true时）直接删除</p><p>在任务状态为未完成  弹出对话框</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\罗中运\AppData\Roaming\Typora\typora-user-images\1545736203312.png" alt="1545736203312" title="">                </div>                <div class="image-caption">1545736203312</div>            </figure><p>为对话框是否显示 添加数据  isRemoveShow: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"isRemoveShow=false"</span> <span class="attr">v-if</span>=<span class="string">"isRemoveShow"</span> <span class="attr">class</span>=<span class="string">"decive-content"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-if =true的时候显示 =false的时候隐藏</p><p>设置点击 除确定 的地方 将其隐藏 ： @click=”isRemoveShow=false” </p><h4 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h4><p>在 vue对象中：</p><blockquote><p> 删除按钮： <a href="#" class="button button-round" @click="checkTodo(todo.id,todo.isFinished)"></a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">        removeTodo(id) &#123;</span><br><span class="line">            <span class="keyword">this</span>.todos = <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> todo.id !== id ? todo : <span class="string">""</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        checkTodo(id, isFinished) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isFinished) &#123;</span><br><span class="line">                <span class="keyword">this</span>.isRemoveShow = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.preRemoveId = id;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.removeTodo(id);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>为对话框的确定添加删除功能</p><p> <span class="modal-button modal-button-bold" @click="removeTodo(preRemoveId)">确定</span></p><p>ps:这里 点击发生了冒泡，再删除数据的同时，也冒泡触发了 其父元素的 @click=”isRemoveShow=false”事件</p><p>为了给确定指明删除哪一个</p><p>在点击删除未完成任务的时候 存一个preRemoveId 用来记录此时的数据的id</p><h4 id="4、添加分类按钮"><a href="#4、添加分类按钮" class="headerlink" title="4、添加分类按钮"></a>4、添加分类按钮</h4><p>用sui的样式 和 vue的v-for循环添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">:class</span>=<span class="string">"['button',activeType === btn.type?'active':'']"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"(btn) in btns"</span> <span class="attr">:key</span>=<span class="string">"btn.id"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">click</span>=<span class="string">"activeType=btn.type"</span></span></span><br><span class="line"><span class="tag">&gt;</span>&#123;&#123;btn.title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为按钮创建数据模型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">btns: [&#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    type: <span class="string">"all"</span>,</span><br><span class="line">    title: <span class="string">"A"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">   &#123;</span><br><span class="line">       id: <span class="number">2</span>,</span><br><span class="line">       type: <span class="string">"finished"</span>,</span><br><span class="line">       title: <span class="string">"F"</span>,</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">       id: <span class="number">3</span>,</span><br><span class="line">       type: <span class="string">"unfinished"</span>,</span><br><span class="line">       title: <span class="string">"U"</span>,</span><br><span class="line">   &#125;,</span><br><span class="line">  ],</span><br><span class="line">    activeType: <span class="string">"all"</span></span><br></pre></td></tr></table></figure><p>title 用于显示文本、type用来匹配当前选中 哪一个 activeType 用来 表示 哪个选中</p><p><strong>按钮的</strong>  :calss 用来通过数据决定哪个被选中 </p><p><strong>添加点击事件改变选中</strong>：@click=”activeType=btn.type”</p><p>PS：所以，对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>。</p><p><strong>添加计算属性 来 控制显示 哪一部分数据</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">            finished()&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> todo.isFinished?todo:<span class="string">""</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            unfinished()&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> !todo.isFinished?todo:<span class="string">""</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            showTodo()&#123;</span><br><span class="line">                <span class="keyword">switch</span>(<span class="keyword">this</span>.activeType)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"all"</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.todos;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"finished"</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.finished;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"unfinished"</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.unfinished;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//&lt;div class="card" v-for="todo in showTodo"&gt;</span></span><br><span class="line"><span class="comment">//修改循环显示的 数据</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;任务列表&quot;&gt;&lt;a href=&quot;#任务列表&quot; class=&quot;headerlink&quot; title=&quot;任务列表&quot;&gt;&lt;/a&gt;任务列表&lt;/h1&gt;&lt;h3 id=&quot;功能：&quot;&gt;&lt;a href=&quot;#功能：&quot; class=&quot;headerlink&quot; title=&quot;功能：&quot;&gt;&lt;/a&gt;功能
      
    
    </summary>
    
    
      <category term="sui vue" scheme="https://tianjiec.top/tags/sui-vue/"/>
    
  </entry>
  
  <entry>
    <title>js的this</title>
    <link href="https://tianjiec.top/2018/12/24/js%E7%9A%84this/"/>
    <id>https://tianjiec.top/2018/12/24/js的this/</id>
    <published>2018-12-24T04:14:45.000Z</published>
    <updated>2018-12-24T06:01:28.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this-指向详细解析（箭头函数）"><a href="#this-指向详细解析（箭头函数）" class="headerlink" title="this 指向详细解析（箭头函数）"></a>this 指向详细解析（箭头函数）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>this 指向问题是入坑前端必须了解知识点，现在迎来了ES6时代，因为箭头函数的出现，所以感觉有必要对 this 问题梳理一下，遂有此文</p><p>在非箭头函数下， this 指向调用其所在函数的对象，而且是离谁近就是指向谁（此对于常规对象，原型链， getter &amp; setter等都适用）；构造函数下，this与被创建的新对象绑定；DOM事件，this指向触发事件的元素；内联事件分两种情况，bind绑定， call &amp; apply 方法等， 容以下一步一步讨论。箭头函数也会穿插其中进行讨论。</p><h2 id="全局环境下"><a href="#全局环境下" class="headerlink" title="全局环境下"></a>全局环境下</h2><p>在全局环境下，this 始终指向全局对象（window）, 无论是否严格模式；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(this.document === document); // true</span><br><span class="line"></span><br><span class="line">// 在浏览器中，全局对象为 window 对象：</span><br><span class="line">console.log(this === window); // true</span><br><span class="line"></span><br><span class="line">this.a = 37;</span><br><span class="line">console.log(window.a); // 37</span><br></pre></td></tr></table></figure><h2 id="函数上下文调用"><a href="#函数上下文调用" class="headerlink" title="函数上下文调用"></a>函数上下文调用</h2><h3 id="函数直接调用"><a href="#函数直接调用" class="headerlink" title="函数直接调用"></a>函数直接调用</h3><p>普通函数内部的this分两种情况，严格模式和非严格模式。</p><p>非严格模式下，this 默认指向全局对象window</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1() === window; // true</span><br></pre></td></tr></table></figure><p>而严格模式下， this为undefined</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f2()&#123;</span><br><span class="line">  &quot;use strict&quot;; // 这里是严格模式</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2() === undefined; // true</span><br></pre></td></tr></table></figure><h3 id="对象中的this"><a href="#对象中的this" class="headerlink" title="对象中的this"></a>对象中的this</h3><p>对象内部方法的this指向调用这些方法的对象，</p><ol><li>函数的定义位置不影响其this指向，this指向只和调用函数的对象有关。</li><li>多层嵌套的对象，内部方法的this指向离被调用函数最近的对象（window也是对象，其内部对象调用方法的this指向内部对象， 而非window）。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line">var o = &#123;</span><br><span class="line">  prop: 37,</span><br><span class="line">  f: function() &#123;</span><br><span class="line">    return this.prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(o.f());  //37</span><br><span class="line">var a = o.f;</span><br><span class="line">console.log(a()):  //undefined</span><br><span class="line"></span><br><span class="line">var o = &#123;prop: 37&#125;;</span><br><span class="line"></span><br><span class="line">function independent() &#123;</span><br><span class="line">  return this.prop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f = independent;</span><br><span class="line"></span><br><span class="line">console.log(o.f()); // logs 37</span><br><span class="line"></span><br><span class="line">//2</span><br><span class="line">o.b = &#123;</span><br><span class="line">  g: independent,</span><br><span class="line">  prop: 42</span><br><span class="line">&#125;;</span><br><span class="line">console.log(o.b.g()); // logs 42</span><br></pre></td></tr></table></figure><h4 id="原型链中this"><a href="#原型链中this" class="headerlink" title="原型链中this"></a>原型链中this</h4><p>原型链中的方法的this仍然指向调用它的对象，与以上讨论一致；看个例子，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  f : function()&#123; </span><br><span class="line">    return this.a + this.b; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var p = Object.create(o);</span><br><span class="line">p.a = 1;</span><br><span class="line">p.b = 4;</span><br><span class="line"></span><br><span class="line">console.log(p.f()); // 5</span><br></pre></td></tr></table></figure><p>可以看出， 在p中没有属性f，当执行p.f()时，会查找p的原型链，找到 f 函数并执行，但这与函数内部this指向对象 p 没有任何关系，只需记住谁调用指向谁。</p><p>以上对于函数作为getter &amp; setter 调用时同样适用。</p><h3 id="构造函数中this"><a href="#构造函数中this" class="headerlink" title="构造函数中this"></a>构造函数中this</h3><p>构造函数中的this与被创建的新对象绑定。</p><p>注意：当构造器返回的默认值是一个this引用的对象时，可以手动设置返回其他的对象，如果返回值不是一个对象，返回this。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function C()&#123;</span><br><span class="line">  this.a = 37;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = new C();</span><br><span class="line">console.log(o.a); // logs 37</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function C2()&#123;</span><br><span class="line">  this.a = 37;</span><br><span class="line">  return &#123;a:38&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = new C2();</span><br><span class="line">console.log(b.a); // logs 38</span><br></pre></td></tr></table></figure><p>以上两个例子内部的this都指向对象o, 看到这里的你不妨在控制台执行下以上代码，看看对象 o 和 b ，这些是属于构造函数的内容了，此处不多做介绍。（C2函数中的this.a = 37 对整个过程完全没有影响的， 可以被忽略的）。</p><h3 id="call-amp-apply"><a href="#call-amp-apply" class="headerlink" title="call &amp; apply"></a>call &amp; apply</h3><p>当函数通过Function对象的原型中继承的方法 call() 和 apply() 方法调用时， 其函数内部的this值可绑定到 call() &amp; apply() 方法指定的第一个对象上， 如果第一个参数不是对象，JavaScript内部会尝试将其转换成对象然后指向它。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function add(c, d)&#123;</span><br><span class="line">  return this.a + this.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = &#123;a:1, b:3&#125;;</span><br><span class="line"></span><br><span class="line">add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16</span><br><span class="line"></span><br><span class="line">add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</span><br><span class="line"></span><br><span class="line">function tt() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">// 返回对象见下图（图1）</span><br><span class="line">tt.call(5);  // Number &#123;[[PrimitiveValue]]: 5&#125; </span><br><span class="line">tt.call(&apos;asd&apos;); // String &#123;0: &quot;a&quot;, 1: &quot;s&quot;, 2: &quot;d&quot;, length: 3, [[PrimitiveValue]]: &quot;asd&quot;&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144423820-371299881.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h3 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h3><p>bind方法在ES5引入， 在Function的原型链上， <code>Function.prototype.bind</code>。通过bind方法绑定后， 函数将被永远绑定在其第一个参数对象上， 而无论其在什么情况下被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">  return this.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = f.bind(&#123;a:&quot;azerty&quot;&#125;);</span><br><span class="line">console.log(g()); // azerty</span><br><span class="line"></span><br><span class="line">var o = &#123;a:37, f:f, g:g&#125;;</span><br><span class="line">console.log(o.f(), o.g()); // 37, azerty</span><br></pre></td></tr></table></figure><h3 id="DOM-事件处理函数中的-this-amp-内联事件中的-this"><a href="#DOM-事件处理函数中的-this-amp-内联事件中的-this" class="headerlink" title="DOM 事件处理函数中的 this &amp; 内联事件中的 this"></a>DOM 事件处理函数中的 this &amp; 内联事件中的 this</h3><p><strong>DOM事件处理函数</strong></p><ol><li>当函数被当做监听事件处理函数时， 其 this 指向触发该事件的元素 （针对于addEventListener事件）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 被调用时，将关联的元素变成蓝色</span><br><span class="line">  function bluify(e)&#123;</span><br><span class="line">    //在控制台打印出所点击元素</span><br><span class="line">    console.log(this);</span><br><span class="line">    //阻止时间冒泡</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    //阻止元素的默认事件</span><br><span class="line">    e.preventDefault();      </span><br><span class="line">    this.style.backgroundColor = &apos;#A5D9F3&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 获取文档中的所有元素的列表</span><br><span class="line">  var elements = document.getElementsByTagName(&apos;*&apos;);</span><br><span class="line"></span><br><span class="line">  // 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span><br><span class="line">  for(var i=0 ; i&lt;elements.length ; i++)&#123;</span><br><span class="line">    elements[i].addEventListener(&apos;click&apos;, bluify, false);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上代码建议在网页中执行以下，看下效果。</p><p><strong>内联事件</strong><br>内联事件中的this指向分两种情况：</p><ol><li>当代码被内联处理函数调用时，它的this指向监听器所在的DOM元素</li><li>当代码被包括在函数内部执行时，其this指向等同于 <strong><strong>函数直接调用</strong></strong>的情况，即在非严格模式指向全局对象window， 在严格模式指向undefined</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144449757-948944211.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>页面的代码块</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144504413-1120828849.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>在浏览器内显示三个按钮</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144511679-451778615.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>依次点击上边的三个按钮后在控制台的输出结果，</p><p>建议自己操作一遍以便于更好的理解。</p><h3 id="setTimeout-amp-setInterval"><a href="#setTimeout-amp-setInterval" class="headerlink" title="setTimeout &amp; setInterval"></a>setTimeout &amp; setInterval</h3><p>对于延时函数内部的回调函数的this指向全局对象window（当然我们可以通过bind方法改变其内部函数的this指向）<br>看下边代码及截图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//默认情况下代码</span><br><span class="line">function Person() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();//3秒后返回 window 对象</span><br><span class="line">==============================================</span><br><span class="line">//通过bind绑定</span><br><span class="line">function Person() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setTimeout((function() &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;).bind(this), 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();//3秒后返回构造函数新生成的对象 Person&#123;...&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144527554-990414883.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144536820-1525099793.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h2 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h2><p>由于箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值，</p><ol><li>所以 call() / apply() / bind() 方法对于箭头函数来说只是传入参数，对它的 this 毫无影响。</li><li>考虑到 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。（可以忽略是否在严格模式下的影响）</li></ol><p>因为箭头函数可以捕获其所在上下文的this值 所以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">        // 回调里面的 `this` 变量就指向了期望的那个对象了</span><br><span class="line">        this.age++;</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();</span><br></pre></td></tr></table></figure><p>以上代码可以得到我们所以希望的值，下图可以看到，在setTimeout中的this指向了构造函数新生成的对象，而普通函数指向了全局window对象</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144556179-936108349.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var adder = &#123;</span><br><span class="line">  base : 1,</span><br><span class="line">    </span><br><span class="line">  add : function(a) &#123;</span><br><span class="line">    var f = v =&gt; v + this.base;</span><br><span class="line">    return f(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addThruCall: function inFun(a) &#123;</span><br><span class="line">    var f = v =&gt; v + this.base;</span><br><span class="line">    var b = &#123;</span><br><span class="line">      base : 2</span><br><span class="line">    &#125;;</span><br><span class="line">            </span><br><span class="line">    return f.call(b, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(adder.add(1));         // 输出 2</span><br><span class="line">console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3，其内部的this并没有因为call() 而改变，其this值仍然为函数inFun的this值，指向对象adder</span><br></pre></td></tr></table></figure><p>bind() &amp; apply() 读者可以自行测试</p><p>对于是否严格模式示例代码（可以复制进控制台进行验证）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var f = () =&gt; &#123;&apos;use strict&apos;; return this&#125;;</span><br><span class="line">var p = () =&gt; &#123; return this&#125;;</span><br><span class="line">console.log(1,f() === window);</span><br><span class="line">console.log(2,f() === p());</span><br><span class="line">//1 true</span><br><span class="line">//2 true</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144613820-1277977431.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>以上的箭头函数都是在方法内部，总之都是以非方法的方式使用，如果将箭头函数当做一个方法使用会怎样呢？<br>上例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  i: 10,</span><br><span class="line">  b: () =&gt; console.log(this.i, this),</span><br><span class="line">  c: function() &#123;</span><br><span class="line">    console.log( this.i, this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b();  // undefined window&#123;...&#125;</span><br><span class="line">obj.c();  // 10 Object &#123;...&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144630663-1545275969.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>可以看到，作为方法的箭头函数this指向全局window对象，而普通函数则指向调用它的对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;this-指向详细解析（箭头函数）&quot;&gt;&lt;a href=&quot;#this-指向详细解析（箭头函数）&quot; class=&quot;headerlink&quot; title=&quot;this 指向详细解析（箭头函数）&quot;&gt;&lt;/a&gt;this 指向详细解析（箭头函数）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>箭头函数this</title>
    <link href="https://tianjiec.top/2018/12/24/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this/"/>
    <id>https://tianjiec.top/2018/12/24/箭头函数this/</id>
    <published>2018-12-24T04:03:14.000Z</published>
    <updated>2018-12-24T05:07:13.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h3><p>由于箭头函数不绑定this，他会捕捉所在上下文的this值，作为自己的this值，</p><p>​    1、所以call()/apply()/bind() 方法对于箭头函数来说只是传入参数，对他的this值毫无影响。</p><p>​    2、考虑到this是语法层面上的，严格模式中this相关的规则都可以忽略。（可以忽略是否在严格模式下的影响）</p><p>因为箭头函数可以捕获其上下文的this值所以</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line">     setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 回调里面的 `this` 变量就指向了期望的那个对象了</span></span><br><span class="line">        <span class="keyword">this</span>.age++;</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>以上代码可以得到我们所以希望的值，下图可以看到，在setTimeout中的this指向了构造函数新生成的对象，而普通函数指向了全局window对象</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144556179-936108349.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adder = &#123;</span><br><span class="line">  base : <span class="number">1</span>,</span><br><span class="line">    </span><br><span class="line">  add : <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="keyword">this</span>.base;</span><br><span class="line">    <span class="keyword">return</span> f(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addThruCall: <span class="function"><span class="keyword">function</span> <span class="title">inFun</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="keyword">this</span>.base;</span><br><span class="line">    <span class="keyword">var</span> b = &#123;</span><br><span class="line">      base : <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> f.call(b, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(adder.add(<span class="number">1</span>));         <span class="comment">// 输出 2</span></span><br><span class="line"><span class="built_in">console</span>.log(adder.addThruCall(<span class="number">1</span>)); <span class="comment">// 仍然输出 2（而不是3，其内部的this并没有因为call() 而改变，其this值仍然为函数inFun的this值，指向对象adder</span></span><br></pre></td></tr></table></figure><p>bind() &amp; apply() 读者可以自行测试</p><p>对于是否严格模式示例代码（可以复制进控制台进行验证）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="string">'use strict'</span>; <span class="keyword">return</span> <span class="keyword">this</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>,f() === <span class="built_in">window</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>,f() === p());</span><br><span class="line"><span class="comment">//1 true</span></span><br><span class="line"><span class="comment">//2 true</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144613820-1277977431.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>以上的箭头函数都是在方法内部，总之都是以非方法的方式使用，如果将箭头函数当做一个方法使用会怎样呢？<br>上例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  i: <span class="number">10</span>,</span><br><span class="line">  b: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.i, <span class="keyword">this</span>),</span><br><span class="line">  c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.i, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b();  <span class="comment">// undefined window&#123;...&#125;</span></span><br><span class="line">obj.c();  <span class="comment">// 10 Object &#123;...&#125;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144630663-1545275969.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>可以看到，作为方法的箭头函数this指向全局window对象，而普通函数则指向调用它的对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;箭头函数中的this&quot;&gt;&lt;a href=&quot;#箭头函数中的this&quot; class=&quot;headerlink&quot; title=&quot;箭头函数中的this&quot;&gt;&lt;/a&gt;箭头函数中的this&lt;/h3&gt;&lt;p&gt;由于箭头函数不绑定this，他会捕捉所在上下文的this值，作为自己的thi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue1</title>
    <link href="https://tianjiec.top/2018/12/24/Vue1/"/>
    <id>https://tianjiec.top/2018/12/24/Vue1/</id>
    <published>2018-12-24T03:09:56.000Z</published>
    <updated>2018-12-24T05:05:34.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总结一"><a href="#总结一" class="headerlink" title="总结一"></a>总结一</h1><h4 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./base/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//每一个应用都是从创建一个实例开始的</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//每一个应用起码得来这么一个实例</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//声明式渲染：声明一条数据之后再利用特殊的模板语法将数据渲染到页面中</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line"><span class="undefined">        data:&#123;</span></span><br><span class="line"><span class="javascript">            message:<span class="string">"hello world"</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="mvc-设计模式示例"><a href="#mvc-设计模式示例" class="headerlink" title="mvc 设计模式示例"></a>mvc 设计模式示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span>&gt;</span>toggle<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn2"</span>&gt;</span>big<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./base/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//mvc的设计模式  设计项目逻辑</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//m: model 数据模型  v: view 视图  c: controller 控制器</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//c层需要控制model 在 view 进行显示</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//M层的数据和v层的显示存在一个映射关系， 当我们建立好c层之后，焦点关注在数据变化上就行了。</span></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">//通过简单的mvc的设计思想来构建</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//view层</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> view = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'box'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    <span class="comment">//model</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> model = &#123;</span></span><br><span class="line"><span class="javascript">        isShow: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        isBig: <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//controller</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">Controller</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.init()；</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    Controller.prototype = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">constructor</span>: Controller,</span></span><br><span class="line"><span class="undefined">        init()&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">this</span>.addEvent();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.render();</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        addEvent()&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//let self = self;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//let This = this;</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"btn"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> btn2 = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"btn2"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">            btn.onclick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="undefined">                model.isShow = !model.isShow;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.render();</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            btn2.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                model.isBig = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.render();</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        render()&#123;<span class="comment">//渲染的过程</span></span></span><br><span class="line"><span class="javascript">            view.style.display = model.isShow?<span class="string">"block"</span>:<span class="string">"none"</span>;</span></span><br><span class="line"><span class="javascript">            view.style.width = (model.isBig ? <span class="number">400</span> : <span class="number">50</span>)+<span class="string">"px"</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Controller();</span></span><br></pre></td></tr></table></figure><h3 id="vue的mvvm-设计模式"><a href="#vue的mvvm-设计模式" class="headerlink" title="vue的mvvm 设计模式"></a>vue的mvvm 设计模式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标签内 数据不需要&#123;&#123;&#125;&#125; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-model 是vue 提供的指令 它的作用是操作dom --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//Vue 采用的是MVVM模式，这是MVC衍生出来的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//区别：视图与vieqmodel直接的关系紧密</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//M层的数据会与v层视图 建立联系</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//v-model就是vue提供的指令 操作dom</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="javascript">            message: <span class="string">"hello World"</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">".app"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="comment">// data:data</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//data与data名相同 可简写为data</span></span></span><br><span class="line"><span class="undefined">            data</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="javascript">        <span class="comment">//Vue当中实现双向数据绑定的原理：</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//vue在创建viewmodel的时候，会将数据配置在实例中，然后会是使用Object.defineProperty对这</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//些数据进行处理，并且为这些数据添加getter，setter方法，当数据改变之后，就会触发此数据绑定的setter方法</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//从而触发vm的watcher方法，然后数据改变了，然后vm进一步渲染view视图。</span></span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="javascript">            message: <span class="string">"Hello world"</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">".app"</span>,</span></span><br><span class="line"><span class="undefined">            data</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//Object.defineProperty()  es5提供的 ie8不支持</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> _data = &#123;</span></span><br><span class="line"><span class="undefined">            </span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> temp = <span class="number">123</span>;</span></span><br><span class="line"><span class="undefined">          temp = 123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Object</span>.defineProperty(_data,<span class="string">"msg"</span>,&#123;</span></span><br><span class="line"><span class="undefined">            get()&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"getter"</span>)</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> temp;</span></span><br><span class="line"><span class="undefined">              </span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            set(vel)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"setter"</span>)</span></span><br><span class="line"><span class="undefined">                temp = vel;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="javascript">        <span class="comment">//获取数据</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(_data.msg)</span></span><br><span class="line"><span class="javascript">        <span class="comment">//设置属性的时候会执行setter方法</span></span></span><br><span class="line"><span class="undefined">        _data.msg = 456;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(_data.msg)</span></span><br><span class="line"><span class="javascript">        <span class="comment">//vue双向数据绑定原理</span></span></span><br><span class="line"><span class="undefined">        /* </span></span><br><span class="line"><span class="undefined">            当view层数据改变时， 通过监听viewmodel获取数据  viewmodel再去改变 model数据层</span></span><br><span class="line"><span class="undefined">            数据修改之后 viewmodel再去设置 view层的显示</span></span><br><span class="line"><span class="undefined">         */</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;总结一&quot;&gt;&lt;a href=&quot;#总结一&quot; class=&quot;headerlink&quot; title=&quot;总结一&quot;&gt;&lt;/a&gt;总结一&lt;/h1&gt;&lt;h4 id=&quot;demo1&quot;&gt;&lt;a href=&quot;#demo1&quot; class=&quot;headerlink&quot; title=&quot;demo1&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node.js取参的四种方法</title>
    <link href="https://tianjiec.top/2018/12/21/node-js%E5%8F%96%E5%8F%82%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://tianjiec.top/2018/12/21/node-js取参的四种方法/</id>
    <published>2018-12-21T11:59:17.000Z</published>
    <updated>2018-12-21T12:01:13.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="node-js取参四种方法"><a href="#node-js取参四种方法" class="headerlink" title="node.js取参四种方法"></a>node.js取参四种方法</h1><h4 id="req-body-req-params-req-param-req-body"><a href="#req-body-req-params-req-param-req-body" class="headerlink" title="req.body,req.params,req.param,req.body"></a>req.body,req.params,req.param,req.body</h4><p>参考：<a href="https://my.oschina.net/u/2519530/blog/535309" target="_blank" rel="noopener">https://my.oschina.net/u/2519530/blog/535309</a></p><p>获取请求很中的参数是每个web后台处理的必经之路，nodejs的 <strong>express框架</strong> 提供了四种方法来实现。</p><p>1,req.body</p><p>2,req.query</p><p>3,req.params</p><p>4,req.param()</p><p><strong>首先介绍第一个req.body</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">官方文档解释：</span><br><span class="line">Contains key-value pairs of data submitted in the request body. By default, it is undefined,</span><br><span class="line"> and is populated when you use body-parsing middleware such as body-parser and multer.</span><br><span class="line"></span><br><span class="line">稍微翻译一下：包含了提交数据的键值对在请求的body中，默认是underfined,</span><br><span class="line">你可以用body-parser或者multer来解析body</span><br></pre></td></tr></table></figure><p>解析body不是nodejs默认提供的，你需要载入body-parser中间件才可以使用req.body；</p><p>此方法通常用来解析POST请求中的数据</p><p><strong>第二种是req.query</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">官方文档解释：</span><br><span class="line">An object containing a property for each query string parameter in the route. </span><br><span class="line">If there is no query string, it is the empty object, &#123;&#125;.</span><br><span class="line">翻译一下:包含在路由中每个查询字符串参数属性的对象。如果没有，默认为&#123;&#125;</span><br></pre></td></tr></table></figure><p>有nodejs默认提供，无需载入中间件</p><p>举例说明（官方摘录）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /search?q=tobi+ferret</span></span><br><span class="line">req.query.q</span><br><span class="line"><span class="comment">// =&gt; "tobi ferret"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=converse</span></span><br><span class="line">req.query.order</span><br><span class="line"><span class="comment">// =&gt; "desc"</span></span><br><span class="line">req.query.shoe.color</span><br><span class="line"><span class="comment">// =&gt; "blue"</span></span><br><span class="line">req.query.shoe.type</span><br><span class="line"><span class="comment">// =&gt; "converse"</span></span><br></pre></td></tr></table></figure><p><strong>注意：此方法多适用于GET请求，解析GET里的参数</strong></p><p><strong>第三种是 req.params</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">官方文档：</span><br><span class="line">An object containing properties mapped to the named route “parameters”. </span><br><span class="line">For example, <span class="keyword">if</span> you have the route /user/:name, </span><br><span class="line">then the “name” property is available <span class="keyword">as</span> req.params.name. This object defaults to &#123;&#125;.</span><br><span class="line"></span><br><span class="line">翻译：包含映射到指定的路线“参数”属性的对象。</span><br><span class="line">例如，如果你有route/user/：name，那么“name”属性可作为req.params.name。</span><br><span class="line">该对象默认为&#123;&#125;。</span><br></pre></td></tr></table></figure><p>nodejs默认提供，无需载入其他中间件</p><p>举例说明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /user/tj</span></span><br><span class="line">req.params.name</span><br><span class="line"><span class="comment">// =&gt; "tj"</span></span><br></pre></td></tr></table></figure><p><strong>多适用于restful风格url中的参数的解析</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eq.query与req.params的区别</span><br><span class="line">req.params包含路由参数（在URL的路径部分），而req.query包含URL的查询参数（在URL的？后的参数）。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;node-js取参四种方法&quot;&gt;&lt;a href=&quot;#node-js取参四种方法&quot; class=&quot;headerlink&quot; title=&quot;node.js取参四种方法&quot;&gt;&lt;/a&gt;node.js取参四种方法&lt;/h1&gt;&lt;h4 id=&quot;req-body-req-params-r
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>soket</title>
    <link href="https://tianjiec.top/2018/12/20/soket/"/>
    <id>https://tianjiec.top/2018/12/20/soket/</id>
    <published>2018-12-20T12:35:54.000Z</published>
    <updated>2018-12-20T12:43:12.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>当前程序执行：</p><p>同步：阻塞，当前程序是否能够去执行，必须等前一个程序执行完毕之后，才能够去执行。</p><p>异步：非阻塞，当前程序的执行，并不受前一个程序是否执行完毕的影响。</p><p>多个程序之间的关系 （串行/并行）</p><p>并行： 多个程序之间可以同时或者不同时去执行，叫做并行</p><p>串行： 多个程序之间必须按照顺序去执行，这叫串行。</p><p>1、同步执行的程序，必然是串行的</p><p>2、异步执行的程序，可以实现串行</p><p>3、并行的程序必然是异步执行</p><p>套接字：</p><p>上传视频 ： 视频 =&gt; 二进制 =&gt; 分块（编码） + ip：port=&gt; 传输 =&gt; 组装</p><p>SOCKET</p><p>网络上两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="file:///C:/Users/罗中运/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image001.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h4 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h4><table><thead><tr><th>创建用来接收数据和广播数据的 服务器：</th><th></th></tr></thead><tbody><tr><td>创建socket</td><td>socket（）</td></tr><tr><td>绑定soket和端口号</td><td>bind（）</td></tr><tr><td>监听端口号</td><td>listen（）</td></tr><tr><td>接受信息</td><td>accept（）</td></tr><tr><td>从socket中读取字符</td><td>recv（）</td></tr><tr><td>关闭socket</td><td>close（）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;同步和异步&quot;&gt;&lt;a href=&quot;#同步和异步&quot; class=&quot;headerlink&quot; title=&quot;同步和异步&quot;&gt;&lt;/a&gt;同步和异步&lt;/h2&gt;&lt;p&gt;当前程序执行：&lt;/p&gt;
&lt;p&gt;同步：阻塞，当前程序是否能够去执行，必须等前一个程序执行完毕之后，才能够去执行。&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>5-1Node.js编写</title>
    <link href="https://tianjiec.top/2018/12/20/5-1Node-js%E7%BC%96%E5%86%99/"/>
    <id>https://tianjiec.top/2018/12/20/5-1Node-js编写/</id>
    <published>2018-12-20T09:17:09.000Z</published>
    <updated>2018-12-20T09:18:20.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学前需求"><a href="#学前需求" class="headerlink" title="学前需求"></a>学前需求</h2><blockquote><h3 id="一、node安装和运行"><a href="#一、node安装和运行" class="headerlink" title="一、node安装和运行"></a>一、node安装和运行</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">会安装node，搭建node环境</span><br><span class="line">会运行node执行node程序</span><br></pre></td></tr></table></figure><blockquote><h3 id="二、node基础模块的使用"><a href="#二、node基础模块的使用" class="headerlink" title="二、node基础模块的使用"></a>二、node基础模块的使用</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Buffer：二进制数据处理模块</span><br><span class="line">Events：事件模块</span><br><span class="line">fs：文件系统模块</span><br><span class="line">Net：网络模块</span><br><span class="line">Http：http模块</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://nodejs.org/api/" target="_blank" rel="noopener">https://nodejs.org/api/</a></p></blockquote><h2 id="前台管理功能"><a href="#前台管理功能" class="headerlink" title="前台管理功能"></a>前台管理功能</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/BUkKRSYer6YG8srS1RteyV39UGe04Zi8kcWL7bwoQas!/b/dGYBAAAAAAAA&bo=cgF6AQAAAAADByo!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="后台页面"><a href="#后台页面" class="headerlink" title="后台页面"></a>后台页面</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/R660H48.QMim2kKOUN.K5Pkfhpdcpu2cfnZmsIuDq.k!/b/dDEBAAAAAAAA&bo=KAKqAwAAAAADB6E!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="三、技术框架介绍"><a href="#三、技术框架介绍" class="headerlink" title="三、技术框架介绍"></a>三、技术框架介绍</h3><p>NodeJS、Express、Mongodb</p><h3 id="四、第三方模块-amp-中间件"><a href="#四、第三方模块-amp-中间件" class="headerlink" title="四、第三方模块&amp;中间件"></a>四、第三方模块&amp;中间件</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body-parser:解析post请求数据</span><br><span class="line">cookies:读/写cookie</span><br><span class="line">swig:模板解析引擎</span><br><span class="line">mongoose:操作mongodb数据</span><br><span class="line">markdown:markdown语法解析生成模块</span><br></pre></td></tr></table></figure><blockquote><h3 id="五、项目初始化"><a href="#五、项目初始化" class="headerlink" title="五、项目初始化"></a>五、项目初始化</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><blockquote><h3 id="六、依赖模块安装（要联网、要联网、要联网）"><a href="#六、依赖模块安装（要联网、要联网、要联网）" class="headerlink" title="六、依赖模块安装（要联网、要联网、要联网）"></a>六、依赖模块安装（要联网、要联网、要联网）</h3></blockquote><h2 id="应用创建"><a href="#应用创建" class="headerlink" title="应用创建"></a>应用创建</h2><blockquote><h3 id="准备：目录结构"><a href="#准备：目录结构" class="headerlink" title="准备：目录结构"></a>准备：目录结构</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/KEvmeky95HuJ4YaPSjoF5hjfAx9M9Q3bz6WsqtErtqQ!/b/dFYBAAAAAAAA&bo=xgKcAQAAAAADB3s!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="一、创建应用、监听端口-app-js中"><a href="#一、创建应用、监听端口-app-js中" class="headerlink" title="一、创建应用、监听端口(app.js中)"></a>一、创建应用、监听端口(app.js中)</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//加载express模块</span><br><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">//创建app应用  =&gt; NodeJS Http.createServer();</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">//监听http请求</span><br><span class="line">app.listen(8081);</span><br></pre></td></tr></table></figure><blockquote><h3 id="二、用户的访问"><a href="#二、用户的访问" class="headerlink" title="二、用户的访问"></a>二、用户的访问</h3><p>(1)用户通过URL访问web应用，如 http:localhost:8081/<br>(2)web后端根据用户访问的URL处理不同的业务逻辑</p><h3 id="三、处理请求输出"><a href="#三、处理请求输出" class="headerlink" title="三、处理请求输出"></a>三、处理请求输出</h3><p>(1)路由绑定：<br>通过app.get()或者app.post()等方法可以把一个url路径和一个或N个函数进行绑定。<br>app.get(“/“, function(req, res, next){}) req：request对象 - 保存客户端请求的一个数据 http.request<br>res：response对象 - 服务端输出对象，提供了一些服务器端输出相关的一些方法 - http.response<br>next：方法，用于执行下一个和路径匹配的函数</p><h3 id="四、内容输出"><a href="#四、内容输出" class="headerlink" title="四、内容输出"></a>四、内容输出</h3><p>通过res.send(string)发送内容到客户端</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//加载express模块</span><br><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">//创建app应用  =&gt; NodeJS Http.createServer();</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">首页</span><br><span class="line">监听到输入路径/，处理的操作</span><br><span class="line">*/</span><br><span class="line">app.get(&quot;/&quot;, function(req, res, next)&#123;</span><br><span class="line">res.send(&quot;&lt;h1&gt;欢迎光临我的博客!&lt;/h1&gt;&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//监听http请求</span><br><span class="line">app.listen(8081);</span><br></pre></td></tr></table></figure><blockquote><h3 id="五、使用模板"><a href="#五、使用模板" class="headerlink" title="五、使用模板"></a>五、使用模板</h3><p>（1）模板的使用<br>后端逻辑和页面表现分离 - 前后端分离<br>（2）模板的配置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//加载express模块</span><br><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">//加载模板处理前后端</span><br><span class="line">var swig = require(&quot;swig&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建app应用  =&gt; NodeJS Http.createServer();</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">//配置应用模板</span><br><span class="line">/*</span><br><span class="line">定义当前应用所使用的模板引擎,使用swig.renderFile方法解析后缀为html的文件</span><br><span class="line">第一个参数：模板引擎的名称，同时也是模板文件的后缀</span><br><span class="line">第二个参数：表示用于解析处理模板内容的方法</span><br><span class="line">*/</span><br><span class="line">app.engine(&quot;html&quot;, swig.renderFile);</span><br><span class="line">/*</span><br><span class="line">设置模板文件存放的目录</span><br><span class="line">第一个参数必须是views</span><br><span class="line">第二个参数是目录</span><br><span class="line">*/</span><br><span class="line">app.set(&quot;views&quot;, &quot;./views&quot;);</span><br><span class="line">/*</span><br><span class="line">注册所使用的模板引擎</span><br><span class="line">第一个参数：不能改必须是view engine</span><br><span class="line">第二个参数：和app.engine这个方法中定义的模板引擎的名称（第一个参数）是一致的</span><br><span class="line">*/</span><br><span class="line">app.set(&quot;view engine&quot;, &quot;html&quot;);</span><br><span class="line">/*</span><br><span class="line">【注】这里注意，在开发过程中，需要取消模板缓存</span><br><span class="line">*/</span><br><span class="line">swig.setDefaults(&#123;cache: false&#125;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">首页</span><br><span class="line">监听到输入路径/，处理的操作</span><br><span class="line">*/</span><br><span class="line">app.get(&quot;/&quot;, function(req, res, next)&#123;</span><br><span class="line">// res.send(&quot;&lt;h1&gt;欢迎光临我的博客!&lt;/h1&gt;&quot;);</span><br><span class="line">//将前后台页面进行分离</span><br><span class="line">/*</span><br><span class="line">读取view目录下的指定文件，解析并返回给客户端</span><br><span class="line">第一个参数，表示模板文件，相对于views目录 views/index.html</span><br><span class="line">第二个参数，传递给模板使用的数据。</span><br><span class="line">*/</span><br><span class="line">res.render(&quot;index&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//监听http请求</span><br><span class="line">app.listen(8081);</span><br></pre></td></tr></table></figure><blockquote><p>当我们在设置main.css样式链接的时候，提示请求失败，是因为我们没有设置对应的路由操作</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(&quot;/main.css&quot;, function(req, res, next)&#123;</span><br><span class="line"></span><br><span class="line">// 默认发送的是html格式数据，没有办法解析</span><br><span class="line">// 在这里需要设置解析格式头</span><br><span class="line"></span><br><span class="line">res.setHeader(&quot;content-type&quot;, &quot;text/css&quot;);</span><br><span class="line"></span><br><span class="line">res.send(&quot;body &#123;background-color: red;&#125;&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>但是上述这种操作处理静态文件过于麻烦，我们可以设置静态文件托管目录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//修改index.html</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;/public/main.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">//修改app.js</span><br><span class="line">/*</span><br><span class="line">设置静态文件托管</span><br><span class="line">下述代码的意思是，如果加载路径url是以/public开头的，就以后续操作处理</span><br><span class="line">*/</span><br><span class="line">app.use(&quot;/public&quot;, express.static(__dirname + &quot;/public&quot;));</span><br></pre></td></tr></table></figure><blockquote><p>【注】项目逻辑：<br>用户发送http请求 -&gt; url -&gt; 解析路由 -&gt; 找到匹配的规则 -&gt; 满足规则执行绑定的函数 -&gt; 返回对应的内容。<br>/public -&gt; 静态 -&gt; 直接读取指定目录下的文件，返回用户<br>动态 -&gt; 处理业务逻辑，加载模板，解析模板 -&gt; 返回数据给用户。</p><h2 id="六、划分模块"><a href="#六、划分模块" class="headerlink" title="六、划分模块"></a>六、划分模块</h2><h3 id="根据功能进行模块划分"><a href="#根据功能进行模块划分" class="headerlink" title="根据功能进行模块划分"></a>根据功能进行模块划分</h3><p>前台模块<br>后台管理模块<br>API模块</p><p>使用app.use()进行模块划分</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(&quot;/admin&quot;, require(&apos;./routers/admin&apos;));</span><br><span class="line">app.use(&quot;/api&quot;, require(&quot;.routers/api&quot;));</span><br><span class="line">app.use(&quot;/&quot;, require(&quot;./routers/main&quot;));</span><br></pre></td></tr></table></figure><blockquote><p>创建routers/admin.js routers/api.js routers/main.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line">//这里不需要些/admin/user，因为前面已经处理过了</span><br><span class="line">router.get(&quot;/user&quot;, function(req, res, next)&#123;</span><br><span class="line">res.send(&quot;ADMIN - User&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure><blockquote><h3 id="前台路由-模板"><a href="#前台路由-模板" class="headerlink" title="前台路由+模板"></a>前台路由+模板</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/yrwfg0RB5*BrSANs3IltkSPIIe76l7bseNEbdTw4DDY!/b/dFYBAAAAAAAA&bo=BAKIAQAAAAADB60!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="后台路由-模块"><a href="#后台路由-模块" class="headerlink" title="后台路由+模块"></a>后台路由+模块</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/yd3sN3SlMU22RfznIbFMYtreROhe80JUaw8Zx0xj7QU!/b/dFYBAAAAAAAA&bo=BgIEAgAAAAADByA!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="功能开发顺序"><a href="#功能开发顺序" class="headerlink" title="功能开发顺序"></a>功能开发顺序</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/Rh6kslhjswehoKgecSqxrliFSMIG4q9rm*DjmbSuZs8!/b/dF4BAAAAAAAA&bo=EgJeAQAAAAADB20!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="首先我们来看一下如何链接数据库mongoDB"><a href="#首先我们来看一下如何链接数据库mongoDB" class="headerlink" title="首先我们来看一下如何链接数据库mongoDB"></a>首先我们来看一下如何链接数据库mongoDB</h3></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --dbpath=磁盘路径 port=端口号</span><br></pre></td></tr></table></figure><blockquote><h3 id="数据库的使用"><a href="#数据库的使用" class="headerlink" title="数据库的使用"></a>数据库的使用</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/bDrNzQyw4OQ2Xwat*g6CDTXSQcAgDzaFrgLSIH0L4HY!/b/dGcBAAAAAAAA&bo=JgJ0AQAAAAADB3M!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><p>（1）首先在app.js中链接数据库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//加载数据库模块</span><br><span class="line">var mongoose = require(&quot;mongoose&quot;);</span><br><span class="line">//链接数据库</span><br><span class="line">mongoose.connect(&quot;mongodb://127.0.0.1:27017&quot;, function(err)&#123;</span><br><span class="line">if(err)&#123;</span><br><span class="line">console.log(&quot;数据库链接失败：&quot; + err);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">console.log(&quot;数据库链接成功&quot;);</span><br><span class="line">//当我们数据库链接成功以后，监听http请求</span><br><span class="line">app.listen(8081);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>（2）创建schemas/users.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&quot;mongoose&quot;);</span><br><span class="line"></span><br><span class="line">//定义用户的表结构,并对外提供接口</span><br><span class="line">module.exports = new mongoose.Schema(&#123;</span><br><span class="line">//用户名</span><br><span class="line">username: String,</span><br><span class="line">//密码</span><br><span class="line">password: String</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>（3）创建models/User.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var mongoose = require(&quot;mongoose&quot;);</span><br><span class="line"></span><br><span class="line">var usersSchema = require(&quot;../schemas/users&quot;);</span><br><span class="line"></span><br><span class="line">//完成了一个模型类</span><br><span class="line">module.exports = mongoose.model(&quot;User&quot;, usersSchema);</span><br><span class="line">/*</span><br><span class="line">【注】后期可以通过这个模型类创建对象</span><br><span class="line">直接对表中的数据进行操作。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><blockquote><h3 id="用户注册"><a href="#用户注册" class="headerlink" title="用户注册"></a>用户注册</h3></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/YRE0y3xWBvM4MuKGsuZoc0aAjLYcIhTQP6kXcNCa73o!/b/dFYBAAAAAAAA&bo=jAEOAQAAAAADB6A!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><h3 id="设置用户主页"><a href="#设置用户主页" class="headerlink" title="设置用户主页"></a>设置用户主页</h3><p>修改routers/main.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line">//这里不需要些/admin/user，因为前面已经处理过了</span><br><span class="line">router.get(&quot;/&quot;, function(req, res, next)&#123;</span><br><span class="line">// res.send(&quot;首页&quot;);</span><br><span class="line">//加载index.html</span><br><span class="line">res.render(&quot;main/index&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure><blockquote><p>拷贝对应的index.html（已经写好了） 页面到views/main/index.html<br>同时拷贝对应的其他文件到public中</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://m.qpic.cn/psb?/V13wE8sQ0FBtUy/x3.YvajSctA1zqznjRIefek90Yg7PR.8IIHL4RPwLx8!/b/dFYBAAAAAAAA&bo=8AFkAQAAAAADB7Y!&rf=viewer_4" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><p>在public/js/index.js中编写登录注册逻辑</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//设置登录和注册互斥显示</span><br><span class="line">$(function()&#123;</span><br><span class="line">$loginBox = $(&quot;#loginBox&quot;);</span><br><span class="line">$registerBox = $(&quot;#registerBox&quot;);</span><br><span class="line"></span><br><span class="line">//点击马上注册，切换到注册面板</span><br><span class="line">$loginBox.find(&quot;a&quot;).on(&quot;click&quot;, function()&#123;</span><br><span class="line">$registerBox.show();</span><br><span class="line">$loginBox.hide();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//切换到登录面板</span><br><span class="line">$registerBox.find(&quot;a&quot;).on(&quot;click&quot;, function()&#123;</span><br><span class="line">$registerBox.hide();</span><br><span class="line">$loginBox.show();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//注册</span><br><span class="line">$registerBox.find(&quot;button&quot;).on(&quot;click&quot;, function()&#123;</span><br><span class="line">//点击注册按钮，通过ajax提交请求</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">type: &quot;POST&quot;,</span><br><span class="line">url: &quot;/api/user/register&quot;,</span><br><span class="line">data: &#123;</span><br><span class="line">username: $registerBox.find(&quot;[name=username]&quot;).val(),</span><br><span class="line">password: $registerBox.find(&quot;[name=password]&quot;).val(),</span><br><span class="line">repassword: $registerBox.find(&quot;[name=repassword]&quot;).val()</span><br><span class="line">&#125;,</span><br><span class="line">dataType: &quot;json&quot;,</span><br><span class="line">success: function(result)&#123;</span><br><span class="line">console.log(result);</span><br><span class="line">&#125;,</span><br><span class="line">error: function(err)&#123;</span><br><span class="line">console.log(&quot;请求错误：&quot; + err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">//这个部分我们只是完成了前端注册信息的提交</span><br></pre></td></tr></table></figure><blockquote><p>下面我们给后端增加注册的逻辑<br>处理post请求数据需要引入body-parser模块<br>在app.js中设置该模块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var bodyParser = require(&quot;body-parser&quot;); </span><br><span class="line">/*</span><br><span class="line">bodyParser设置</span><br><span class="line">*/</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended: true&#125;));</span><br></pre></td></tr></table></figure><blockquote><p>在 routers/api.js 中实现</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&quot;express&quot;);</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line">//定义统一返回格式</span><br><span class="line">var responseData;</span><br><span class="line"></span><br><span class="line">router.use(function(req, res, next)&#123;</span><br><span class="line">responseData = &#123;</span><br><span class="line">code: 0,    //错误码</span><br><span class="line">message: &quot;&quot; //信息</span><br><span class="line">&#125;</span><br><span class="line">next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//这里不需要些/admin/user，因为前面已经处理过了</span><br><span class="line">//在api.js中增加路由</span><br><span class="line">/*</span><br><span class="line">用户注册</span><br><span class="line">这里我们需要获取到提交的post数据，</span><br><span class="line">这里需要用到模块body-parser,用来处理post提交过来的数据</span><br><span class="line">在app.js中引入该模块</span><br><span class="line">body-parser引入以后，还需要进行一些相关配置，具体百度</span><br><span class="line">设置以后，会自动在req中增加一个属性body</span><br><span class="line">这个属性中有我们post请求提交的数据</span><br><span class="line">*/</span><br><span class="line">router.post(&quot;/user/register&quot;, function(req, res, next)&#123;</span><br><span class="line">// console.log(&quot;register&quot;);</span><br><span class="line">// console.log(req.body);</span><br><span class="line">/*</span><br><span class="line">下面我们编写注册逻辑</span><br><span class="line">1、基本的注册逻辑判断</span><br><span class="line">（1）用户名不能为空</span><br><span class="line">（2）密码不能为空</span><br><span class="line">（3）两次输入的密码必须一致</span><br><span class="line">2、和数据库中的数据进行比对，判断是否被注册了</span><br><span class="line">（1）数据库的查询</span><br><span class="line">【注】在判断过程中，我们需要随时返回判断结果，所以需要设置统一接口</span><br><span class="line">*/</span><br><span class="line">var username = req.body.username;</span><br><span class="line">var password = req.body.password;</span><br><span class="line">var repassword = req.body.repassword;</span><br><span class="line"></span><br><span class="line">//用户名是否为空</span><br><span class="line">if(username == &quot;&quot;)&#123;</span><br><span class="line">responseData.code = 1;</span><br><span class="line">responseData.message = &quot;用户名不能为空&quot;;</span><br><span class="line">//返回前端</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//密码不能为空</span><br><span class="line">if(password == &quot;&quot;)&#123;</span><br><span class="line">responseData.code = 2;</span><br><span class="line">responseData.message = &quot;密码不能为空&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//两次输入的密码不一致，必须一致</span><br><span class="line">if(password != repassword)&#123;</span><br><span class="line">responseData.code = 3</span><br><span class="line">responseData.message = &quot;两次输入的密码不一致&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//注册成功</span><br><span class="line">responseData.message = &quot;注册成功&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure><blockquote><h3 id="添加数据库验证"><a href="#添加数据库验证" class="headerlink" title="添加数据库验证"></a>添加数据库验证</h3><p>routers/api.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   //引入数据模型</span><br><span class="line">   var User = require(&quot;../models/User&quot;);</span><br><span class="line">   //插入到一般判断后面</span><br><span class="line">/*</span><br><span class="line">用户名是否已经被注册了，</span><br><span class="line">如果数据库已经存在和我们要注册的用户名同名的数据</span><br><span class="line">表示用户名已经被注册了</span><br><span class="line">*/</span><br><span class="line">User.findOne(&#123;</span><br><span class="line">username: username</span><br><span class="line">&#125;).then(function(userInfo)&#123;</span><br><span class="line">// console.log(userInfo);</span><br><span class="line">if(userInfo)&#123;</span><br><span class="line">//表示数据库中有该记录</span><br><span class="line">responseData.code = 4;</span><br><span class="line">responseData.message = &quot;用户名已经被注册了&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//保存用户注册的信息到数据库中</span><br><span class="line">var user = new User(&#123;</span><br><span class="line">username: username,</span><br><span class="line">password: password</span><br><span class="line">&#125;);</span><br><span class="line">//保存到数据库</span><br><span class="line">return user.save(); </span><br><span class="line">&#125;).then(function(newUserInfo)&#123;</span><br><span class="line">console.log(newUserInfo);</span><br><span class="line">//注册成功 数据成功存储在了admin数据库中</span><br><span class="line">responseData.message = &quot;注册成功&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>将注册成功的信息显示在页面上(public/js/index.js)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">success: function(result)&#123;</span><br><span class="line">// console.log(result);</span><br><span class="line">$registerBox.find(&quot;.colWarning&quot;).html(result.message);</span><br><span class="line">if(!result.code)&#123;</span><br><span class="line">//注册成功</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">//显示登录页面，隐藏注册页面</span><br><span class="line">$registerBox.hide();</span><br><span class="line">$loginBox.show();</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>同样的原理，编写登录<br>public/js/index.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//登录</span><br><span class="line">$loginBox.find(&quot;button&quot;).on(&quot;click&quot;, function()&#123;</span><br><span class="line">//通过ajax提交请求</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">type: &quot;post&quot;,</span><br><span class="line">url: &quot;api/user/login&quot;,</span><br><span class="line">data: &#123;</span><br><span class="line">username: $loginBox.find(&quot;[name=username]&quot;).val(),</span><br><span class="line">password: $loginBox.find(&quot;[name=password]&quot;).val()</span><br><span class="line">&#125;,</span><br><span class="line">dataType: &quot;json&quot;,</span><br><span class="line">success: function(result)&#123;</span><br><span class="line">//提示信息</span><br><span class="line">$loginBox.find(&quot;.colWarning&quot;).html(result.message);</span><br><span class="line">// console.log(result);</span><br><span class="line">if(!result.code)&#123;</span><br><span class="line">//登录成功</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">//显示登录页面，隐藏注册页面</span><br><span class="line">$loginBox.hide();</span><br><span class="line">$userInfo.show();</span><br><span class="line"></span><br><span class="line">//将用户信息显示在页面上</span><br><span class="line">$userInfo.find(&quot;.username&quot;).html(result.userInfo.username);</span><br><span class="line">$userInfo.find(&quot;.info&quot;).html(&quot;你好，欢迎光临我的博客！😁&quot;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在routers/api.js中新增登录的路由</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//新增登录的路由</span><br><span class="line">/*</span><br><span class="line">登录</span><br><span class="line">*/</span><br><span class="line">router.post(&quot;/user/login&quot;, function(req, res, next)&#123;</span><br><span class="line">var username = req.body.username;</span><br><span class="line">var password = req.body.password;</span><br><span class="line"></span><br><span class="line">if(username == &quot;&quot; || password == &quot;&quot;)&#123;</span><br><span class="line">responseData.code = 1;</span><br><span class="line">responseData.message = &quot;用户名和密码不能为空&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查询数据库中相同用户名和密码的记录是否存在，如果存在则登录成功</span><br><span class="line">User.findOne(&#123;</span><br><span class="line">username: username,</span><br><span class="line">password: password</span><br><span class="line">&#125;).then(function(userInfo)&#123;</span><br><span class="line">if(!userInfo)&#123;</span><br><span class="line">responseData.code = 2;</span><br><span class="line">responseData.message = &quot;用户名或密码错误&quot;;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用户名和密码正确</span><br><span class="line">responseData.message = &quot;登录成功&quot;;</span><br><span class="line">//将登录信息返回前端页面</span><br><span class="line">responseData.userInfo = &#123;</span><br><span class="line">_id: userInfo._id,</span><br><span class="line">username: userInfo.username</span><br><span class="line">&#125;</span><br><span class="line">res.json(responseData);</span><br><span class="line">return;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学前需求&quot;&gt;&lt;a href=&quot;#学前需求&quot; class=&quot;headerlink&quot; title=&quot;学前需求&quot;&gt;&lt;/a&gt;学前需求&lt;/h2&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;一、node安装和运行&quot;&gt;&lt;a href=&quot;#一、node安装和运行&quot; class=&quot;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>express的路由</title>
    <link href="https://tianjiec.top/2018/12/20/express%E7%9A%84%E8%B7%AF%E7%94%B1/"/>
    <id>https://tianjiec.top/2018/12/20/express的路由/</id>
    <published>2018-12-20T02:42:13.000Z</published>
    <updated>2018-12-20T03:07:29.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="express路由与应用模式"><a href="#express路由与应用模式" class="headerlink" title="express路由与应用模式"></a>express路由与应用模式</h1><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><blockquote><p>Express是一个基于Node.js的轻量级web开发框架，具有体积小，使用灵活等特点。查看Express的源码，如果不计供使用的中间件，主体框架只有一千余行代码，非常简练。</p><p>Express模型的核心为Express中定义的路由和路由器。分析Express源码可发现Express的路由提供多种灵活的应用模式。</p><p>我们首先介绍一下Express中的路由、路由器相关概念、结构及其特点，然后针对典型场景描述使用Express路由的四种应用模式。</p></blockquote><h3 id="2-Express中的路由与路由器"><a href="#2-Express中的路由与路由器" class="headerlink" title="2.Express中的路由与路由器"></a>2.Express中的路由与路由器</h3><p>Express具有典型的MVC模型特征。我们将路由定义为一个二元组route=(path, endpoint)：其中path为HTTP请求的路径，endpoint为请求路径应映射到的端点（端点可视为处理该请求的实体）,则Express中的路由器负责将请求映射到对应端点进行处理。</p><p>Express中的路由器分为两种类型:</p><p>app类型的路由器常使用如下代码创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br></pre></td></tr></table></figure><p>router类型的路由器常使用如下代码创建:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br></pre></td></tr></table></figure><blockquote><p>app和router是形为function(request, response, next)形式的函数对象，使用app.verb()，router.verb()形式函数实现路由注册（路由注册本质上是一个观察者模式）。</p><p>app.verb()和router.verb()中的verb常使用use、get、post、put、delete、route等动词，不同动词管辖的HTTP请求方法范围不同，这些动词函数的参数形式常为(pathExp, handleCallback)形式：其中pathExp表示请求路径，可为正则表达式；handleCallback为路径映射处理函数。</p></blockquote><p>app是Express框架所构建程序的请求处理入口，app可作为顶层路由器使用，在应用中也可挂载下级路由器（使用router对象）以实现分级路由。其间的关系可由下图表示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://s1.51cto.com/images/20180716/1531726860898789.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="express对象关系图.jpg" title="">                </div>                <div class="image-caption">express对象关系图.jpg</div>            </figure><p><strong>考察如下代码：</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/reports'</span>, router1);</span><br><span class="line">router1.get(<span class="string">'/querymysql/:id'</span>, queryMysqlData, handleQueryData);</span><br></pre></td></tr></table></figure><blockquote><p>对于http请求URL“/reports/querymysql/1”，Express中的路由器将此请求路由到queryMysqlData函数处理。</p></blockquote><h3 id="3、Express中的路由应用模式"><a href="#3、Express中的路由应用模式" class="headerlink" title="3、Express中的路由应用模式"></a>3、Express中的路由应用模式</h3><h3 id="3-1-REST模式"><a href="#3-1-REST模式" class="headerlink" title="3.1.   REST模式"></a>3.1.   REST模式</h3><p>对于一个使用restful风格的应用, 让我们想一想在不使用Express的时候如何在Node.js中处理rest请求，我们常常会写下如下示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">switch</span> (request.url) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'uri1'</span></span><br><span class="line">                        handleUri1 (request, response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' uri2'</span></span><br><span class="line">                        handleU ri2(request, response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' uri3'</span></span><br><span class="line">                        handleU ri3 (request, response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' uri4'</span></span><br><span class="line">                        handleU ri4 (request, response);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        logToConsole(<span class="string">'unknown path:'</span> + path);</span><br><span class="line">                        response.writeHead(<span class="number">404</span>);</span><br><span class="line">                        response.end(<span class="string">"404 Not found"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Express将上面代码中对每个rest资源的操作(switch分支)转换为路由，路由中的路径为rest资源的URI，处理端点为function(request, response, next)形式、对rest资源的操作函数。</p><p>常使用app.route函数实现一个完整的restful接口，如下示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.route(<span class="string">'/uri1'</span>)</span><br><span class="line">  .get(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    handleGetUri1();</span><br><span class="line">  &#125;)</span><br><span class="line">  .post(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    handlePost Uri1 ();</span><br><span class="line">  &#125;)</span><br><span class="line">  .put(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    handlePut Uri <span class="number">1</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">.delete(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    handleDeleteUri <span class="number">1</span>();</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="3-2-AOP模式"><a href="#3-2-AOP模式" class="headerlink" title="3.2.   AOP模式"></a>3.2.   AOP模式</h3><p>在处理不同路径的HTTP请求时，常常需要在请求处理前和处理后做一些通用操作，这种应用需求是一个典型的AOP应用要求。</p><p>Express中允许定义一个具有通配路径的路由，在调用其它路径的路由前会先调用该通配路径路由。此通配路径路由也成为其它路径路由切面的一个注入点，考察如下示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.use(<span class="function"><span class="keyword">function</span> <span class="title">timelog</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"receive report request time is:"</span>,<span class="built_in">Date</span>.now());</span><br><span class="line">    next(); <span class="comment">//注意next函数的使用，必须声明该函数才能调用后继映射函数</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">router.get(<span class="string">'/chart1'</span>, proxy(&#123;</span><br><span class="line">    target: <span class="string">'http://127.0.0.1:8082'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">        <span class="string">'^/reports/chart1'</span>: <span class="string">'/loadChart1'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br><span class="line"> </span><br><span class="line">router.get(<span class="string">'/querymysql/:id'</span>, queryMysqlData, handleQueryData);</span><br></pre></td></tr></table></figure><p>上述代码中，在执行router的’/chart1’路由和’/querymysql/:id’路由之前都会执行timelog函数，在日志中记录当前路由执行时间。</p><h3 id="3-3-责任链模式"><a href="#3-3-责任链模式" class="headerlink" title="3.3.   责任链模式"></a>3.3.   责任链模式</h3><p>在Node.js中，由于多使用异步函数，常会出现异步回调函数中嵌套异步回调函数的情形。当出现多重异步回调时,则代码会变得混乱和难以维护。</p><p>考察一个应用场景：应用需要在数据库中进行多次查询，并对多次查询的结果综合处理。若使用数据库提供的异步查询接口，则需要在前一个查询操作的回调函数中进行下一个查询操作，若写在一个回调函数中，代码显臃肿。</p><p>Express的一个路由可定义多个处理函数，这些处理函数可设计为链式调用，实现了责任链模式，考察如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/test'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    handle1();</span><br><span class="line">    next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    handle2();</span><br><span class="line">    next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">   handle3();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述代码中：handle1, handle2, handle3构成了一个处理责任链“handle1-&gt;handle2-&gt;handle3”，通过next函数指引链式调用。</p><p>Express中路由的责任链应用特性使得多重异步嵌套的代码变得清晰和优雅。</p><p>​    针对本节开始提到的数据库查询应用场景，下面的示例代码展示了责任链模式的应用特点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/querymysql/:id'</span>, queryMysqlData, handleQueryData);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//查询mysql表中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryMysqlData</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"id"</span> <span class="keyword">in</span> req.params) &#123;</span><br><span class="line">        dbpool.query(<span class="string">" select * from articles where id=?"</span> ,[req.params.id], <span class="function"><span class="keyword">function</span> (<span class="params">err, rows, fields</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                res.send(err.stack);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rows &amp;&amp; rows.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'The queried rows is: '</span>, rows.length);</span><br><span class="line">                    res.articles = rows;</span><br><span class="line">                    next();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.send(<span class="string">"no query results!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.send(<span class="string">"invalid query params!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//处理查询mysql后得到的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleQueryData</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"articles"</span> <span class="keyword">in</span> res) &#123;</span><br><span class="line">        res.send(<span class="string">"id:"</span> + req.params.id + <span class="string">";title:"</span> + res.articles[<span class="number">0</span>].title);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.send(<span class="string">"no query data handled!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-熔断器模式"><a href="#3-4-熔断器模式" class="headerlink" title="3.4.   熔断器模式"></a>3.4.   熔断器模式</h3><p>上节提到的责任链模式本质上是一个逐级调用模型。在分布式服务架构（微服务架构）中，深度调用常常需要考虑调用可达性问题，即需要考虑某级调用会否一直不响应。调用可达性问题常使用熔断器模式，即在调用端设置一个熔断器，熔断条件产生时，熔断器发生熔断，返回给调用方调用失败信息。</p><p>考虑这样的应用场景：对于一些有处理时间要求的请求，当在指定时间内没有完成处理，需要向请求方返回处理失败信息。针对此应用场景，可在Express路由中设置超时熔断器，当处理超时，开启熔断器，通知请求方本次处理请求失败。</p><p>上述应用场景可使用如下示例代码应对：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/circuit'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bt=setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        next(<span class="string">'route'</span>); <span class="comment">//触发熔断</span></span><br><span class="line">    &#125;,<span class="number">3000</span>); <span class="comment">//设置熔断时间为3秒</span></span><br><span class="line">   res.breakTimer = bt;</span><br><span class="line">   next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    handle2();</span><br><span class="line">    next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">   handle3();</span><br><span class="line">   clearTimeout(res.breakTimer);<span class="comment">//正常执行完毕，取消熔断定时器</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/circuit '</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!res.finished)&#123; <span class="comment">//如果还没有响应，启动熔断</span></span><br><span class="line">    <span class="comment">//返回给调用者熔断信息</span></span><br><span class="line">    res.send(<span class="string">"breakCondition is true, notify the invoker."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="路径和句柄"><a href="#路径和句柄" class="headerlink" title="路径和句柄"></a>路径和句柄</h2><h3 id="理解了路径和句柄，才算真的会了Express路由的使用"><a href="#理解了路径和句柄，才算真的会了Express路由的使用" class="headerlink" title="理解了路径和句柄，才算真的会了Express路由的使用"></a>理解了路径和句柄，才算真的会了Express路由的使用</h3><p>路由：就是如何处理HTTP请求中的路径部分。</p><p>每个路径都会有对应的函数来处理（这个函数叫句柄），下面一个一个来说。</p><h4 id="一、有关路径"><a href="#一、有关路径" class="headerlink" title="一、有关路径"></a>一、有关路径</h4><p>路径可以是一个String类型也可以是一个正则表达式，例子：</p><p>1、当路径是String：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1053068413,3123129933&fm=173&s=AC9825D24BFEB6CA40BCCD030100E0C2&w=515&h=278&img.JPEG" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>如上图所示配置路由，页面分别访问：</p><p><a href="http://localhost:1234/abcd" target="_blank" rel="noopener">http://localhost:1234/abcd</a></p><p>输出：This is list</p><p><a href="http://localhost:1234/list/news/" target="_blank" rel="noopener">http://localhost:1234/list/news/</a></p><p>输出：This is news</p><p><a href="http://localhost:1234/list/news/123" target="_blank" rel="noopener">http://localhost:1234/list/news/123</a></p><p>输出：This is list news:123</p><p>2、当路径是正则表达式：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=1685331371,3718706668&fm=173&s=AC9835D3C9C8B4415AE5C50F0100E0C2&w=509&h=158&img.JPEG" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>第一个路由匹配的是/mobile/1[十个数字]，页面访问：</p><p><a href="http://localhost:1234/mobile/1XXXXXXXXXX" target="_blank" rel="noopener">http://localhost:1234/mobile/1XXXXXXXXXX</a></p><p>输出：This is a mobile phone ……</p><p>第二个路由匹配的是/abcd或者/acd。</p><h4 id="二、有关句柄"><a href="#二、有关句柄" class="headerlink" title="二、有关句柄"></a>二、有关句柄</h4><p>有关句柄，说两个问题</p><p>1、next和next（’route’）区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request,response,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req, res ,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    next(<span class="string">'route'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res ,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    next()</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">req, res ,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    next(<span class="string">'route'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上图所示，有三个地方加了next，实例测试发现：</p><p>当位置1是next()时，结果输出：1234</p><p>当位置1是next(‘router’)时，结果输出：134</p><h5 id="由此可见，二者的区别就是：next从下一个处理函数开始往下执行，next-‘router’-，直接执行下一个相同路由。"><a href="#由此可见，二者的区别就是：next从下一个处理函数开始往下执行，next-‘router’-，直接执行下一个相同路由。" class="headerlink" title="由此可见，二者的区别就是：next从下一个处理函数开始往下执行，next(‘router’)，直接执行下一个相同路由。"></a>由此可见，二者的区别就是：next从下一个处理函数开始往下执行，next(‘router’)，直接执行下一个相同路由。</h5><p>2】param</p><p>param在路由中也相当于是一个中间件作用。例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.param(<span class="string">"listname"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next, listname</span>)</span>&#123;</span><br><span class="line">    req.list = [<span class="string">'item0'</span>, <span class="string">'item1'</span>, <span class="string">'item2'</span>];</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">'/list/:listname'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'list:\n'</span> + req.list.join(<span class="string">''</span>));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面这个路由输出：list:item0item1item2</p><p>app.param会在路由前执行，需要注意的是listname参数一定要对应。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;express路由与应用模式&quot;&gt;&lt;a href=&quot;#express路由与应用模式&quot; class=&quot;headerlink&quot; title=&quot;express路由与应用模式&quot;&gt;&lt;/a&gt;express路由与应用模式&lt;/h1&gt;&lt;h3 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mongoose</title>
    <link href="https://tianjiec.top/2018/12/20/mongoose/"/>
    <id>https://tianjiec.top/2018/12/20/mongoose/</id>
    <published>2018-12-20T02:18:28.000Z</published>
    <updated>2018-12-20T02:23:42.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>　　Mongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具</p><p>　　那么要使用它，首先你得装上node.js和mongodb,关于mongodb的安装和操作介绍可以参考：<a href="http://www.cnblogs.com/zhongweiv/p/node_mongodb.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhongweiv/p/node_mongodb.html</a></p><p>　　Github地址：<a href="https://github.com/Automattic/mongoose" target="_blank" rel="noopener">https://github.com/Automattic/mongoose</a></p><p>　　API Docs：<a href="http://mongoosejs.com/docs/guide.html" target="_blank" rel="noopener">http://mongoosejs.com/docs/guide.html</a></p><p>　　前面有介绍过用node-mongodb-native来操作mongodb，实际开发中估计更多会选用类似mongoose的模块来操作来提升开发效率</p><p>　　下面我们一步步来了解mongoose的基本操作^_^!</p><h1 id="mongoose安装"><a href="#mongoose安装" class="headerlink" title="mongoose安装"></a>mongoose安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mongoose</span><br></pre></td></tr></table></figure><p>　　安装成功后如下图：</p><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images.cnblogs.com/cnblogs_com/zhongweiv/804376/o_1.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure></blockquote><p>　　安装成功后，就可以通过 require(‘mongoose’) 来使用！</p><h1 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h1><p>　　创建一个db.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line">DB_URL = <span class="string">'mongodb://localhost:27017/mongoosedemo'</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*连接</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mongoose.connect(DB_URL);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;　　Mongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具&lt;/p&gt;
&lt;p&gt;　　那么要使用它，首先你得装上no
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>框架初探-blog项目</title>
    <link href="https://tianjiec.top/2018/12/19/%E6%A1%86%E6%9E%B6%E5%88%9D%E6%8E%A2-blog%E9%A1%B9%E7%9B%AE/"/>
    <id>https://tianjiec.top/2018/12/19/框架初探-blog项目/</id>
    <published>2018-12-19T11:51:16.000Z</published>
    <updated>2018-12-19T11:51:16.179Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
