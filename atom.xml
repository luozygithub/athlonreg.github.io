<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chentj&#39;s Blog</title>
  
  <subtitle>Inflexible thinking, bad humor</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tianjiec.top/"/>
  <updated>2019-01-02T12:35:45.468Z</updated>
  <id>https://tianjiec.top/</id>
  
  <author>
    <name>chentj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>meta标签的作用及整理</title>
    <link href="https://tianjiec.top/2019/01/02/meta%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E6%95%B4%E7%90%86/"/>
    <id>https://tianjiec.top/2019/01/02/meta标签的作用及整理/</id>
    <published>2019-01-02T12:34:57.000Z</published>
    <updated>2019-01-02T12:35:45.468Z</updated>
    
    <content type="html"><![CDATA[<p>meta的标签的使用是我在前端学习中曾经困惑过一段时间的问题。一方面不是很了解meta标签的用途，另一方面是对于meta标签里的属性和值不是懂，也不知道从哪里冒出来的，所以这篇文章专门整理下meta标签，一个必用且关键的标签。</p><p>什么是meta标签？<br>引自下W3school的定义说明一下。</p><p>元数据（metadata）是关于数据的信息。</p><p>标签提供关于 HTML 文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。</p><p>典型的情况是，meta 元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。</p><p>标签始终位于 head 元素中。</p><p>元数据可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p><p>其实对上面的概念简单总结下就是：<meta> 标签提供关于 HTML 文档的元数据。它不会显示在页面上，但是对于机器是可读的。可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p><p>meta的作用<br>meta里的数据是供机器解读的，告诉机器该如何解析这个页面，还有一个用途是可以添加服务器发送到浏览器的http头部内容，例如我们为页面中添加如下meta标签：</p><p><meta http-equiv="charset" content="iso-8859-1"></p><p><meta http-equiv="expires" content="31 Dec 2008"><br>1<br>2<br>那么浏览器的头部就会包括这些:</p><p>charset:iso-8859-1<br>expires:31 Dec 2008<br>1<br>2<br>当然，只有浏览器可以接受这些附加的头部字段，并能以适当的方式使用它们时，这些字段才有意义。</p><p>meta的必需属性和可选属性<br>必需属性content<br>meta的必需属性是content，当然并不是说meta标签里一定要有content，而是当有http-equiv或name属性的时候，一定要有content属性对其进行说明。例如：</p><meta name="keywords" content="HTML,ASP,PHP,SQL"><p>这里面content里的属性就是对keywords进行的说明，所以呢也可以理解成一个键值对吧，就是{keywords:”HTML,ASP,PHP,SQL”}。</p><p>可选属性<br>在W3school中，对于meta的可选属性说到了三个，分别是http-equiv、name和scheme。考虑到scheme不是很常用，所以就只说下前两个属性吧。</p><p>http-equiv<br>http-equiv属性是添加http头部内容，对一些自定义的，或者需要额外添加的http头部内容，需要发送到浏览器中，我们就可以是使用这个属性。在上面的meta作用中也有简单的说明，那么现在再举个例子。例如我们不想使用js来重定向，用http头部内容控制，那么就可以这样控制：</p><p><meta http-equiv="Refresh" content="5;url=http://blog.yangchen123h.cn"><br>1<br>在页面中加入这个后，5秒钟后就会跳转到指定页面啦，效果可看W3school的例子</p><p>name<br>第二个可选属性是name，这个属性是供浏览器进行解析，对于一些浏览器兼容性问题，name属性是最常用的，当然有个前提就是浏览器能够解析你写进去的name属性才可以，不然就是没有意义的。还是举个例子吧:</p><p><meta name="renderer" content="webkit"><br>1<br>这个meta标签的意思就是告诉浏览器，用webkit内核进行解析，当然前提是浏览器有webkit内核才可以，不然就是没有意义的啦。当然看到这个你可能会有疑问，这个renderer是从哪里冒出来的，我要怎么知道呢？这个就是在对应的浏览器的开发文档里就会有表明的，例如这个renderer是在360浏览器里说明的。360浏览器内核控制Meta标签说明文档</p><p>常用meta标签大总结<br>接下来就是常用的meta标签大总结啦，我会尽可能的做到全</p><p>charset<br>charset是声明文档使用的字符编码，解决乱码问题主要用的就是它，值得一提的是，这个charset一定要写第一行，不然就可能会产生乱码了。</p><p>charset有两种写法</p><p><meta charset="utf-8"></p><p><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><br>1<br>2<br>两个都是等效的。</p><p>百度禁止转码<br>百度会自动对网页进行转码，这个标签是禁止百度的自动转码</p><p><meta http-equiv="Cache-Control" content="no-siteapp"><br>1<br>SEO 优化部分<br><!-- 页面标题<title>标签(head 头部必须) --></p><p><title>your title</title><br><!-- 页面关键词 keywords --></p><p><meta name="keywords" content="your keywords"><br><!-- 页面描述内容 description --></p><p><meta name="description" content="your description"><br><!-- 定义网页作者 author --></p><p><meta name="author" content="author,email address"><br><!-- 定义网页搜索引擎索引方式，robotterms 是一组使用英文逗号「,」分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。 --></p><p><meta name="robots" content="index,follow"><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>viewport<br>viewport主要是影响移动端页面布局的，例如：</p><meta name="viewport" content="width=device-width, initial-scale=1.0"><p>1<br>2<br>3<br>content 参数：</p><p>width viewport 宽度(数值/device-width)<br>height viewport 高度(数值/device-height)<br>initial-scale 初始缩放比例<br>maximum-scale 最大缩放比例<br>minimum-scale 最小缩放比例<br>user-scalable 是否允许用户缩放(yes/no)<br>各浏览器平台<br>Microsoft Internet Explorer<br><!-- 优先使用最新的ie版本 --></p><p><meta http-equiv="x-ua-compatible" content="ie=edge"><br><!-- 是否开启cleartype显示效果 --></p><p><meta http-equiv="cleartype" content="on"></p><meta name="skype_toolbar" content="skype_toolbar_parser_compatible"><!-- Pinned Site --><!-- IE 10 / Windows 8 --><p><meta name="msapplication-TileImage" content="pinned-tile-144.png"></p><p><meta name="msapplication-TileColor" content="#009900"><br><!-- IE 11 / Windows 9.1 --></p><p><meta name="msapplication-config" content="ieconfig.xml"><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>Google Chrome<br><!-- 优先使用最新的chrome版本 --></p><p><meta http-equiv="X-UA-Compatible" content="chrome=1"><br><!-- 禁止自动翻译 --></p><p><meta name="google" value="notranslate"><br>1<br>2<br>3<br>4<br>360浏览器<br><!-- 选择使用的浏览器解析内核 --></p><p><meta name="renderer" content="webkit|ie-comp|ie-stand"><br>1<br>2<br>UC手机浏览器<br><!-- 将屏幕锁定在特定的方向 --></p><p><meta name="screen-orientation" content="landscape/portrait"><br><!-- 全屏显示页面 --></p><p><meta name="full-screen" content="yes"><br><!-- 强制图片显示，即使是"text mode" --></p><p><meta name="imagemode" content="force"><br><!-- 应用模式，默认将全屏，禁止长按菜单，禁止手势，标准排版，强制图片显示。 --></p><p><meta name="browsermode" content="application"><br><!-- 禁止夜间模式显示 --></p><p><meta name="nightmode" content="disable"><br><!-- 使用适屏模式显示 --></p><p><meta name="layoutmode" content="fitscreen"><br><!-- 当页面有太多文字时禁止缩放 --></p><p><meta name="wap-font-scale" content="no"><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>UCBrowser_U3_API</p><p>QQ手机浏览器<br><!-- 锁定屏幕在特定方向 --></p><p><meta name="x5-orientation" content="landscape/portrait"><br><!-- 全屏显示 --></p><p><meta name="x5-fullscreen" content="true"><br><!-- 页面将以应用模式显示 --></p><p><meta name="x5-page-mode" content="app"><br>1<br>2<br>3<br>4<br>5<br>6<br>Apple iOS<br><!-- Smart App Banner --></p><meta name="apple-itunes-app" content="app-id=APP_ID,affiliate-data=AFFILIATE_ID,app-argument=SOME_TEXT"><!-- 禁止自动探测并格式化手机号码 --><meta name="format-detection" content="telephone=no"><!-- Add to Home Screen添加到主屏 --><!-- 是否启用 WebApp 全屏模式 --><p><meta name="apple-mobile-web-app-capable" content="yes"><br><!-- 设置状态栏的背景颜色,只有在 “apple-mobile-web-app-capable” content=”yes” 时生效 --></p><p><meta name="apple-mobile-web-app-status-bar-style" content="black"><br><!-- 添加到主屏后的标题 --></p><p><meta name="apple-mobile-web-app-title" content="App Title"><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>Google Android</p><p><meta name="theme-color" content="#E64545"><br><!-- 添加到主屏 --></p><p><meta name="mobile-web-app-capable" content="yes"><br><!-- More info: https://developer.chrome.com/multidevice/android/installtohomescreen --><br>1<br>2<br>3<br>4<br>App Links<br><!-- iOS --></p><p><meta property="al:ios:url" content="applinks://docs"></p><p><meta property="al:ios:app_store_id" content="12345"></p><p><meta property="al:ios:app_name" content="App Links"><br><!-- Android --></p><p><meta property="al:android:url" content="applinks://docs"></p><p><meta property="al:android:app_name" content="App Links"></p><p><meta property="al:android:package" content="org.applinks"><br><!-- Web Fallback --></p><p><meta property="al:web:url" content="http://applinks.org/documentation"><br><!-- More info: http://applinks.org/documentation/ --><br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>最后——移动端常用的meta</p><p><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"></p><p><meta name="apple-mobile-web-app-capable" content="yes"></p><p><meta name="apple-mobile-web-app-status-bar-style" content="black"></p><p><meta name="format-detection" content="telephone=no, email=no"></p><p><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"></p><p><meta name="apple-mobile-web-app-capable" content="yes"><!-- 删除苹果默认的工具栏和菜单栏 --></p><p><meta name="apple-mobile-web-app-status-bar-style" content="black"><!-- 设置苹果工具栏颜色 --></p><p><meta name="format-detection" content="telphone=no, email=no"><!-- 忽略页面中的数字识别为电话，忽略email识别 --><br><!-- 启用360浏览器的极速模式(webkit) --></p><p><meta name="renderer" content="webkit"><br><!-- 避免IE使用兼容模式 --></p><p><meta http-equiv="X-UA-Compatible" content="IE=edge"><br><!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --></p><p><meta name="HandheldFriendly" content="true"><br><!-- 微软的老式浏览器 --></p><p><meta name="MobileOptimized" content="320"><br><!-- uc强制竖屏 --></p><p><meta name="screen-orientation" content="portrait"><br><!-- QQ强制竖屏 --></p><p><meta name="x5-orientation" content="portrait"><br><!-- UC强制全屏 --></p><p><meta name="full-screen" content="yes"><br><!-- QQ强制全屏 --></p><p><meta name="x5-fullscreen" content="true"><br><!-- UC应用模式 --></p><p><meta name="browsermode" content="application"><br><!-- QQ应用模式 --></p><p><meta name="x5-page-mode" content="app"><br><!-- windows phone 点击无高光 --></p><p><meta name="msapplication-tap-highlight" content="no"></p><h2 id=""><a href="#" class="headerlink" title=""></a><!-- 适应移动端end --></h2><p>作者：阿Q虾米<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/yc123h/article/details/51356143" target="_blank" rel="noopener">https://blog.csdn.net/yc123h/article/details/51356143</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;meta的标签的使用是我在前端学习中曾经困惑过一段时间的问题。一方面不是很了解meta标签的用途，另一方面是对于meta标签里的属性和值不是懂，也不知道从哪里冒出来的，所以这篇文章专门整理下meta标签，一个必用且关键的标签。&lt;/p&gt;
&lt;p&gt;什么是meta标签？&lt;br&gt;引自
      
    
    </summary>
    
    
      <category term="js" scheme="https://tianjiec.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ES6模块的import和export用法总结</title>
    <link href="https://tianjiec.top/2019/01/02/ES6%E6%A8%A1%E5%9D%97%E7%9A%84import%E5%92%8Cexport%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://tianjiec.top/2019/01/02/ES6模块的import和export用法总结/</id>
    <published>2019-01-02T12:33:21.000Z</published>
    <updated>2019-01-02T12:36:04.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6模块的import和export用法总结"><a href="#ES6模块的import和export用法总结" class="headerlink" title="ES6模块的import和export用法总结"></a><a href="https://www.cnblogs.com/dupd/p/5951311.html" target="_blank" rel="noopener">ES6模块的import和export用法总结</a></h1><p>ES6之前已经出现了js模块加载的方案，最主要的是CommonJS和AMD规范。commonjs主要应用于服务器，实现同步加载，如nodejs。AMD规范应用于浏览器，如requirejs，为异步加载。同时还有CMD规范，为同步加载方案如seaJS。</p><p>ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6模块主要有两个功能：export和import</p><p>export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口</p><p>import用于在一个模块中加载另一个含有export接口的模块。</p><p>也就是说使用<code>export</code>命令定义了模块的对外接口以后，其他JS文件就可以通过<code>import</code>命令加载这个模块（文件）。如下图(假设a和b文件在同一目录下)</p><p>按 Ctrl+C 复制代码</p><p>按 Ctrl+C 复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// b.js</span><br><span class="line">通过import获取a.js文件的内部变量，&#123;&#125;括号内的变量来自于a.js文件export出的变量标识符。</span><br><span class="line">import &#123;sex,echo&#125; from &quot;./a.js&quot; </span><br><span class="line">console.log(sex)   // boy</span><br><span class="line">echo(sex) // boy</span><br></pre></td></tr></table></figure><p>a.js文件也可以按如下export语法写，但不如上边直观，不太推荐。</p><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="javascript:void(0);" alt="复制代码](https://common.cnblogs.com/images/copycode.gif)" title="">                </div>                <div class="image-caption">复制代码](https://common.cnblogs.com/images/copycode.gif)</div>            </figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">export var sex=&quot;boy&quot;;</span><br><span class="line">export var echo=function(value)&#123;</span><br><span class="line">　　console.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//因为function echo()&#123;&#125;等价于 var echo=function()&#123;&#125;所以也可以写成</span><br><span class="line">export function echo(value)&#123;</span><br><span class="line">　　　console.log(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="javascript:void(0);" alt="复制代码](https://common.cnblogs.com/images/copycode.gif)" title="">                </div>                <div class="image-caption">复制代码](https://common.cnblogs.com/images/copycode.gif)</div>            </figure></p><p><strong>以上是export与module的基本用法，再进行拓展学习</strong></p><p>前面的例子可以看出，b.js使用<code>import</code>命令的时候，用户需要知道a.js所暴露出的变量标识符，否则无法加载。可以使用<strong>export default</strong>命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//a.js</span><br><span class="line">var sex=&quot;boy&quot;;</span><br><span class="line">export default sex（sex不能加大括号）</span><br><span class="line">//原本直接export sex外部是无法识别的，加上default就可以了.但是一个文件内最多只能有一个export default。</span><br><span class="line">其实此处相当于为sex变量值&quot;boy&quot;起了一个系统默认的变量名default，自然default只能有一个值，所以一个文件内不能有多个export default。</span><br></pre></td></tr></table></figure><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="javascript:void(0);" alt="复制代码](https://common.cnblogs.com/images/copycode.gif)" title="">                </div>                <div class="image-caption">复制代码](https://common.cnblogs.com/images/copycode.gif)</div>            </figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// b.js</span><br><span class="line">本质上，a.js文件的export default输出一个叫做default的变量，然后系统允许你为它取任意名字。所以可以为import的模块起任何变量名，且不需要用大括号包含</span><br><span class="line">import any from &quot;./a.js&quot;</span><br><span class="line">import any12 from &quot;./a.js&quot; </span><br><span class="line">console.log(any,any12)   // boy,boy</span><br></pre></td></tr></table></figure><p>原文：<a href="https://www.cnblogs.com/dupd/p/5951311.html" target="_blank" rel="noopener">https://www.cnblogs.com/dupd/p/5951311.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6模块的import和export用法总结&quot;&gt;&lt;a href=&quot;#ES6模块的import和export用法总结&quot; class=&quot;headerlink&quot; title=&quot;ES6模块的import和export用法总结&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://
      
    
    </summary>
    
    
      <category term="es6" scheme="https://tianjiec.top/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>移动端开发</title>
    <link href="https://tianjiec.top/2018/12/30/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    <id>https://tianjiec.top/2018/12/30/移动端开发/</id>
    <published>2018-12-30T12:40:46.000Z</published>
    <updated>2018-12-30T12:57:51.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移动端开发"><a href="#移动端开发" class="headerlink" title="移动端开发"></a>移动端开发</h1><h3 id="Viewport视口的作用："><a href="#Viewport视口的作用：" class="headerlink" title="Viewport视口的作用："></a>Viewport视口的作用：</h3><p>通俗的讲，移动设备上的viewport就是设备屏幕上能用来显示我们网页的那一块区域，再具体一点，就是浏览器上（也可能是一个app中的webview）用来显示网页的那部分区域，但viewport又不局限与浏览器的可视区域大小，它可能比浏览器的可视区域要大，也可能比浏览器可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是比大于浏览器可视区域的，这是因为考虑到移动设备分辨率相对于桌面电脑来说都比较小，所以为了能够在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或者1024px（也可能是其它值，有设备决定），但带来的后果是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。</p><h5 id="网页不是直接放到浏览器中，而是先放到视口中，然后等比例缩放到浏览器中。当浏览器宽度小于980时，浏览器宽度就为980"><a href="#网页不是直接放到浏览器中，而是先放到视口中，然后等比例缩放到浏览器中。当浏览器宽度小于980时，浏览器宽度就为980" class="headerlink" title="网页不是直接放到浏览器中，而是先放到视口中，然后等比例缩放到浏览器中。当浏览器宽度小于980时，浏览器宽度就为980"></a>网页不是直接放到浏览器中，而是先放到视口中，然后等比例缩放到浏览器中。当浏览器宽度小于980时，浏览器宽度就为980</h5><h5 id="浏览器宽度大于980时，宽度为视口此时的宽度"><a href="#浏览器宽度大于980时，宽度为视口此时的宽度" class="headerlink" title="浏览器宽度大于980时，宽度为视口此时的宽度"></a>浏览器宽度大于980时，宽度为视口此时的宽度</h5><h5 id="document-documentElement-clientWidth-获取视口宽度"><a href="#document-documentElement-clientWidth-获取视口宽度" class="headerlink" title="document.documentElement.clientWidth 获取视口宽度"></a>document.documentElement.clientWidth 获取视口宽度</h5><h5 id="user-scalable-none-：-用户不能缩放"><a href="#user-scalable-none-：-用户不能缩放" class="headerlink" title="user-scalable=none ： 用户不能缩放"></a>user-scalable=none ： 用户不能缩放</h5><h5 id="dpr：设备像素比：设备像素-物理-逻辑-2"><a href="#dpr：设备像素比：设备像素-物理-逻辑-2" class="headerlink" title="dpr：设备像素比：设备像素 = 物理/逻辑 = 2"></a>dpr：设备像素比：设备像素 = 物理/逻辑 = 2</h5><h5 id="现有手机dpr-一般为2-，-也就是四个像素点-当做一个像素点去用。"><a href="#现有手机dpr-一般为2-，-也就是四个像素点-当做一个像素点去用。" class="headerlink" title="现有手机dpr 一般为2 ， 也就是四个像素点 当做一个像素点去用。"></a>现有手机dpr 一般为2 ， 也就是四个像素点 当做一个像素点去用。</h5><h4 id="我们一般以iPhone5-iPhone6-为例制作设计稿"><a href="#我们一般以iPhone5-iPhone6-为例制作设计稿" class="headerlink" title="我们一般以iPhone5 / iPhone6 为例制作设计稿"></a>我们一般以iPhone5 / iPhone6 为例制作设计稿</h4><p>且以两倍图设计</p><p>因为如果不按照两倍图去设计 会先被放大，再等比例缩小放入浏览器。在放大的过程中会失真</p><h3 id="rem布局"><a href="#rem布局" class="headerlink" title="rem布局"></a>rem布局</h3><h4 id="以iphone5设计稿为例-640px-在设计稿当中宽度为320px，那么手机端应该是160px"><a href="#以iphone5设计稿为例-640px-在设计稿当中宽度为320px，那么手机端应该是160px" class="headerlink" title="//以iphone5设计稿为例  640px 在设计稿当中宽度为320px，那么手机端应该是160px"></a>//以iphone5设计稿为例  640px 在设计稿当中宽度为320px，那么手机端应该是160px</h4><h5 id="1、设置htmlfont-size"><a href="#1、设置htmlfont-size" class="headerlink" title="//1、设置htmlfont-size"></a>//1、设置htmlfont-size</h5><h4 id="document-documentELement-style-fontSIze-document-documentElement-clientWidth-3-2-“px”"><a href="#document-documentELement-style-fontSIze-document-documentElement-clientWidth-3-2-“px”" class="headerlink" title="document.documentELement.style.fontSIze = document.documentElement.clientWidth / 3.2 + “px”"></a>document.documentELement.style.fontSIze = document.documentElement.clientWidth / 3.2 + “px”</h4><h5 id="2、其他元素宽度"><a href="#2、其他元素宽度" class="headerlink" title="//2、其他元素宽度"></a>//2、其他元素宽度</h5><p>rem= width px/fontSIze</p><p>设计稿上面 宽度320px占一半=》在逻辑稿里面宽度为160px  然后根据上述计算的出 比例</p><p>rem为1.6rem</p><h4 id="以iphone6来设计-750设计稿-逻辑宽度为375px"><a href="#以iphone6来设计-750设计稿-逻辑宽度为375px" class="headerlink" title="//以iphone6来设计   750设计稿 逻辑宽度为375px"></a>//以iphone6来设计   750设计稿 逻辑宽度为375px</h4><p>document.documentELement.style.fontSIze = document.documentElement.clientWidth / 3.75 + “px”</p><p>#### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;移动端开发&quot;&gt;&lt;a href=&quot;#移动端开发&quot; class=&quot;headerlink&quot; title=&quot;移动端开发&quot;&gt;&lt;/a&gt;移动端开发&lt;/h1&gt;&lt;h3 id=&quot;Viewport视口的作用：&quot;&gt;&lt;a href=&quot;#Viewport视口的作用：&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="html" scheme="https://tianjiec.top/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>rem</title>
    <link href="https://tianjiec.top/2018/12/29/rem/"/>
    <id>https://tianjiec.top/2018/12/29/rem/</id>
    <published>2018-12-29T07:12:14.000Z</published>
    <updated>2018-12-30T12:34:42.461Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：</p><p><a href="http://caibaojian.com/web-app-rem.html" target="_blank" rel="noopener">http://caibaojian.com/web-app-rem.html</a></p><h2 id="rem是什么？"><a href="#rem是什么？" class="headerlink" title="rem是什么？"></a>rem是什么？</h2><p>rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。<a href="http://caibaojian.com/web-app-rem.html" target="_blank" rel="noopener">·</a></p><p>摘要：<a href="http://caibaojian.com/t/rem" target="_blank" rel="noopener">rem</a>是相对于根元素<html>，这样就意味着，我们只需要在根元素确定一个px字号，则可以来算出元素的宽高。本文讲的是如何使用<a href="http://caibaojian.com/t/rem" target="_blank" rel="noopener">rem</a>实现自适应。<a href="http://caibaojian.com/web-app-rem.html" target="_blank" rel="noopener">·</a></html></p><p>rem这是个低调的css单位，近一两年开始崭露头角，有许多同学对rem的评价不一，有的在尝试使用，有的在使用过程中遇到坑就弃用了。但是我对rem综合评价是用来做<a href="http://caibaojian.com/c/web" target="_blank" rel="noopener">web</a> app它绝对是最合适的人选之一。</p><h2 id="为什么web-app要使用rem？"><a href="#为什么web-app要使用rem？" class="headerlink" title="为什么web app要使用rem？"></a>为什么web app要使用rem？</h2><p>这里我特别强调web app，web page就不能使用rem吗，其实也当然可以，不过出于兼容性的考虑在web app下使用更加能突显这个单位的价值和能力，接下来我们来看看目前一些企业的web app是怎么做屏幕适配的。</p><h3 id="1、实现强大的屏幕适配布局："><a href="#1、实现强大的屏幕适配布局：" class="headerlink" title="1、实现强大的屏幕适配布局："></a>1、实现强大的屏幕适配布局：</h3><p>最近iphone6一下出了两款尺寸的手机，导致的移动端的屏幕种类更加的混乱，记得一两年前做web app有一种做法是以320宽度为标准去做适配，超过320的大小还是以320的规格去展示，这种实现方式以淘宝web app为代表作，但是近期手机淘宝首页进行了改版，采用了rem这个单位，首页以内依旧是和以前一样各种混乱，有定死宽度的页面，也有那种流式布局的页面。</p><p>我们现在在切页面布局的使用常用的单位是px，这是一个绝对单位，web app的屏幕适配有很多中做法，例如：流式布局、限死宽度，还有就是通过<a href="http://caibaojian.com/356.html" target="_blank" rel="noopener">响应式</a>来做，但是这些方案都不是最佳的解决方法。<a href="http://caibaojian.com/web-app-rem.html" target="_blank" rel="noopener">·</a></p><p>例如流式布局的解决方案有不少弊端，它虽然可以让各种屏幕都适配，但是显示的效果极其的不好，因为只有几个尺寸的手机能够完美的显示出视觉设计师和交互最想要的效果，但是目前行业里用流式布局切web app的公司还是挺多的，看看下面我收集的一些案例：</p><p>1.亚马逊：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pic.caibaojian.com/uploads/2015/12/1418896965.jpeg" alt="1418896965" title="">                </div>                <div class="image-caption">1418896965</div>            </figure><p>2.携程：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pic.caibaojian.com/uploads/2015/12/1418891322.jpeg" alt="原文来自http://caibaojian.com/web-app-rem.html" title="">                </div>                <div class="image-caption">原文来自http://caibaojian.com/web-app-rem.html</div>            </figure><p>3.兰亭</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pic.caibaojian.com/uploads/2015/12/1418891825.jpeg" alt="1418891825" title="">                </div>                <div class="image-caption">1418891825</div>            </figure><p>上面的网站都是采用的流式布局的技术实现的，他们在页面布局的时候都是通过百分比来定义宽度，但是高度大都是用px来固定住，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度还是和原来一样，实际显示非常的不协调，这就是流式布局的最致命的缺点，往往只有几个尺寸的手机下看到的效果是令人满意的，其实很多视觉设计师应该无法接受这种效果，因为他们的设计图在大屏幕手机下看到的效果相当于是被横向拉长来一样。</p><p>流式布局并不是最理想的实现方式，通过大量的百分比布局，会经常出现许多兼容性的问题，还有就是对设计有很多的限制，因为他们在设计之初就需要考虑流式布局对元素造成的影响，只能设计横向拉伸的元素布局，设计的时候存在很多局限性。</p><h3 id="2-固定宽度做法"><a href="#2-固定宽度做法" class="headerlink" title="2.固定宽度做法"></a>2.固定宽度做法</h3><p>还有一种是固定页面宽度的做法，早期有些网站把页面设置成320的宽度，超出部分留白，这样做视觉，前端都挺开心，视觉在也不用被流式布局限制自己的设计灵感了，前端也不用在搞坑爹的流式布局。但是这种解决方案也是存在一些问题，例如在大屏幕手机下两边是留白的，还有一个就是大屏幕手机下看起来页面会特别小，操作的按钮也很小，手机淘宝首页起初是这么做的，但近期改版了，采用了rem。</p><h3 id="3-响应式做法"><a href="#3-响应式做法" class="headerlink" title="3.响应式做法"></a>3.响应式做法</h3><p>响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是工作大，维护性难，所以一般都是中小型的门户或者博客类站点会采用响应式的方法从web page到web app直接一步到位，因为这样反而可以节约成本，不用再专门为自己的网站做一个web app的版本。</p><h3 id="4-设置viewport进行缩放"><a href="#4-设置viewport进行缩放" class="headerlink" title="4.设置viewport进行缩放"></a>4.设置viewport进行缩放</h3><p>天猫的web app的首页就是采用这种方式去做的，以320宽度为基准，进行缩放，最大缩放为320*1.3 = 416，基本缩放到416都就可以兼容iphone6 plus的屏幕了，这个方法简单粗暴，又高效。说实话我觉得他和用接下去我们要讲的rem都非常高效，不过有部分同学使用过程中反应缩放会导致有些页面元素会糊的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=320,maximum-scale=1.3,user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="rem能等比例适配所有屏幕"><a href="#rem能等比例适配所有屏幕" class="headerlink" title="rem能等比例适配所有屏幕"></a>rem能等比例适配所有屏幕</h2><p>上面讲了一大堆目前大部分公司主流的一些web app的适配解决方案，接下来讲下rem是如何工作的。</p><p>上面说过rem是通过根元素进行适配的，网页中的根元素指的是html我们通过设置html的字体大小就可以控制rem的大小。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">html&#123;</span><br><span class="line">    font-size:20px;</span><br><span class="line">&#125;</span><br><span class="line">.btn &#123;</span><br><span class="line">    width: 6rem;</span><br><span class="line">    height: 3rem;</span><br><span class="line">    line-height: 3rem;</span><br><span class="line">    font-size: 1.2rem;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    background: #06c;</span><br><span class="line">    color: #fff;</span><br><span class="line">    border-radius: .5rem;</span><br><span class="line">    text-decoration: none;</span><br><span class="line">    text-align: center;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo 上面代码结果按钮大小如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pic.caibaojian.com/uploads/2015/12/1418899506.jpeg" alt="1418899506" title="">                </div>                <div class="image-caption">1418899506</div>            </figure><p>我把html设置成10px是为了方便我们计算，为什么6rem等于60px。如果这个时候我们的.btn的样式不变，我们再改变html的font-size的值，看看按钮发生上面变化:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//code from http://caibaojian.com/web-app-rem.html</span><br><span class="line">html&#123;</span><br><span class="line">    font-size:40px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo</p><p>按钮大小结果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pic.caibaojian.com/uploads/2015/12/1418898055.jpeg" alt="1418898055" title="">                </div>                <div class="image-caption">1418898055</div>            </figure><p>上面的width，height变成了上面结果的两倍，我们只改变了html的font-size，但.btn样式的width,height的rem设置的属性不变的情况下就改变了按钮在web中的大小。</p><p>其实从上面两个案例中我们就可以计算出1px多少rem:</p><p>第一个例子：</p><p>120px = 6rem * 20px(根元素设置大值)</p><p>第二个例子：</p><p>240px = 6rem * 40px(根元素设置大值)</p><p>推算出：</p><p>10px  = 1rem 在根元素（font-size = 10px的时候）；</p><p>20px  = 1rem 在根元素（font-size = 20px的时候）；</p><p>40px  = 1rem 在根元素（font-size = 40px的时候）；</p><p>在上面两个例子中我们发现第一个案例按钮是等比例放大到第二个按钮，html font-size的改变就会导致按钮的大小发生改变，我们并不需要改变先前给按钮设置的宽度和高度，其实这就是我们最想看到的，为什么这么说？接下来我们再来看一个例子：</p><p>Demo</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pic.caibaojian.com/uploads/2015/12/1418873132.jpeg" alt="1418873132" title="">                </div>                <div class="image-caption">1418873132</div>            </figure><p>由上面两个的demo中我们知道改变html的font-size可以等比改变所有用了rem单位的元素，所以大家可以通过chrome浏览器的调试工具去切换第三个的demo在不同设备下的展示效果，或者通过缩放浏览器的宽度来查看效果，我们可以看到不管在任何分辨率下，页面的排版都是按照等比例进行切换，并且布局没有乱。我只是通过一段js根据浏览器当前的分辨率改变font-size的值，就简单的实现了上面的效果，页面的所有元素都不需要进行任何改变。</p><p><strong>到这里肯定有很多人会问我是怎么计算出不同分辨率下font-size的值？</strong></p><p>首先假设我上面的页面设计稿给我时候是按照640的标准尺寸给我的前提下，（当然这个尺寸肯定不一定是640，可以是320，或者480，又或是375）来看一组表格。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pic.caibaojian.com/uploads/2015/12/1418903956.jpeg" alt="1418903956" title="">                </div>                <div class="image-caption">1418903956</div>            </figure><p>上面的表格蓝色一列是Demo3中页面的尺寸，页面是以640的宽度去切的，怎么计算不同宽度下font-site的值，大家看表格上面的数值变化应该能明白。举个例子：384/640 = 0.6，384是640的0.6倍，所以384页面宽度下的font-size也等于它的0.6倍，这时384的font-size就等于12px。在不同设备的宽度计算方式以此类推。</p><p>Demo3中我是通过<a href="http://caibaojian.com/javascript/" target="_blank" rel="noopener">JS</a>去动态计算根元素的font-size，这样的好处是所有设备分辨率都能兼容适配，淘宝首页目前就是用的JS计算。但其实不用JS我们也可以做适配，一般我们在做web app都会先统计自己网站有哪些主流的屏幕设备，然后去针对那些设备去做media query设置也可以实现适配，例如下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">    font-size : 20px;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 401px)&#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 25px !important;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 428px)&#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 26.75px !important;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 481px)&#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 30px !important; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 569px)&#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 35px !important; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 641px)&#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 40px !important; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的做的设置当然是不能所有设备全适配，但是用JS是可以实现全适配。具体用哪个就要根据自己的实际工作场景去定了。</p><p>下面推荐两个国内用了rem技术的移动站，大家可以上去参考看看他们的做法，手机淘宝目前只有首页用了rem，淘宝native app的首页是内嵌的web app首页。</p><p><strong>淘宝首页</strong>：m.taobao.com</p><p><strong>D X</strong>：m.dx.com</p><h3 id="最后我们再来看一看他的兼容性："><a href="#最后我们再来看一看他的兼容性：" class="headerlink" title="最后我们再来看一看他的兼容性："></a>最后我们再来看一看他的兼容性：</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pic.caibaojian.com/uploads/2015/12/1418894538.png" alt="1418894538" title="">                </div>                <div class="image-caption">1418894538</div>            </figure><h3 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h3><p>@blinkcat，rem是可以合并雪碧图的，viewport设置确实简洁，但是过于粗暴，全局都进行缩放，有时候我布局并不希望全局缩放，部分布局希望不用缩放，所以使用rem，不过具体使用什么方法大家都可以根据实际情况衡量。并不是每个人都喜欢使用sass，所以在px转rem这块我做了一个在线转换工具：<a href="http://520ued.com/tools/rem" target="_blank" rel="noopener">http://520ued.com/tools/rem</a></p><h3 id="REM自适应JS"><a href="#REM自适应JS" class="headerlink" title="REM自适应JS"></a>REM<a href="http://caibaojian.com/t/自适应" target="_blank" rel="noopener">自适应</a>JS</h3><p>具体使用方法请参考这篇文章：<a href="http://caibaojian.com/simple-flexible.html" target="_blank" rel="noopener">Rem精简版实现自适应-优化flexible.js</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//designWidth:设计稿的实际宽度值，需要根据实际设置</span><br><span class="line">//maxWidth:制作稿的最大宽度值，需要根据实际设置</span><br><span class="line">//这段js的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为750，最大宽度为750，则为(750,750)</span><br><span class="line">;(function(designWidth, maxWidth) &#123;</span><br><span class="line">var doc = document,</span><br><span class="line">win = window,</span><br><span class="line">docEl = doc.documentElement,</span><br><span class="line">remStyle = document.createElement(&quot;style&quot;),</span><br><span class="line">tid;</span><br><span class="line"></span><br><span class="line">function refreshRem() &#123;</span><br><span class="line">var width = docEl.getBoundingClientRect().width;</span><br><span class="line">maxWidth = maxWidth || 540;</span><br><span class="line">width&gt;maxWidth &amp;&amp; (width=maxWidth);</span><br><span class="line">var rem = width * 100 / designWidth;</span><br><span class="line">remStyle.innerHTML = &apos;html&#123;font-size:&apos; + rem + &apos;px;&#125;&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (docEl.firstElementChild) &#123;</span><br><span class="line">docEl.firstElementChild.appendChild(remStyle);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">var wrap = doc.createElement(&quot;div&quot;);</span><br><span class="line">wrap.appendChild(remStyle);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://caibaojian.com/web-app-rem.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://caibaojian.com/web-app-rem.html&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="html" scheme="https://tianjiec.top/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>vue脚手架各文件意义</title>
    <link href="https://tianjiec.top/2018/12/29/vue%E8%84%9A%E6%89%8B%E6%9E%B6%E5%90%84%E6%96%87%E4%BB%B6%E6%84%8F%E4%B9%89/"/>
    <id>https://tianjiec.top/2018/12/29/vue脚手架各文件意义/</id>
    <published>2018-12-29T02:40:36.000Z</published>
    <updated>2018-12-30T12:32:36.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue2全家桶之一：vue-cli（vue脚手架）超详细教程"><a href="#Vue2全家桶之一：vue-cli（vue脚手架）超详细教程" class="headerlink" title="Vue2全家桶之一：vue-cli（vue脚手架）超详细教程"></a>Vue2全家桶之一：vue-cli（vue脚手架）超详细教程</h1><blockquote><p>vue.js有著名的全家桶系列，包含了vue-router，vuex， vue-resource，再加上构建工具vue-cli，就是一个完整的vue项目的核心构成。</p></blockquote><h4 id="1-安装vue-cli"><a href="#1-安装vue-cli" class="headerlink" title="1.安装vue-cli"></a>1.安装vue-cli</h4><p><strong>①</strong> 使用npm（需要安装node环境）<strong>全局安装webpack</strong>，打开命令行工具输入：<code>npm install webpack -g</code>或者（<code>npm install -g webpack</code>），安装完成之后输入 <code>webpack -v</code>，如下图，如果出现相应的版本号，则说明安装成功。</p><p><strong>②</strong> <strong>全局安装vue-cli</strong>，在cmd中输入命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global vue-cli</span><br></pre></td></tr></table></figure><p>（我已经安装过，为了更直观我在电脑上重新演示下）</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-12cb0bef236c50fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/675/format/webp" alt="img"></p><p>安装成功：</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-ac2a13a62505d1ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/671/format/webp" alt="img"></p><p> 安装完成之后输入 vue -V（注意这里是大写的“V”），如下图，如果出现相应的版本号，则说明安装成功。</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-d8e864620a0b5aef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/292/format/webp" alt="img"></p><p>打开C:\Users\Andminster\AppData\Roaming\npm目录下可以看到：</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-9d5e131d9681c0d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/765/format/webp" alt="img"></p><p> 打开node_modules也可以看到：</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-6e55eb6b7d70ac91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550/format/webp" alt="img"></p><h4 id="2-用vue-cli来构建项目"><a href="#2-用vue-cli来构建项目" class="headerlink" title="2.用vue-cli来构建项目"></a>2.用vue-cli来构建项目</h4><p><strong>①</strong> 我首先在D盘新建一个文件夹（dxl_vue）作为项目存放地，然后使用命令行cd进入到项目目录输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack baoge</span><br></pre></td></tr></table></figure><p>baoge是自定义的项目名称，命令执行之后，会在当前目录生成一个以该名称命名的项目文件夹。</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-22cf1a5dc4cda33d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/659/format/webp" alt="img"></p><p>输入命令后，会跳出几个选项让你回答：</p><ul><li>Project name (baoge)：     —–项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，如果有会报错Sorry, name can no longer contain capital letters），阮一峰老师博客<a href="https://link.jianshu.com?t=http://www.ruanyifeng.com/blog/2017/02/filename-should-be-lowercase.html" target="_blank" rel="noopener">为什么文件名要小写</a> ，可以参考一下。</li><li>Project description (A Vue.js project)：  —-项目描述，也可直接点击回车，使用默认名字</li><li>Author ()：       —-作者，输入dongxili<br> 接下来会让用户选择：</li><li>Runtime + Compiler: recommended for most users    运行加编译，既然已经说了推荐，就选它了<br> Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere   仅运行时，已经有推荐了就选择第一个了</li><li>Install vue-router? (Y/n)    是否安装vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。</li><li>Use ESLint to lint your code? (Y/n)      是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。<br> 接下来也是选择题Pick an ESLint preset (Use arrow keys)            选择一个ESLint预设，编写vue项目时的代码风格，直接y回车</li><li>Setup unit tests with Karma + Mocha? (Y/n)  是否安装单元测试，我选择安装y回车</li><li>Setup e2e tests with Nightwatch(Y/n)?     是否安装e2e测试 ，我选择安装y回车</li></ul><p>回答完毕后上图就开始构建项目了。</p><p><strong>②</strong> 配置完成后，可以看到目录下多出了一个项目文件夹baoge，然后cd进入这个文件夹：<br> <strong>安装依赖</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p> ( 如果安装速度太慢。可以安装淘宝镜像，打开命令行工具，输入：<br>  <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code><br>  然后使用<code>cnpm</code>来安装 )</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-a5701c92e10ce959.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/664/format/webp" alt="img"></p><p>npm install ：安装所有的模块，如果是安装具体的哪个个模块，在install 后面输入模块的名字即可。而只输入install就会按照项目的根目录下的package.json文件中依赖的模块安装（这个文件里面是不允许有任何注释的），每个使用npm管理的项目都有这个文件，是npm操作的入口文件。因为是初始项目，还没有任何模块，所以我用npm install 安装所有的模块。安装完成后，目录中会多出来一个node_modules文件夹，这里放的就是所有依赖的模块。</p><p> 然后现在，baoge文件夹里的目录是这样的：</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-84cb6c247eba4438.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/615/format/webp" alt="img"></p><p> 解释下每个文件夹代表的意思(仔细看一下这张图）：</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-01a038fa573b22c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/443/format/webp" alt="img"></p><p>image.png</p><h4 id="3-启动项目"><a href="#3-启动项目" class="headerlink" title="3.启动项目"></a>3.启动项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p> 如果浏览器打开之后，没有加载出页面，有可能是本地的 8080 端口被占用，需要修改一下配置文件 config里的index.js</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-3a6a5874d3e8d445.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/596/format/webp" alt="img"></p><p>还有，如果本地调试项目时，建议将build 里的<code>assetsPublicPath</code>的路径前缀修改为 ‘ ./ ‘（开始是 ‘ / ‘），因为打包之后，外部引入 js 和 css 文件时，如果路径以 ‘ / ‘ 开头，在本地是无法找到对应文件的（服务器上没问题）。所以<strong>如果需要在本地打开打包后的文件</strong>，就得修改文件路径。<br> 我的端口没有被占用，直接成功（服务启动成功后浏览器会默认打开一个“欢迎页面”）：</p><p><img src="https:////upload-images.jianshu.io/upload_images/10868449-77b13bb61a67b83f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p><p>注意：在进行vue页面调试时，一定要去谷歌商店下载一个vue-tool扩展程序。</p><h4 id="4-vue-cli的webpack配置分析"><a href="#4-vue-cli的webpack配置分析" class="headerlink" title="4.vue-cli的webpack配置分析"></a>4.vue-cli的webpack配置分析</h4><ul><li><p>从</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package.json</span><br></pre></td></tr></table></figure><p>可以看到开发和生产环境的入口。</p></li></ul><p>  <img src="https:////upload-images.jianshu.io/upload_images/10868449-255932a94e033291.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/775/format/webp" alt="img"></p><ul><li><p>可以看到dev中的设置，<strong>build/webpack.dev.conf.js</strong>，该文件是开发环境中webpack的配置入口。</p></li><li><p>在webpack.dev.conf.js中出现<strong>webpack.base.conf.js</strong>，这个文件是开发环境和生产环境，甚至测试环境，这些环境的公共webpack配置。可以说，这个文件相当重要。</p></li><li><p>还有<strong>config/index.js 、build/utils.js  、build/build.js</strong>等，具体请看这篇介绍：<br> <a href="https://link.jianshu.com?t=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000008644830" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008644830</a> </p></li></ul><h4 id="5-打包上线"><a href="#5-打包上线" class="headerlink" title="5.打包上线"></a>5.打包上线</h4><p>注意，自己的项目文件都需要放到 src 文件夹下。<br> 在项目开发完成之后，可以输入 <code>npm run build</code> 来进行打包工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>另：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.npm 开启了npm run dev以后怎么退出或关闭？</span><br><span class="line">ctrl+c</span><br><span class="line">2.--save-dev</span><br><span class="line">自动把模块和版本号添加到模块配置文件package.json中的依赖里devdependencies部分</span><br><span class="line">3. --save-dev 与 --save 的区别</span><br><span class="line">--save     安装包信息将加入到dependencies（生产阶段的依赖）</span><br><span class="line">--save-dev 安装包信息将加入到devDependencies（开发阶段的依赖），所以开发阶段一般使用它</span><br></pre></td></tr></table></figure><p>打包完成后，会生成 dist 文件夹，如果已经修改了文件路径，可以直接打开本地文件查看。<br> 项目上线时，只需要将 dist 文件夹放到服务器就行了。</p><p>好了，史上最详细版vue2脚手架出炉了，由于是全家桶第一篇，所以过于详细，后面我只会写关键步骤，多加入点实例。[微笑]</p><p>作者：东西里</p><p>链接：<a href="https://www.jianshu.com/p/32beaca25c0d" target="_blank" rel="noopener">https://www.jianshu.com/p/32beaca25c0d</a></p><p>來源：简书</p><p>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue2全家桶之一：vue-cli（vue脚手架）超详细教程&quot;&gt;&lt;a href=&quot;#Vue2全家桶之一：vue-cli（vue脚手架）超详细教程&quot; class=&quot;headerlink&quot; title=&quot;Vue2全家桶之一：vue-cli（vue脚手架）超详细教程&quot;&gt;
      
    
    </summary>
    
    
      <category term="vue" scheme="https://tianjiec.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>package.json理解</title>
    <link href="https://tianjiec.top/2018/12/29/package-json%E7%90%86%E8%A7%A3/"/>
    <id>https://tianjiec.top/2018/12/29/package-json理解/</id>
    <published>2018-12-29T02:39:22.000Z</published>
    <updated>2018-12-30T12:39:08.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对package-json的理解和学习"><a href="#对package-json的理解和学习" class="headerlink" title="对package.json的理解和学习"></a><a href="https://www.cnblogs.com/whkl-m/p/6617540.html" target="_blank" rel="noopener">对package.json的理解和学习</a></h1><p><strong>一、初步理解</strong></p><p>\1. npm安装package.json时  直接转到当前项目目录下用命令npm install 或npm install –save-dev安装即可，自动将package.json中的模块安装到node-modules文件夹下</p><p>\2. package.json 中添加中文注释会编译出错</p><p>\3. 每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install 命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。</p><p>\4. package.json文件可以手工编写，也可以使用<strong>npm init</strong>命令自动生成。</p><p>注意：npm init 时，用户需回答一些问题，然后在当前目录生成一个基本的package.json文件。所有问题之中，只有项目名称（name）和项目版本（version）是必填的，其他都是选填的。</p><p><strong>二、进一步理解 （完整的字段说明：<a href="http://www.mujiang.info/translation/npmjs/files/package.json.html" target="_blank" rel="noopener">http://www.mujiang.info/translation/npmjs/files/package.json.html</a>  中文版）</strong></p><p>以下是根据 创建vue项目的时候 npm init自动生成的package.json做详细的理解</p><p>1.下面是最简单的的一个package.json 文件（只有两个数据，项目名称和项目版本，他们都是必须的，如果没有就无法install）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&#123;``  ``&quot;name&quot;``: ``&quot;kocla_test&quot;``,``  ``&quot;version&quot;``: ``&quot;1.0.0&quot;``,``&#125;`</span><br></pre></td></tr></table></figure><p>2.scripts</p><p>指定了运行脚本命令的npm命令行缩写，比如start指定了运行npm run start时，所要执行的命令。</p><p>下面的设置指定了npm run dev、npm run bulid、npm run unit、npm run test<em>、npm run lint</em>时，所要执行的命令。　</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`"scripts"`</span><span class="string">`: &#123;`</span><span class="string">`    `</span><span class="string">`"dev"`</span><span class="string">`: `</span><span class="string">`"node build/dev-server.js"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"build"`</span><span class="string">`: `</span><span class="string">`"node build/build.js"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"unit"`</span><span class="string">`: `</span><span class="string">`"cross-env BABEL_ENV=test karma start test/unit/karma.conf.js --single-run"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"test"`</span><span class="string">`: `</span><span class="string">`"npm run unit"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"lint"`</span><span class="string">`: `</span><span class="string">`"eslint --ext .js,.vue src test/unit/specs"`</span><span class="string">`  `</span><span class="string">`&#125;,`</span></span><br></pre></td></tr></table></figure><h3 id="3-dependencies，devDependencies"><a href="#3-dependencies，devDependencies" class="headerlink" title="3  dependencies，devDependencies"></a>3  <em>dependencies，devDependencies</em></h3><h6 id="dependencies和devDependencies两项，分别指定了项目运行所依赖的模块、项目开发所需要的模块。它们都指向一个对象，该对象的各个成员，分别由模块名和对应的版本要去组成，表示依赖的模块及其版本范围"><a href="#dependencies和devDependencies两项，分别指定了项目运行所依赖的模块、项目开发所需要的模块。它们都指向一个对象，该对象的各个成员，分别由模块名和对应的版本要去组成，表示依赖的模块及其版本范围" class="headerlink" title="dependencies和devDependencies两项，分别指定了项目运行所依赖的模块、项目开发所需要的模块。它们都指向一个对象，该对象的各个成员，分别由模块名和对应的版本要去组成，表示依赖的模块及其版本范围"></a>dependencies和devDependencies两项，分别指定了项目运行所依赖的模块、项目开发所需要的模块。它们都指向一个对象，该对象的各个成员，分别由模块名和对应的版本要去组成，表示依赖的模块及其版本范围</h6><h6 id="–save参数表示将该模块写入dependencies属性，"><a href="#–save参数表示将该模块写入dependencies属性，" class="headerlink" title="–save参数表示将该模块写入dependencies属性，"></a>–save参数表示将该模块写入dependencies属性，</h6><h6 id="–save-dev表示将该模块写入devDependencies属性。"><a href="#–save-dev表示将该模块写入devDependencies属性。" class="headerlink" title="–save-dev表示将该模块写入devDependencies属性。"></a>–save-dev表示将该模块写入devDependencies属性。</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`"dependencies"`</span><span class="string">`: &#123;`</span><span class="string">`    `</span><span class="string">`"vue"`</span><span class="string">`: `</span><span class="string">`"^2.2.2"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"vue-router"`</span><span class="string">`: `</span><span class="string">`"^2.2.0"`</span><span class="string">`  `</span><span class="string">`&#125;,`</span><span class="string">`  `</span><span class="string">`"devDependencies"`</span><span class="string">`: &#123;`</span><span class="string">`    `</span><span class="string">`"autoprefixer"`</span><span class="string">`: `</span><span class="string">`"^6.7.2"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"babel-core"`</span><span class="string">`: `</span><span class="string">`"^6.22.1"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"babel-eslint"`</span><span class="string">`: `</span><span class="string">`"^7.1.1"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"babel-loader"`</span><span class="string">`: `</span><span class="string">`"^6.2.10"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"babel-plugin-transform-runtime"`</span><span class="string">`: `</span><span class="string">`"^6.22.0"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"babel-preset-env"`</span><span class="string">`: `</span><span class="string">`"^1.2.1"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"babel-preset-stage-2"`</span><span class="string">`: `</span><span class="string">`"^6.22.0"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"babel-register"`</span><span class="string">`: `</span><span class="string">`"^6.22.0"`</span><span class="string">`,`</span><span class="string">`    `</span><span class="string">`"chalk"`</span><span class="string">`: `</span><span class="string">`"^1.1.3"`</span><span class="string">`,`</span><span class="string">`&#125;`</span></span><br></pre></td></tr></table></figure><h2 id="4、config字段"><a href="#4、config字段" class="headerlink" title="4、config字段"></a>4、config字段</h2><p>config字段用于向环境变量输出值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`&#123; `</span><span class="string">`  `</span><span class="string">`"name"`</span> <span class="string">`: `</span><span class="string">`"foo"`</span><span class="string">`, `</span><span class="string">`  `</span><span class="string">`"config"`</span> <span class="string">`: &#123; `</span><span class="string">`"port"`</span> <span class="string">`: `</span><span class="string">`"8080"`</span> <span class="string">`&#125;, `</span><span class="string">`  `</span><span class="string">`"scripts"`</span> <span class="string">`: &#123; `</span><span class="string">`"start"`</span> <span class="string">`: `</span><span class="string">`"node server.js"`</span> <span class="string">`&#125; `</span><span class="string">`&#125; `</span></span><br></pre></td></tr></table></figure><p>　　</p><p>5.engines 字段</p><p>指明了该项目所需要的node.js版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&quot;engines&quot;``: &#123;``   ``&quot;node&quot;``: ``&quot;&gt;= 4.0.0&quot;``,``   ``&quot;npm&quot;``: ``&quot;&gt;= 3.0.0&quot;`` ``&#125;,`</span><br></pre></td></tr></table></figure><p>　　</p><p><strong>6.bin</strong></p><p>许多包有一个或多个可执行文件希望被安装到系统路径。在npm下要这么做非常容易(事实上，npm就是这么运行的)。</p><p>这需要在你的package.json中提供一个bin字段，它是一个命令名和本地文件名的映射。在安装时，如果是全局安装，npm将会使用符号链接把这些文件链接到prefix/bin，如果是本地安装，会链接到./node_modules/.bin/。</p><p>比如，要使用myapp作为命令时可以这么做：</p><h3 id="“bin”-“myapp”-“-cli-js”"><a href="#“bin”-“myapp”-“-cli-js”" class="headerlink" title="{ “bin” : { “myapp” : “./cli.js” } }"></a>{ “bin” : { “myapp” : “./cli.js” } }</h3><p>这么一来，当你安装myapp，npm会从cli.js文件创建一个到/usr/local/bin/myapp的符号链接(这使你可以直接在命令行执行myapp)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对package-json的理解和学习&quot;&gt;&lt;a href=&quot;#对package-json的理解和学习&quot; class=&quot;headerlink&quot; title=&quot;对package.json的理解和学习&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>函数加不加括号的区别</title>
    <link href="https://tianjiec.top/2018/12/28/%E5%87%BD%E6%95%B0%E5%8A%A0%E4%B8%8D%E5%8A%A0%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://tianjiec.top/2018/12/28/函数加不加括号的区别/</id>
    <published>2018-12-28T12:10:53.000Z</published>
    <updated>2018-12-28T12:17:50.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于vue-，v-on-绑定事件时，函数名加括号和不加括号的区别"><a href="#关于vue-，v-on-绑定事件时，函数名加括号和不加括号的区别" class="headerlink" title="关于vue ，v-on 绑定事件时，函数名加括号和不加括号的区别"></a><a href="https://www.cnblogs.com/huqiuwei/p/6401851.html" target="_blank" rel="noopener">关于vue ，v-on 绑定事件时，函数名加括号和不加括号的区别</a></h2><p>从官方的文档 <a href="https://link.zhihu.com/?target=https%3A//vuefe.cn/v2/guide/events.html" target="_blank" rel="noopener">事件处理器 — Vue.js</a> 中可以看出通过 <code>v-on</code> 中既可以执行一段代码、一个方法、内联 JavaScript 语句，根据不同的情况 Vue 会做不同的处理，具体可以从源码中可以看出（2.1.10版本），在编译阶段，会根据抽象HTML语法树生成代码，从 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/codegen/index.js%23L194" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/v2.1.10/src/compiler/codegen/index.js#L194</a> 可以看出如果此时包含了事件处理，则会调用 <code>genHandlers</code> 生成事件处理代码，最终走到 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/codegen/events.js%23L46" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/v2.1.10/src/compiler/codegen/events.js#L46</a> ，这里有两个正则判断，判断是函数正则以及属性访问正则，如果两个正则匹配成功则直接返回当前的值，否则用 <code>function($event){${handler.value}}</code> 包裹一次。 针对于你的疑问来说，如果说你是直接给定的 <code>greet</code> 的话，则属性访问正则匹配成功，如果是<code>greet()</code> 或者 <code>x+=1</code> 来说，则两个正则都匹配失败，利用函数包裹一层；而额外的第一种判断函数的正则则只有是你写的是函数的时候才会匹配成功，也就是类似于 <code>function () {xxx}</code> 或者 <code>() =&gt; dsf</code> 也就是一个匿名函数或者箭头函数。</p><p>最后，到底需不需要加括号的话，一般就是要看参数的情况了： 1、不需要参数或者默认参数的情况下，用一个定义的方法名即可。此时有一个需要注意的就是默认参数的情况，对于原生的事件处理的话，参数就只有一个：事件对象event；而对于自定义事件的话，则是在 emit 的时候传入的参数是什么，这个定义的方法被调用的时候的参数也是一一对应的。 2、自定义参数，这个参数有可能是你在HTML上直接写的<code>greet(&#39;xx&#39;)</code>，也有可能是在特殊上下文中得到的，例如说在 <code>v-for</code> 内部，可以传入当前循环项；这种情况下则是当一段代码片段来执行的，此时正是因为包裹的函数是有<code>$event</code>参数的，所以可以使用这个；你可能还会发现此时还可以这样写：<code>greet(arguments)</code>，传入的就是<code>arguments</code>对象，把调用定义方法的参数在形式上是可以由多个变为一个的。</p><p>函数名其实就是指向函数体的指针 </p><p>不加括号， 可以认为是查看该函数的完整信息， </p><p>不加括号传参，相当于传入函数整体 </p><p>加括号 表示立即调用（执行）这个函数里面的代码（花括号部分的代码）</p><p>应该是 Vue 对函数调用表达式额外用了一个函数做了层包装。<br>加与不加括号的区别在于事件对象参数 event 的处理。不加括号时，函数第一个参数为 event，加了括号后，需要手动传入 $event 才能获得事件对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"click($event)"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line"><span class="undefined">            methods: &#123;</span></span><br><span class="line"><span class="undefined">                click(e)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(e)</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于vue-，v-on-绑定事件时，函数名加括号和不加括号的区别&quot;&gt;&lt;a href=&quot;#关于vue-，v-on-绑定事件时，函数名加括号和不加括号的区别&quot; class=&quot;headerlink&quot; title=&quot;关于vue ，v-on 绑定事件时，函数名加括号和不加括
      
    
    </summary>
    
    
      <category term="vue" scheme="https://tianjiec.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>swiper-component</title>
    <link href="https://tianjiec.top/2018/12/28/swiper-component/"/>
    <id>https://tianjiec.top/2018/12/28/swiper-component/</id>
    <published>2018-12-28T09:40:07.000Z</published>
    <updated>2018-12-28T10:00:00.606Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.swiper.com.cn/" target="_blank" rel="noopener">https://www.swiper.com.cn/</a></p><h2 id="Swiper常用于移动端网站的内容触摸滑动"><a href="#Swiper常用于移动端网站的内容触摸滑动" class="headerlink" title="Swiper常用于移动端网站的内容触摸滑动"></a>Swiper常用于移动端网站的内容触摸滑动</h2><h3 id="Swiper4-x使用方法"><a href="#Swiper4-x使用方法" class="headerlink" title="Swiper4.x使用方法"></a>Swiper4.x使用方法</h3><p>1.首先加载插件，需要用到的文件有swiper.min.js和swiper.min.css文件。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./swiper.min.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./swiper.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./base/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue-resource/1.5.1/vue-resource.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">my-banner</span>&gt;</span><span class="tag">&lt;/<span class="name">my-banner</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"my-banner"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--2.HTML内容。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-container banner"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-wrapper"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">v-for</span>=<span class="string">"banner in banners"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">:key</span>=<span class="string">"banner.id"</span></span></span><br><span class="line"><span class="tag">                &gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">:src</span>=<span class="string">"banner.image"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如果需要分页器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-pagination"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;div&gt;&lt;input type="text" v-model="msg" name="" id=""&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//全局注册组件my-banner</span></span></span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">"my-banner"</span>,&#123;</span></span><br><span class="line"><span class="javascript">            template:<span class="string">"#my-banner"</span>,</span></span><br><span class="line"><span class="undefined">            data()&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="undefined">                    banners:[],</span></span><br><span class="line"><span class="javascript">                    msg:<span class="string">""</span></span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            methods:&#123;</span></span><br><span class="line"><span class="undefined">                getBanners()&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.$http.get(<span class="string">"./banners.json"</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                       <span class="comment">//console.log(res.body.bannerList)</span></span></span><br><span class="line"><span class="javascript">                        <span class="keyword">this</span>.banners = res.body.bannerList; </span></span><br><span class="line"><span class="undefined">                        </span></span><br><span class="line"><span class="javascript">                        <span class="comment">//4.初始化Swiper：最好是挨着&lt;/body&gt;标签</span></span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> mySwiper = <span class="keyword">new</span> Swiper (<span class="string">'.swiper-container'</span>, &#123;</span></span><br><span class="line"><span class="javascript">                            direction: <span class="string">'vertical'</span>, <span class="comment">// 垂直切换选项</span></span></span><br><span class="line"><span class="javascript">                            loop: <span class="literal">true</span>, <span class="comment">// 循环模式选项</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">                            <span class="comment">// 如果需要分页器</span></span></span><br><span class="line"><span class="undefined">                            pagination: &#123;</span></span><br><span class="line"><span class="javascript">                              el: <span class="string">'.swiper-pagination'</span>,</span></span><br><span class="line"><span class="undefined">                            &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">                            <span class="comment">// 如果需要前进后退按钮</span></span></span><br><span class="line"><span class="undefined">                            navigation: &#123;</span></span><br><span class="line"><span class="javascript">                              nextEl: <span class="string">'.swiper-button-next'</span>,</span></span><br><span class="line"><span class="javascript">                              prevEl: <span class="string">'.swiper-button-prev'</span>,</span></span><br><span class="line"><span class="undefined">                            &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">                            <span class="comment">// 如果需要滚动条</span></span></span><br><span class="line"><span class="undefined">                            scrollbar: &#123;</span></span><br><span class="line"><span class="javascript">                              el: <span class="string">'.swiper-scrollbar'</span>,</span></span><br><span class="line"><span class="undefined">                            &#125;,</span></span><br><span class="line"><span class="undefined">                         &#125;)        </span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">               &#125;</span></span><br><span class="line"><span class="undefined">           &#125;,</span></span><br><span class="line"><span class="undefined">           created()&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.getBanners()</span></span><br><span class="line"><span class="undefined">           &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#app"</span></span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.swiper.com.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.swiper.com.cn/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Swiper常用于移动端网站的内容触摸滑动&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="vue swiper" scheme="https://tianjiec.top/tags/vue-swiper/"/>
    
  </entry>
  
  <entry>
    <title>setTimeout</title>
    <link href="https://tianjiec.top/2018/12/28/setTimeout/"/>
    <id>https://tianjiec.top/2018/12/28/setTimeout/</id>
    <published>2018-12-28T08:04:23.000Z</published>
    <updated>2018-12-28T09:38:58.198Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇的文章中介绍了js异步原理，有的小伙伴可能还有些云里雾里，在本篇文章中将以新手很容易用错的setTimeout为例来解释js的异步原理。</p><p>首先我们看一个例子</p><script>  console.log(1);  setTimeout(function(){    console.log(2);  },500);  console.log(3);  // 运行结果  // 1  // 3  // 2</script><p>这里通过setTimeout延迟500毫秒执行，所以结果是1，3，2。这看起来明明就是异步操作啊，为什么说是同步呢？我们接着看下一个例子。</p><script>  var date = new Date();  console.log('first time: ' + date.getTime());  setTimeout(function(){      var date1 = new Date();      console.log('second time: ' + date1.getTime() );      console.log( date1.getTime() - date.getTime() );  },1000);  for(var i=0; i < 10000 ; i++){      console.log(1);  }  // 运行结果  // first time: 1524540272462  // （10000）1  // second time: 1524540274346  // 1884</script><p>神奇的事情出现了，假设js是异步，那么结果应该是这样的：<br>// first time: 1524540272462</p><p>//（x）1</p><p>// second time: 1524540273462</p><p>// 1000</p><p>//（10000-x）1</p><p>x为一秒内打印的1的数量。</p><p>但是实际结果settimeout并非是1000毫秒后执行的，而是1884毫秒。其原因是js是单线程，在打印完first time: 1524540272462后settimeout内的操作进入了“任务队列”，而1000毫秒到了以后，因为当前js正在执行打印1的操作，故js会在1打印完之后，才将settimeout内操作压进执行栈里。所以实际上我们看到的结果1884毫秒的原因就在于次。</p><p>这个例子说明js仍旧是单线程而非多线程，在同一时间内js只能做一件事情。</p><p>下面我们通过下面的简单例子也能够看出js是单线程的。</p><script>  console.log('1');  setTimeout(function(){      console.log('2');  },10);  while(true){};  // 运行结果  // 1</script><p>浏览器打印出1后就卡死了，并没有打印出2来。因为执行栈必须把当前任务完成，任务队列里的操作才能进入执行栈。而执行栈内的操作是死循环，所以浏览器卡死，2也不会被打印出来。</p><p>下面来看一种特殊情况，当setTimeout的时间为0的时候是不是立即执行的。</p><p>  console.log(1);<br>  setTimeout(function(){<br>​      console.log(2);<br>  },0);<br>  console.log(3);<br>  // 运行结果<br>  // 1<br>  // 3<br>  // 2</p><p>结果证明即便延迟设为0，也不是立即执行的。因为setTimeout有一个最小执行时间，当指定的时间小于该时间时，浏览器会用最小允许的时间作为setTimeout的时间间隔，也就是说即使我们把setTimeout的毫秒数设置为0，被调用的程序也没有马上启动。</p><h6 id="setTimeout的最小时间间隔和浏览器及操作系统有关。在John-Resig的《Javascript忍者的秘密》一书中提到–Browsers-all-have-a-10ms-minimum-delay-on-OSX-and-a-approximately-15ms-delay-on-Windows-（在苹果机上的最小时间间隔是10毫秒，在Windows系统上的最小时间间隔大约是15毫秒），另外，MDC中关于setTimeout的介绍中也提到，Firefox中定义的最小时间间隔（DOM-MIN-TIMEOUT-VALUE）是10毫秒，HTML5定义的最小时间间隔是4毫秒。"><a href="#setTimeout的最小时间间隔和浏览器及操作系统有关。在John-Resig的《Javascript忍者的秘密》一书中提到–Browsers-all-have-a-10ms-minimum-delay-on-OSX-and-a-approximately-15ms-delay-on-Windows-（在苹果机上的最小时间间隔是10毫秒，在Windows系统上的最小时间间隔大约是15毫秒），另外，MDC中关于setTimeout的介绍中也提到，Firefox中定义的最小时间间隔（DOM-MIN-TIMEOUT-VALUE）是10毫秒，HTML5定义的最小时间间隔是4毫秒。" class="headerlink" title="setTimeout的最小时间间隔和浏览器及操作系统有关。在John Resig的《Javascript忍者的秘密》一书中提到–Browsers all have a 10ms minimum delay on OSX and a(approximately) 15ms delay on Windows.（在苹果机上的最小时间间隔是10毫秒，在Windows系统上的最小时间间隔大约是15毫秒），另外，MDC中关于setTimeout的介绍中也提到，Firefox中定义的最小时间间隔（DOM_MIN_TIMEOUT_VALUE）是10毫秒，HTML5定义的最小时间间隔是4毫秒。"></a>setTimeout的最小时间间隔和浏览器及操作系统有关。在John Resig的《Javascript忍者的秘密》一书中提到–Browsers all have a 10ms minimum delay on OSX and a(approximately) 15ms delay on Windows.（在苹果机上的最小时间间隔是10毫秒，在Windows系统上的最小时间间隔大约是15毫秒），另外，MDC中关于setTimeout的介绍中也提到，Firefox中定义的最小时间间隔（DOM_MIN_TIMEOUT_VALUE）是10毫秒，HTML5定义的最小时间间隔是4毫秒。</h6><h6 id="作者：Tomhs3000"><a href="#作者：Tomhs3000" class="headerlink" title="作者：Tomhs3000"></a>作者：Tomhs3000</h6><p>来源：CSDN<br>原文：<a href="https://blog.csdn.net/Tomhs3000/article/details/80061501" target="_blank" rel="noopener">https://blog.csdn.net/Tomhs3000/article/details/80061501</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一篇的文章中介绍了js异步原理，有的小伙伴可能还有些云里雾里，在本篇文章中将以新手很容易用错的setTimeout为例来解释js的异步原理。&lt;/p&gt;
&lt;p&gt;首先我们看一个例子&lt;/p&gt;
&lt;script&gt;
  console.log(1);
  setTimeout(fun
      
    
    </summary>
    
    
      <category term="js" scheme="https://tianjiec.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>实例生命周期钩子</title>
    <link href="https://tianjiec.top/2018/12/28/%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/"/>
    <id>https://tianjiec.top/2018/12/28/实例生命周期钩子/</id>
    <published>2018-12-28T01:59:32.000Z</published>
    <updated>2018-12-28T03:46:46.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实例生命周期钩子"><a href="#实例生命周期钩子" class="headerlink" title="实例生命周期钩子"></a>实例生命周期钩子</h1><blockquote><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p></blockquote><p>比如 <a href="https://cn.vuejs.org/v2/api/#created" target="_blank" rel="noopener"><code>created</code></a> 钩子可以用来在一个实例被创建之后执行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a is: '</span> + <span class="keyword">this</span>.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt; "a is: 1"</span></span><br></pre></td></tr></table></figure><p>也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 <a href="https://cn.vuejs.org/v2/api/#mounted" target="_blank" rel="noopener"><code>mounted</code></a>、<a href="https://cn.vuejs.org/v2/api/#updated" target="_blank" rel="noopener"><code>updated</code></a> 和 <a href="https://cn.vuejs.org/v2/api/#destroyed" target="_blank" rel="noopener"><code>destroyed</code></a>。生命周期钩子的 <code>this</code> 上下文指向调用它的 Vue 实例。</p><p>ps:</p><blockquote><p>不要在选项属性或回调上使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>，比如 <code>created: () =&gt; console.log(this.a)</code> 或 <code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code>。因为箭头函数是和父级上下文绑定在一起的，<code>this</code> 不会是如你所预期的 Vue 实例，经常导致 <code>Uncaught TypeError: Cannot read property of undefined</code>或 <code>Uncaught TypeError: this.myMethod is not a function</code>之类的错误</p></blockquote><h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">生命周期图示</a></h2><p>下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。</p><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue 实例生命周期"></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>每个 Vue 实例在从创建到销毁的一系列过程，</p><p>vue在整个生命周期中为我们提供了很多的一些钩子函数</p><p>钩子函数特点就是会在生命周期某一时刻进行触发。</p><blockquote><p>组件从创建到销毁的一系列过程就叫做组建的生命周期</p><p>vue在整个生命周期中为我们提供了很多的一些钩子函数</p><p>钩子函数的特点就是会在生命周期某一时刻进行触发</p><p><strong>组件的生命周期可以分为三个过程</strong> </p><p><strong>初始化、运行中、 销毁</strong></p><p><strong>初始化阶段</strong>：beforeCreate、 created、beforeMount、mounted</p><p><strong>运行中阶段</strong>：beforeUpdate、updated</p><p><strong>销毁阶段</strong>：beforeDestory、destoryed</p><p>初始化阶段</p><p>1、一个示例/组件的生命周期是从new 开始</p><p>2、实例化之后，会初始化一些事件和生命周期相关的配置</p></blockquote><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">"my-component"</span>,&#123;</span><br><span class="line">template: <span class="string">"#my-component"</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            message: <span class="string">"component"</span>,</span><br><span class="line">            num: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        destory()&#123;</span><br><span class="line">            <span class="keyword">this</span>.$destory();<span class="comment">//销毁组件/实例</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//初始化阶段</span></span><br><span class="line">    <span class="comment">//1.一个组件的生命周期是从new开始</span></span><br><span class="line">    <span class="comment">//2.实例化之后，会初始化一些事件和生命周期相关的配置</span></span><br><span class="line">    beforeCreate()&#123;</span><br><span class="line">       <span class="comment">//3.在这里，数据还没有进行挂载，dom也没有进行渲染。此钩子函数基本无用</span></span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">     <span class="comment">//4.在这里，数据已经挂载完毕，但是dom还是没有进行渲染</span></span><br><span class="line">         <span class="comment">//在这个函数里面，如果同步的更改数据，则不会触发其他运行中钩子函数的执行</span></span><br><span class="line">         <span class="comment">//做一些初始化数据的配置  掉接口就可以在这里写</span></span><br><span class="line">        <span class="keyword">this</span>.message = <span class="keyword">this</span>.message.toUpperCase();</span><br><span class="line">        <span class="comment">//想要this.num进行累计操作</span></span><br><span class="line">        <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">1111</span>)</span><br><span class="line">            <span class="keyword">this</span>.num++</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//ps：</span></span><br><span class="line">        <span class="comment">//同步：执行完这些代码之后才会继续向后执行</span></span><br><span class="line">        <span class="comment">//异步：此处继续执行，但后面的代码也继续执行，不阻塞</span></span><br><span class="line">        <span class="comment">//此处为一示例</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">window</span>.onscroll = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">111111111</span>)</span><br><span class="line">            <span class="keyword">this</span>.num++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//接下来过程是我们的组建或实例去查找对应的模板，然后将编译成虚拟dom放入rander函数中</span></span><br><span class="line">    beforeMount()&#123;</span><br><span class="line">        <span class="comment">//5代表dom马上将要被渲染，但是还没有真正的渲染出来！</span></span><br><span class="line">        <span class="comment">//做一些初始化数据的配置</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"beforeMount"</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.message, <span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// render()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log(11111111)</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    mounted()&#123;</span><br><span class="line">        <span class="comment">//6.当mounted执行完毕的时候，说明组件生命周期的初始化阶段已经结束了</span></span><br><span class="line">        <span class="comment">//这个函数是初始化阶段的最后一个函数，在这里可以获取到真实dom结构</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"mounted"</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.message, <span class="built_in">document</span>.getElementById(<span class="string">"title"</span>))</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeUpdate()&#123;</span><br><span class="line">        <span class="comment">//7.这里数据刚刚更改，dom还是没有进行渲染</span></span><br><span class="line">        <span class="comment">//在这个钩子函数里面，我们不会做任何的操作</span></span><br><span class="line">        <span class="comment">//this.message+=2;</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"beforeUpdate"</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>).innerHTML)</span><br><span class="line">    &#125;,</span><br><span class="line">    updated()&#123;</span><br><span class="line">        <span class="comment">//8在这里可以获取到更新之后的dom,我们不会做任何的操作</span></span><br><span class="line">        <span class="comment">//当数据更改之后，引起dom重新渲染之后，此钩子函数才会执行</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"updated"</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"title"</span>).innerHTML)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy()&#123;</span><br><span class="line">        <span class="comment">//组件即将要被销毁，但是还没有被销毁</span></span><br><span class="line">        <span class="comment">//在这个钩子函数里面，我们可以做一些善后的操作</span></span><br><span class="line">        <span class="comment">//例如清空定时器、清空绑定的事件</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"beforeDestroy"</span>)</span><br><span class="line">        clearInterval(<span class="keyword">this</span>.timer)</span><br><span class="line">        <span class="built_in">window</span>.onscroll = <span class="literal">null</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed()&#123;</span><br><span class="line">        <span class="comment">//组件已经被销毁了，生命周期已经结束了！</span></span><br><span class="line">        <span class="comment">//组件把数据绑定、事件监听都给去掉，但是组件的dom结构还是存在的！</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"destroyed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">new</span> Vue(&#123;&#125;).$mount(<span class="string">"#app"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实例生命周期钩子&quot;&gt;&lt;a href=&quot;#实例生命周期钩子&quot; class=&quot;headerlink&quot; title=&quot;实例生命周期钩子&quot;&gt;&lt;/a&gt;实例生命周期钩子&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需
      
    
    </summary>
    
    
      <category term="vue" scheme="https://tianjiec.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>组件传值</title>
    <link href="https://tianjiec.top/2018/12/27/%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    <id>https://tianjiec.top/2018/12/27/组件传值/</id>
    <published>2018-12-27T08:21:14.000Z</published>
    <updated>2018-12-27T12:58:46.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="父组件——》子组件"><a href="#父组件——》子组件" class="headerlink" title="父组件——》子组件"></a>父组件——》子组件</h2><p>在父组件 global</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是父组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message.value"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>message: &#123;&#123;message.value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">son</span> <span class="attr">:message</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件 通过props 属性 获取到 父组件闯过来的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">"son"</span>, &#123;</span><br><span class="line">    template: <span class="string">"#son"</span>,</span><br><span class="line">    props:[<span class="string">"message"</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>local：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line">    son:&#123;</span><br><span class="line">        props:[<span class="string">"parentSky"</span>],</span><br><span class="line">            template:<span class="string">"#son"</span>,</span><br><span class="line">                data()&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    sonColor:<span class="string">"red"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            computed:&#123;</span><br><span class="line">               ownColor:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">this</span>.parentSky+<span class="keyword">this</span>.sonColor;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单项数据流："><a href="#单项数据流：" class="headerlink" title="单项数据流："></a>单项数据流：</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<strong>不</strong>应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p><blockquote><p><strong>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。</strong></p></blockquote><p>父组件向子组件传对象 子组件 也可以操作父组件数据</p><p>违背了单项数据流 不推荐使用</p><h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><h2 id="Prop-的大小写-camelCase-vs-kebab-case"><a href="#Prop-的大小写-camelCase-vs-kebab-case" class="headerlink" title="Prop 的大小写 (camelCase vs kebab-case)"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%86%99-camelCase-vs-kebab-case" target="_blank" rel="noopener">Prop 的大小写 (camelCase vs kebab-case)</a></h2><p>HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;blog-post&apos;, &#123;</span><br><span class="line">  // 在 JavaScript 中是 camelCase 的</span><br><span class="line">  props: [&apos;postTitle&apos;],</span><br><span class="line">  template: &apos;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;</span><br><span class="line">&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure><p>重申一次，如果你使用字符串模板，那么这个限制就不存在了。</p><h2 id="Prop-类型"><a href="#Prop-类型" class="headerlink" title="Prop 类型"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">Prop 类型</a></h2><p>到这里，我们只看到了以字符串数组形式列出的 prop：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [&apos;title&apos;, &apos;likes&apos;, &apos;isPublished&apos;, &apos;commentIds&apos;, &apos;author&apos;]</span><br></pre></td></tr></table></figure><p>但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些属性的名称和值分别是 prop 各自的名称和类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: String,</span><br><span class="line">  likes: Number,</span><br><span class="line">  isPublished: Boolean,</span><br><span class="line">  commentIds: Array,</span><br><span class="line">  author: Object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不仅为你的组件提供了文档，还会在它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户。你会在这个页面接下来的部分看到<a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener">类型检查和其它 prop 验证</a>。</p><h2 id="传递静态或动态-Prop"><a href="#传递静态或动态-Prop" class="headerlink" title="传递静态或动态 Prop"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#%E4%BC%A0%E9%80%92%E9%9D%99%E6%80%81%E6%88%96%E5%8A%A8%E6%80%81-Prop" target="_blank" rel="noopener">传递静态或动态 Prop</a></h2><p>像这样，你已经知道了可以像这样给 prop 传入一个静态的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure><p>你也知道 prop 可以通过 <code>v-bind</code> 动态赋值，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 动态赋予一个变量的值 --&gt;</span><br><span class="line">&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态赋予一个复杂表达式的值 --&gt;</span><br><span class="line">&lt;blog-post v-bind:title=&quot;post.title + &apos; by &apos; + post.author.name&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure><p>在上述两个示例中，我们传入的值都是字符串类型的，但实际上<em>任何</em>类型的值都可以传给一个 prop。</p><h3 id="传入一个数字"><a href="#传入一个数字" class="headerlink" title="传入一个数字"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97" target="_blank" rel="noopener">传入一个数字</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span><br><span class="line">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span><br><span class="line">&lt;blog-post v-bind:likes=&quot;42&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 用一个变量进行动态赋值。--&gt;</span><br><span class="line">&lt;blog-post v-bind:likes=&quot;post.likes&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure><h3 id="传入一个布尔值"><a href="#传入一个布尔值" class="headerlink" title="传入一个布尔值"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E5%B8%83%E5%B0%94%E5%80%BC" target="_blank" rel="noopener">传入一个布尔值</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">is-published</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:is-published</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:is-published</span>=<span class="string">"post.isPublished"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="传入一个数组"><a href="#传入一个数组" class="headerlink" title="传入一个数组"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">传入一个数组</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:comment-ids</span>=<span class="string">"[234, 266, 273]"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:comment-ids</span>=<span class="string">"post.commentIds"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="传入一个对象"><a href="#传入一个对象" class="headerlink" title="传入一个对象"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">传入一个对象</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:author</span>=<span class="string">"&#123; name: 'Veronica', company: 'Veridian Dynamics' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:author</span>=<span class="string">"post.author"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="传入一个对象的所有属性"><a href="#传入一个对象的所有属性" class="headerlink" title="传入一个对象的所有属性"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">传入一个对象的所有属性</a></h3><p>如果你想要将一个对象的所有属性都作为 prop 传入，你可以使用不带参数的 <code>v-bind</code>(取代 <code>v-bind:prop-name</code>)。例如，对于一个给定的对象 <code>post</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post: &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  title: <span class="string">'My Journey with Vue'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">"post"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:id</span>=<span class="string">"post.id"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">"post.title"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Prop-验证"><a href="#Prop-验证" class="headerlink" title="Prop 验证"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener">Prop 验证</a></h2><p>我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。</p><p>为了定制 prop 的验证方式，你可以为 <code>props</code> 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 匹配任何类型)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的数字</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="comment">// 对象或数组默认值必须从一个工厂函数获取</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'danger'</span>].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。</p><p>注意那些 prop 会在一个组件实例创建<strong>之前</strong>进行验证，所以实例的属性 (如 <code>data</code>、<code>computed</code> 等) 在 <code>default</code> 或 <code>validator</code> 函数中是不可用的。</p><h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a><a href="https://cn.vuejs.org/v2/guide/components-props.html#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5" target="_blank" rel="noopener">类型检查</a></h3><p><code>type</code> 可以是下列原生构造函数中的一个：</p><ul><li><code>String</code></li><li><code>Number</code></li><li><code>Boolean</code></li><li><code>Array</code></li><li><code>Object</code></li><li><code>Date</code></li><li><code>Function</code></li><li><code>Symbol</code></li></ul><p>额外的，<code>type</code> 还可以是一个自定义的构造函数，并且通过 <code>instanceof</code> 来进行检查确认。例如，给定下列现成的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person (firstName, lastName) &#123;</span><br><span class="line">  this.firstName = firstName</span><br><span class="line">  this.lastName = lastName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;blog-post&apos;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    author: Person</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>来验证 <code>author</code> prop 的值是否是通过 <code>new Person</code> 创建的。</p><h2 id="子组件——》父组件"><a href="#子组件——》父组件" class="headerlink" title="子组件——》父组件"></a>子组件——》父组件</h2><h3 id="1、通过关系链操作父组件数据"><a href="#1、通过关系链操作父组件数据" class="headerlink" title="1、通过关系链操作父组件数据"></a>1、通过关系链操作父组件数据</h3><p>子组件：通过this.$parent  可以找到其父组件</p><p>然后可以 通过 this.$parent.属性 来操作</p><h3 id="2、通过ref链"><a href="#2、通过ref链" class="headerlink" title="2、通过ref链"></a>2、通过ref链</h3><p>在组件实例上加上 ref=”ref名字”</p><p>父 找 子组件：</p><p>可以直接通过this.$refs.ref名 来找到</p><p>兄弟：</p><p>可以通过 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$parent.$refs.ref名来找到</span><br></pre></td></tr></table></figure><h3 id="3、通过父组件向子组件传递方法（常用）"><a href="#3、通过父组件向子组件传递方法（常用）" class="headerlink" title="3、通过父组件向子组件传递方法（常用）"></a>3、通过父组件向子组件传递方法（常用）</h3><p> 子组件通过props接收到这个方法； 子组件通过这个方法将数据 通过 参数传到 父组件</p><h3 id="4、通过自定义事件（常用）"><a href="#4、通过自定义事件（常用）" class="headerlink" title="4、通过自定义事件（常用）"></a>4、通过自定义事件（常用）</h3><p>父组件在子标签上 添加一个自定义事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@tell-dad=<span class="string">"say"</span></span><br><span class="line"></span><br><span class="line">say(word) &#123;</span><br><span class="line">    <span class="comment">// console.log(word)</span></span><br><span class="line">    <span class="keyword">this</span>.parentWord = word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子组件通过</p><p>this.$.emit(“自定义事件名”，参数);</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;button @click="tell"&gt;say&lt;/button&gt; </span></span><br><span class="line">tell()&#123;</span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">"tell-dad"</span>,<span class="keyword">this</span>.word)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;父组件——》子组件&quot;&gt;&lt;a href=&quot;#父组件——》子组件&quot; class=&quot;headerlink&quot; title=&quot;父组件——》子组件&quot;&gt;&lt;/a&gt;父组件——》子组件&lt;/h2&gt;&lt;p&gt;在父组件 global&lt;/p&gt;
&lt;figure class=&quot;highlight h
      
    
    </summary>
    
    
      <category term="vue" scheme="https://tianjiec.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-resource</title>
    <link href="https://tianjiec.top/2018/12/27/vue-resource/"/>
    <id>https://tianjiec.top/2018/12/27/vue-resource/</id>
    <published>2018-12-27T03:27:16.000Z</published>
    <updated>2018-12-27T03:45:15.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Vue.js是数据驱动的，这使得我们并不需要直接操作DOM，如果我们不需要使用jQuery的DOM选择器，就没有必要引入jQuery。vue-resource是Vue.js的一款插件，它可以通过XMLHttpRequest或JSONP发起请求并处理响应。也就是说，$.ajax能做的事情，vue-resource插件一样也能做到，而且vue-resource的API更为简洁。另外，vue-resource还提供了非常有用的inteceptor功能，使用inteceptor可以在请求前和请求后附加一些行为，比如使用inteceptor在ajax请求时显示loading界面。</p><p>本文的主要内容如下：</p><ul><li>介绍vue-resource的特点</li><li>介绍vue-resource的基本使用方法</li><li>基于this.$http的增删查改示例</li><li>基于this.$resource的增删查改示例</li><li>基于inteceptor实现请求等待时的loading画面</li><li>基于inteceptor实现请求错误时的提示画面</li></ul><h1 id="vue-resource特点"><a href="#vue-resource特点" class="headerlink" title="vue-resource特点"></a>vue-resource特点</h1><p>vue-resource插件具有以下特点：</p><p><strong>1. 体积小</strong></p><p>vue-resource非常小巧，在压缩以后只有大约12KB，服务端启用gzip压缩后只有4.5KB大小，这远比jQuery的体积要小得多。</p><p><strong>2. 支持主流的浏览器</strong></p><p>和Vue.js一样，vue-resource除了不支持IE 9以下的浏览器，其他主流的浏览器都支持。</p><p><strong>3. 支持Promise API和URI Templates</strong></p><p>Promise是ES6的特性，Promise的中文含义为“先知”，Promise对象用于异步计算。<br>URI Templates表示URI模板，有些类似于ASP.NET MVC的路由模板。</p><p><strong>4. 支持拦截器</strong></p><p>拦截器是全局的，拦截器可以在请求发送前和发送请求后做一些处理。<br>拦截器在一些场景下会非常有用，比如请求发送前在headers中设置access_token，或者在请求失败时，提供共通的处理方式。</p><h1 id="vue-resource使用"><a href="#vue-resource使用" class="headerlink" title="vue-resource使用"></a>vue-resource使用</h1><h2 id="引入vue-resource"><a href="#引入vue-resource" class="headerlink" title="引入vue-resource"></a>引入vue-resource</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;js/vue-resource.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>引入vue-resource后，可以基于全局的Vue对象使用http，也可以基于某个Vue实例使用http。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 基于全局Vue对象使用http</span><br><span class="line">Vue.http.get(&apos;/someUrl&apos;, [options]).then(successCallback, errorCallback);</span><br><span class="line">Vue.http.post(&apos;/someUrl&apos;, [body], [options]).then(successCallback, errorCallback);</span><br><span class="line"></span><br><span class="line">// 在一个Vue实例内使用$http</span><br><span class="line">this.$http.get(&apos;/someUrl&apos;, [options]).then(successCallback, errorCallback);</span><br><span class="line">this.$http.post(&apos;/someUrl&apos;, [body], [options]).then(successCallback, errorCallback);</span><br></pre></td></tr></table></figure><p>在发送请求后，使用<code>then</code>方法来处理响应结果，<code>then</code>方法有两个参数，第一个参数是响应成功时的回调函数，第二个参数是响应失败时的回调函数。</p><p><code>then</code>方法的回调函数也有两种写法，第一种是传统的函数写法，第二种是更为简洁的ES 6的Lambda写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 传统写法</span><br><span class="line">this.$http.get(&apos;/someUrl&apos;, [options]).then(function(response)&#123;</span><br><span class="line">    // 响应成功回调</span><br><span class="line">&#125;, function(response)&#123;</span><br><span class="line">    // 响应错误回调</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Lambda写法</span><br><span class="line">this.$http.get(&apos;/someUrl&apos;, [options]).then((response) =&gt; &#123;</span><br><span class="line">    // 响应成功回调</span><br><span class="line">&#125;, (response) =&gt; &#123;</span><br><span class="line">    // 响应错误回调</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>PS：做过.NET开发的人想必对Lambda写法有一种熟悉的感觉。</p><h2 id="支持的HTTP方法"><a href="#支持的HTTP方法" class="headerlink" title="支持的HTTP方法"></a>支持的HTTP方法</h2><p>vue-resource 的请求API是按照REST风格设计的， 他提供了7种请求API：</p><ul><li>get（url, [options]）</li><li>post（url, [options]）</li><li>head（url, [options]）</li><li><code>delete(url, [options])</code></li><li><code>jsonp(url, [options])</code></li><li><code>put(url, [body], [options])</code></li><li><code>patch(url, [body], [options])</code></li></ul><p>除了jsonp以外，另外6种的API名称是标准的HTTP方法。当服务端使用REST API时，客户端的编码风格和服务端的编码风格近乎一致，这可以减少前端和后端开发人员的沟通成本。</p><table><thead><tr><th>客户端请求方法</th><th>服务端处理方法</th></tr></thead><tbody><tr><td>this.$http.get(…)</td><td>Getxxx</td></tr><tr><td>this.$http.post(…)</td><td>Postxxx</td></tr><tr><td>this.$http.put(…)</td><td>Putxxx</td></tr><tr><td>this.$http.delete(…)</td><td>Deletexxx</td></tr></tbody></table><h2 id="options对象"><a href="#options对象" class="headerlink" title="options对象"></a>options对象</h2><p>发送请求时的options选项对象包含以下属性：</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>url</td><td><code>string</code></td><td>请求的URL</td></tr><tr><td>method</td><td><code>string</code></td><td>请求的HTTP方法，例如：’GET’, ‘POST’或其他HTTP方法</td></tr><tr><td>body</td><td><code>Object</code>, <code>FormData</code> <code>string</code></td><td>request body</td></tr><tr><td>params</td><td><code>Object</code></td><td>请求的URL参数对象</td></tr><tr><td>headers</td><td><code>Object</code></td><td>request header</td></tr><tr><td>timeout</td><td><code>number</code></td><td>单位为毫秒的请求超时时间 (<code>0</code> 表示无超时时间)</td></tr><tr><td>before</td><td><code>function(request)</code></td><td>请求发送前的处理函数，类似于jQuery的beforeSend函数</td></tr><tr><td>progress</td><td><code>function(event)</code></td><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/ProgressEvent" target="_blank" rel="noopener">ProgressEvent</a>回调处理函数</td></tr><tr><td>credentials</td><td><code>boolean</code></td><td>表示跨域请求时是否需要使用凭证</td></tr><tr><td>emulateHTTP</td><td><code>boolean</code></td><td>发送PUT, PATCH, DELETE请求时以HTTP POST的方式发送，并设置请求头的<code>X-HTTP-Method-Override</code></td></tr><tr><td>emulateJSON</td><td><code>boolean</code></td><td>将request body以<code>application/x-www-form-urlencoded</code> content type发送</td></tr></tbody></table><h3 id="emulateHTTP的作用"><a href="#emulateHTTP的作用" class="headerlink" title="emulateHTTP的作用"></a>emulateHTTP的作用</h3><p>如果Web服务器无法处理PUT, PATCH和DELETE这种REST风格的请求，你可以启用enulateHTTP现象。启用该选项后，请求会以普通的POST方法发出，并且HTTP头信息的<code>X-HTTP-Method-Override</code>属性会设置为实际的HTTP方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.options.emulateHTTP = true;</span><br></pre></td></tr></table></figure><h3 id="emulateJSON的作用"><a href="#emulateJSON的作用" class="headerlink" title="emulateJSON的作用"></a>emulateJSON的作用</h3><p>如果Web服务器无法处理编码为application/json的请求，你可以启用emulateJSON选项。启用该选项后，请求会以<code>application/x-www-form-urlencoded</code>作为MIME type，就像普通的HTML表单一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.options.emulateJSON = true;</span><br></pre></td></tr></table></figure><h2 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a>response对象</h2><p>response对象包含以下属性：</p><table><thead><tr><th>方法</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>text()</td><td><code>string</code></td><td>以string形式返回response body</td></tr><tr><td>json()</td><td><code>Object</code></td><td>以JSON对象形式返回response body</td></tr><tr><td>blob()</td><td><code>Blob</code></td><td>以二进制形式返回response body</td></tr><tr><td><strong>属性</strong></td><td><strong>类型</strong></td><td><strong>描述</strong></td></tr><tr><td>ok</td><td><code>boolean</code></td><td>响应的HTTP状态码在200~299之间时，该属性为true</td></tr><tr><td>status</td><td><code>number</code></td><td>响应的HTTP状态码</td></tr><tr><td>statusText</td><td><code>string</code></td><td>响应的状态文本</td></tr><tr><td>headers</td><td><code>Object</code></td><td>响应头</td></tr></tbody></table><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h1 id="CURD示例"><a href="#CURD示例" class="headerlink" title="CURD示例"></a>CURD示例</h1><p>提示：以下示例仍然沿用上一篇的组件和WebAPI，组件的代码和页面HTML代码我就不再贴出来了。</p><h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var demo = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        gridColumns: [&apos;customerId&apos;, &apos;companyName&apos;, &apos;contactName&apos;, &apos;phone&apos;],</span><br><span class="line">        gridData: [],</span><br><span class="line">        apiUrl: &apos;http://211.149.193.19:8080/api/customers&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    ready: function() &#123;</span><br><span class="line">        this.getCustomers()</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getCustomers: function() &#123;</span><br><span class="line">            this.$http.get(this.apiUrl)</span><br><span class="line">                .then((response) =&gt; &#123;</span><br><span class="line">                    this.$set(&apos;gridData&apos;, response.data)</span><br><span class="line">                &#125;)</span><br><span class="line">                .catch(function(response) &#123;</span><br><span class="line">                    console.log(response)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这段程序的then方法只提供了successCallback，而省略了errorCallback。<br>catch方法用于捕捉程序的异常，catch方法和errorCallback是不同的，errorCallback只在响应失败时调用，而catch则是在整个请求到响应过程中，只要程序出错了就会被调用。</p><p>在then方法的回调函数内，你也可以直接使用this，this仍然是指向Vue实例的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getCustomers: function() &#123;</span><br><span class="line">    this.$http.get(this.apiUrl)</span><br><span class="line">        .then((response) =&gt; &#123;</span><br><span class="line">            this.$set(&apos;gridData&apos;, response.data)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(function(response) &#123;</span><br><span class="line">            console.log(response)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为了减少作用域链的搜索，建议使用一个局部变量来接收this。</strong></p><h2 id="JSONP请求"><a href="#JSONP请求" class="headerlink" title="JSONP请求"></a>JSONP请求</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getCustomers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$http.jsonp(<span class="keyword">this</span>.apiUrl).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.$set(<span class="string">'gridData'</span>, response.data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">var demo = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        show: false,</span><br><span class="line">        gridColumns: [&#123;</span><br><span class="line">            name: &apos;customerId&apos;,</span><br><span class="line">            isKey: true</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            name: &apos;companyName&apos;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            name: &apos;contactName&apos;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            name: &apos;phone&apos;</span><br><span class="line">        &#125;],</span><br><span class="line">        gridData: [],</span><br><span class="line">        apiUrl: &apos;http://211.149.193.19:8080/api/customers&apos;,</span><br><span class="line">        item: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ready: function() &#123;</span><br><span class="line">        this.getCustomers()</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        closeDialog: function() &#123;</span><br><span class="line">            this.show = false</span><br><span class="line">        &#125;,</span><br><span class="line">        getCustomers: function() &#123;</span><br><span class="line">            var vm = this</span><br><span class="line">            vm.$http.get(vm.apiUrl)</span><br><span class="line">                .then((response) =&gt; &#123;</span><br><span class="line">                    vm.$set(&apos;gridData&apos;, response.data)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        createCustomer: function() &#123;</span><br><span class="line">            var vm = this</span><br><span class="line">            vm.$http.post(vm.apiUrl, vm.item)</span><br><span class="line">                .then((response) =&gt; &#123;</span><br><span class="line">                    vm.$set(&apos;item&apos;, &#123;&#125;)</span><br><span class="line">                    vm.getCustomers()</span><br><span class="line">                &#125;)</span><br><span class="line">            this.show = false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://images2015.cnblogs.com/blog/341820/201607/341820-20160710081835108-205718456.gif" alt="29](https://images2015.cnblogs.com/blog/341820/201607/341820-20160710081836280-560832480.gif)" title="">                </div>                <div class="image-caption">29](https://images2015.cnblogs.com/blog/341820/201607/341820-20160710081836280-560832480.gif)</div>            </figure></p><p><strong>知识来源</strong>：</p><p><a href="https://www.cnblogs.com/chenhuichao/p/8308993.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenhuichao/p/8308993.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Vue.js是数据驱动的，这使得我们并不需要直接操作DOM，如果我们不需要使用jQuery的DOM选择器，就没有必要引入jQuery。vue
      
    
    </summary>
    
    
      <category term="vue" scheme="https://tianjiec.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>组件-Prop</title>
    <link href="https://tianjiec.top/2018/12/27/%E7%BB%84%E4%BB%B6-Prop/"/>
    <id>https://tianjiec.top/2018/12/27/组件-Prop/</id>
    <published>2018-12-27T02:45:16.000Z</published>
    <updated>2018-12-27T03:13:19.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h1><p>Prop的大小写（camelCase vs kebab-case）</p><blockquote><p>HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用DOM中的模板是，calmelCase（驼峰命名法）的prop名需要使用等价的kebab-case（短横线分隔命名）命名：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  <span class="comment">// 在 JavaScript 中是 camelCase 的</span></span><br><span class="line">  props: [<span class="string">'postTitle'</span>],</span><br><span class="line">  template: <span class="string">'&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">post-title</span>=<span class="string">"hello!"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重申一次，如果你使用字符串模板，那么这个限制就不存在了。</p><h2 id="Prop类型"><a href="#Prop类型" class="headerlink" title="Prop类型"></a>Prop类型</h2><p>到这里，我们只看到了以字符串数组形式列出的 prop：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'title'</span>, <span class="string">'likes'</span>, <span class="string">'isPublished'</span>, <span class="string">'commentIds'</span>, <span class="string">'author'</span>]</span><br></pre></td></tr></table></figure><p>但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些属性的名称和值分别是 prop 各自的名称和类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span>,</span><br><span class="line">  isPublished: <span class="built_in">Boolean</span>,</span><br><span class="line">  commentIds: <span class="built_in">Array</span>,</span><br><span class="line">  author: <span class="built_in">Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不仅为你的组件提供了文档，还会在它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户。你会在这个页面接下来的部分看到<a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener">类型检查和其它 prop 验证</a>。</p><p>传递静态或动态得到Prop</p><p>像这样，你已经知道了可以像这样给prop传入一个静态的值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"My journey with Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你也知道 prop 可以通过 <code>v-bind</code> 动态赋值，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 动态赋予一个变量的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:title</span>=<span class="string">"post.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态赋予一个复杂表达式的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:title</span>=<span class="string">"post.title + ' by ' + post.author.name"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述两个示例中，我们传入的值都是字符串类型的，但实际上<em>任何</em>类型的值都可以传给一个 prop。</p><h4 id="传入一个数字"><a href="#传入一个数字" class="headerlink" title="#传入一个数字"></a>#传入一个数字</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:likes</span>=<span class="string">"42"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:likes</span>=<span class="string">"post.likes"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="单项数据流"><a href="#单项数据流" class="headerlink" title="单项数据流"></a>单项数据流</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你<strong>不</strong>应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p><p>这里有两种常见的试图改变一个prop的情形：</p><p>1、<strong>这个prop用来传递一个初始值；这个子组件接下来希望将其作为一个本地的prop数据来使用</strong>。在这种情况下，最好定义一个本地的data属性并将这个prop用作初始值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'initialCounter'</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="keyword">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、<strong>这个 prop 以一种原始的值传入且需要进行转换。</strong>在这种情况下，最好使用这个 prop 的值来定义一个计算属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'size'</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。</strong></p></blockquote><h3 id="Prop验证"><a href="#Prop验证" class="headerlink" title="Prop验证"></a>Prop验证</h3><p>我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。</p><p>为了定制 prop 的验证方式，你可以为 <code>props</code> 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">    props:&#123;</span><br><span class="line">        <span class="comment">//基础的类型检查（`null` 匹配任何类型）</span></span><br><span class="line">        propA: <span class="built_in">Number</span>,</span><br><span class="line">        <span class="comment">//多个可能类型</span></span><br><span class="line">        propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">        <span class="comment">//必填的字符串</span></span><br><span class="line">        propC: &#123;</span><br><span class="line">            type: <span class="built_in">String</span>,</span><br><span class="line">            required : <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//带有默认值的数字</span></span><br><span class="line">        propD: &#123;</span><br><span class="line">            type: <span class="built_in">Number</span>,</span><br><span class="line">            <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//带有默认值的对象</span></span><br><span class="line">        propE: &#123;</span><br><span class="line">            type: <span class="built_in">Object</span>,</span><br><span class="line">            <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    message: <span class="string">'hello'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//自定义验证函数</span></span><br><span class="line">        propF: &#123;</span><br><span class="line">            validator: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                <span class="comment">//这里值必须匹配下列字符串中的一个</span></span><br><span class="line">                <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'denger'</span>].indexOf(value)!== <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Prop&quot;&gt;&lt;a href=&quot;#Prop&quot; class=&quot;headerlink&quot; title=&quot;Prop&quot;&gt;&lt;/a&gt;Prop&lt;/h1&gt;&lt;p&gt;Prop的大小写（camelCase vs kebab-case）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTML 中的特
      
    
    </summary>
    
    
      <category term="vue" scheme="https://tianjiec.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>xhr</title>
    <link href="https://tianjiec.top/2018/12/26/xhr/"/>
    <id>https://tianjiec.top/2018/12/26/xhr/</id>
    <published>2018-12-26T11:58:39.000Z</published>
    <updated>2018-12-26T12:11:47.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解ajax——XHR对象"><a href="#深入理解ajax——XHR对象" class="headerlink" title="深入理解ajax——XHR对象"></a>深入理解ajax——XHR对象</h1><h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>　　1999年，微软公司发布IE5，第一次引入新功能：允许javascript脚本向服务器发起HTTP请求。这个功能当时并没有引起注意，直到2004年Gmail发布和2005年Google Map发布，才引起广泛重视。2005年2月，ajax这个词第一次正式提出，指围绕这个功能进行开发的一整套做法。从此，ajax成为脚本发起HTTP通信的代名词，W3C也在2006年发布了它的国际标准。本文是ajax系列的第一篇——XHR对象</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>　　ajax是asynchronous javascript and XML的简写，中文翻译是异步的javascript和XML，这一技术能够向服务器请求额外的数据而无须卸载页面，会带来更好的用户体验。虽然名字中包含XML，但ajax通信与数据格式无关</p><p>　　ajax包括以下几步骤：<strong>1、创建AJAX对象；2、发出HTTP请求；3、接收服务器传回的数据；4、更新网页数据</strong></p><p>　　概括起来，就是一句话，<strong>ajax通过原生的<code>XMLHttpRequest</code>对象发出HTTP请求，得到服务器返回的数据后，再进行处理</strong></p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>　　ajax技术的核心是XMLHttpRequest对象(简称XHR)，这是由微软首先引入的一个特性，其他浏览器提供商后来都提供了相同的实现。XHR为向服务器发送请求和解析服务器响应提供了流畅的接口，能够以异步方式从服务器取得更多信息，意味着用户单击后，可以不必刷新页面也能取得新数据</p><p>　　IE5是第一款引入XHR对象的浏览器。在IE5中，XHR对象是通过MSXML库中的一个ActiveX对象实现的，而IE7+及其他标准浏览器都支持原生的XHR对象</p><p>　　创建一个XHR对象，也叫实例化一个XHR对象，因为XMLHTTPRequest()是一个构造函数。下面是创建XHR对象的兼容写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[注意]如果要建立N个不同的请求，就要使用N个不同的XHR对象。当然可以重用已存在的XHR对象，但这会终止之前通过该对象挂起的任何请求</p><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p><strong>open()</strong></p><p>　　在使用XHR对象时，要调用的第一个方法是open()，如下所示，该方法接受3个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"example.php"</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>1、open()方法的第<strong>一个参数用于指定发送请求的方式</strong>，这个字符串，不区分大小写，但通常使用大写字母。”GET”和”POST”是得到广泛支持的</p><p>　　“GET”用于常规请求，它适用于当URL完全指定请求资源，当请求对服务器没有任何副作用以及当服务器的响应是可缓存的情况下</p><p>　　“POST”方法常用于HTML表单。它在请求主体中包含额外数据且这些数据常存储到服务器上的数据库中。相同URL的重复POST请求从服务器得到的响应可能不同，同时不应该缓存使用这个方法的请求</p><p>　　除了”GET”和”POST”之外，参数还可以是”HEAD”、”OPTIONS”、”PUT”。而由于安全风险的原因，”CONNECT”、”TRACE”、”TRACK”被禁止使用</p><p>　　[注意]关于HTTP协议8种常用方法的详细介绍<a href="http://www.cnblogs.com/xiaohuochai/p/6156435.html#anchor3" target="_blank" rel="noopener">移步至此</a></p><p>　2、open()方法的第<strong>二个参数是URL</strong>，该URL相对于执行代码的当前页面，且只能向同一个域中使用相同端口和协议的URL发送请求。如果URL与启动请求的页面有任何差别，都会引发安全错误</p><p>　　3、open()方法的第<strong>三个参数是表示是否异步发送请求的布尔值</strong>，如果不填写，默认为true，表示异步发送</p><p>　　4、如果请求一个受密码保护的URL，把用于认证的用户名和密码作为第4和第5个参数传递给open()方法</p><p><strong>send()</strong></p><p>send()方法接收一个参数，即要作为请求主体发送的数据。调用send()方法后，请求被分派到服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;get&quot;,&quot;example.txt&quot;, true)</span><br><span class="line">xhr.send(null)</span><br></pre></td></tr></table></figure><h3 id="接收响应"><a href="#接收响应" class="headerlink" title="接收响应"></a>接收响应</h3><p>　　一个完整的HTTP响应由状态码、响应头集合和响应主体组成。在收到响应后，这些都可以通过XHR对象的属性和方法使用，主要有以下4个属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">responseText:作为响应主题被返回的文本（文本形式）</span><br><span class="line">responseXML：如果响应的内容是<span class="string">'text/xml'</span>或者是<span class="string">'application/xml'</span>,这个属性中将保存着相应数据的XML DOM文档（<span class="built_in">document</span>形式）</span><br><span class="line">status: HTTP状态码（数字形式）</span><br><span class="line">statusText：HTTP状态说明（文本形式）</span><br></pre></td></tr></table></figure><p>在接收到响应后，第一步是检查status属性，以确定响应已经成功返回。一般来说，可以将HTTP状态码为200作为成功的标志。此时，responseText属性的内容已经就绪，而且在内容类型正确的情况下，responseXML也可以访问了。此外，状态码为304表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本；当然，也意味着响应是有效的</p><p>　　无论内容类型是什么，响应主体的内容都会保存到responseText属性中，而对于非XML数据而言，responseXML属性的值将为null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((xhr.status &gt;=<span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">    alert(xhr.responseText);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    alert(<span class="string">'request was unsuccessful:'</span> + xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>　　如果接受的是同步响应，则需要将open()方法的第三个参数设置为false，那么send()方法将阻塞直到请求完成。一旦send()返回，仅需要检查XHR对象的status和responseText属性即可</p><p>　　同步请求是吸引人的，但应该避免使用它们。客户端javascript是单线程的，当send()方法阻塞时，它通常会导致整个浏览器UI冻结。如果连接的服务器响应慢，那么用户的浏览器将冻结</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">"btn"</span>&gt;获取信息&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;div id="result"&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//创建xhr对象</span></span><br><span class="line">    <span class="keyword">var</span> xhr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    xhr.open(<span class="string">'get'</span>,<span class="string">'/uploads/rs/26/ddzmgynp/message.xml'</span>,<span class="literal">false</span>);</span><br><span class="line">    xhr.send();</span><br><span class="line">    <span class="comment">//同步接受响应</span></span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">            <span class="comment">//实际操作</span></span><br><span class="line">            result.innerHTML += xhr.responseText;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="javascript:void(0);" alt="复制代码](http://common.cnblogs.com/images/copycode.gif)" title="">                </div>                <div class="image-caption">复制代码](http://common.cnblogs.com/images/copycode.gif)</div>            </figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//message.xml</span><br><span class="line">&lt;p&gt;hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure><h4 id="知识来源：http-www-cnblogs-com-xiaohuochai-p-6036475-html"><a href="#知识来源：http-www-cnblogs-com-xiaohuochai-p-6036475-html" class="headerlink" title="知识来源：http://www.cnblogs.com/xiaohuochai/p/6036475.html"></a>知识来源：<a href="http://www.cnblogs.com/xiaohuochai/p/6036475.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaohuochai/p/6036475.html</a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解ajax——XHR对象&quot;&gt;&lt;a href=&quot;#深入理解ajax——XHR对象&quot; class=&quot;headerlink&quot; title=&quot;深入理解ajax——XHR对象&quot;&gt;&lt;/a&gt;深入理解ajax——XHR对象&lt;/h1&gt;&lt;h2 id=&quot;前面的话&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="ajax" scheme="https://tianjiec.top/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>Vue.extend构造器</title>
    <link href="https://tianjiec.top/2018/12/26/Vue-extend%E6%9E%84%E9%80%A0%E5%99%A8/"/>
    <id>https://tianjiec.top/2018/12/26/Vue-extend构造器/</id>
    <published>2018-12-26T09:48:26.000Z</published>
    <updated>2018-12-26T11:51:08.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1.简单介绍"></a>1.简单介绍</h3><p>Vue.extend(options)</p><p>参数：对象</p><p>用法：使用Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象，其中,data选项中必须是函数</p><blockquote><h5 id="描述：Vue-extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue-component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上"><a href="#描述：Vue-extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue-component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上" class="headerlink" title="描述：Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上"></a>描述：Vue.extend返回的是一个“扩展实例构造器”，也就是预设了部分选项的Vue的实例构造器，它常常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂在到自定义元素上</h5></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> author = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">"&lt;p&gt;&lt;a :href='url'&gt;&#123;&#123;author&#125;&#125;&lt;/a&gt;&lt;/p&gt;"</span>,</span><br><span class="line">  data : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      author : <span class="string">'vamous'</span>,</span><br><span class="line">      url : <span class="string">'http://blog.csdn.net/Dear_Mr/article/details/72614370'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Hello = Vue.extend(&#123;</span><br><span class="line">       template:<span class="string">"&lt;p&gt;header!!!&lt;/p&gt;"</span></span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简单介绍&quot;&gt;&lt;a href=&quot;#1-简单介绍&quot; class=&quot;headerlink&quot; title=&quot;1.简单介绍&quot;&gt;&lt;/a&gt;1.简单介绍&lt;/h3&gt;&lt;p&gt;Vue.extend(options)&lt;/p&gt;
&lt;p&gt;参数：对象&lt;/p&gt;
&lt;p&gt;用法：使用Vue构造器，创建
      
    
    </summary>
    
    
      <category term="vue" scheme="https://tianjiec.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>箭头函数</title>
    <link href="https://tianjiec.top/2018/12/26/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>https://tianjiec.top/2018/12/26/箭头函数/</id>
    <published>2018-12-26T03:27:09.000Z</published>
    <updated>2018-12-26T03:51:45.203Z</updated>
    
    <content type="html"><![CDATA[<p>##### </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个参数</span></span><br><span class="line"><span class="keyword">var</span>fn1 = <span class="function"><span class="params">a</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多个参数</span></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function">(<span class="params">a, b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a+b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有return语句 返回值</span></span><br><span class="line"><span class="keyword">var</span> fn3 = <span class="function">(<span class="params">a</span>)=&gt;</span>a</span><br><span class="line"><span class="keyword">var</span> fn4 = <span class="function">(<span class="params">a, b</span>)=&gt;</span>（a+b）</span><br></pre></td></tr></table></figure><h4 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h4><p>函数自执行（自己执行）</p><p>函数的this指向window</p><p><strong>箭头函数的this指向 其上一层（临近）的对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    username:<span class="string">"张三"</span>,</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    say2:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">json.say();<span class="comment">//&#123;username: "张三", say: ƒ, say2: ƒ&#125;</span></span><br><span class="line">json.say2();<span class="comment">//Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##### &lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/s
      
    
    </summary>
    
    
      <category term="es6 js" scheme="https://tianjiec.top/tags/es6-js/"/>
    
  </entry>
  
  <entry>
    <title>作用域、变量提升、this.js</title>
    <link href="https://tianjiec.top/2018/12/25/%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E3%80%81this-js/"/>
    <id>https://tianjiec.top/2018/12/25/作用域、变量提升、this-js/</id>
    <published>2018-12-25T11:53:29.000Z</published>
    <updated>2018-12-26T03:36:40.406Z</updated>
    
    <content type="html"><![CDATA[<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.log(a);</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">abc();</span><br></pre></td></tr></table></figure><p>function 执行过程是</p><p>查找var let 将声明提前</p><p>然后再在原有位置进行赋值</p><p>var 和 let变量提升区别：</p><p>let 局部 变量提升出现死区例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">"hey I am outside"</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//Uncaught ReferenceError: a is not defined</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">"hey I am inside"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>let变量提升 在死区部分无法访问 ，而我们不能够访问的原因事实上是因为let的死区（temporal dead zone）设计：当前作用域顶部到该变量声明位置中间的部分，都是该let变量的死区，在死区中，禁止访问该变量。由此，我们给出结论，let声明的变量存在变量提升， 但是由于死区我们无法在声明前访问这个变量。<br>原文：<a href="https://blog.csdn.net/triumphs/article/details/80142721" target="_blank" rel="noopener">https://blog.csdn.net/triumphs/article/details/80142721</a> </p><h4 id="函数变量的变量提升："><a href="#函数变量的变量提升：" class="headerlink" title="函数变量的变量提升："></a>函数变量的变量提升：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn();<span class="comment">//1</span></span><br><span class="line"><span class="comment">//声明式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn2();<span class="comment">//fn2 not is a function</span></span><br><span class="line"><span class="comment">//定义式</span></span><br><span class="line"><span class="keyword">var</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="this（有关对象和函数）"><a href="#this（有关对象和函数）" class="headerlink" title="this（有关对象和函数）"></a>this（有关对象和函数）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">username = <span class="string">"lisi"</span></span><br><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    username:<span class="string">"张三"</span>,</span><br><span class="line">    fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = json.fn()</span><br><span class="line"><span class="built_in">console</span>.log(obj.username)<span class="comment">//张三 正常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = json.fn</span><br><span class="line"><span class="built_in">console</span>.log(obj().username) <span class="comment">//lisi  原因：此时obj为一个函数，函数的this指向window</span></span><br></pre></td></tr></table></figure><h4 id="bind-call-applay"><a href="#bind-call-applay" class="headerlink" title="bind call applay"></a>bind call applay</h4><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">    username:<span class="string">"张三"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//window对象上面属性不存在就会是undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.username,(a+b))</span><br><span class="line">&#125;</span><br><span class="line">fn();<span class="comment">//undefined NaN</span></span><br><span class="line">fn.call(json,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//张三 3</span></span><br><span class="line">fn.apply(json,[<span class="number">1</span>,<span class="number">2</span>]);<span class="comment">//张三 3</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"box"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>,a)</span><br><span class="line">&#125;.bind(json,<span class="number">100</span>);&#123;<span class="attr">username</span>: <span class="string">"张三"</span>&#125; <span class="number">100</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;变量提升&quot;&gt;&lt;a href=&quot;#变量提升&quot; class=&quot;headerlink&quot; title=&quot;变量提升&quot;&gt;&lt;/a&gt;变量提升&lt;/h4&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
    
      <category term="js" scheme="https://tianjiec.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>todoList</title>
    <link href="https://tianjiec.top/2018/12/25/todoList/"/>
    <id>https://tianjiec.top/2018/12/25/todoList/</id>
    <published>2018-12-25T09:51:57.000Z</published>
    <updated>2018-12-25T12:27:59.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h1><h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><blockquote><p>显示所有任务 ； 已完成任务 ；未完成任务；</p><p>每个任务点击对号记入已完成任务；每个任务有个删除功能；未完成任务在删除的时候弹出确认删除未完成任务的对话框；</p></blockquote><h3 id="技术："><a href="#技术：" class="headerlink" title="技术："></a>技术：</h3><p>SUI Mobile框架</p><p>vue框架</p><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><h4 id="1、借用SUI-Mobile写样式"><a href="#1、借用SUI-Mobile写样式" class="headerlink" title="1、借用SUI Mobile写样式"></a>1、借用SUI Mobile写样式</h4><p><strong>首先将sui的样式css文件引入</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"http://g.alicdn.com/msui/sm/0.6.2/css/sm.min.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ps:这里sui他给的href或src地址要加上http: ， 不然会找不到资源</p><p><strong>然后找到相应的组件</strong></p><p>标题栏、图标、卡片</p><h4 id="2、借助Vue插入数据"><a href="#2、借助Vue插入数据" class="headerlink" title="2、借助Vue插入数据"></a>2、借助Vue插入数据</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span> <span class="attr">v-for</span>=<span class="string">"todo in showTodo"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card-content-inner"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;todo.content&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"> <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">     el: <span class="string">"#app"</span>,</span></span><br><span class="line"><span class="undefined">     data: &#123;</span></span><br><span class="line"><span class="undefined">         todos: [&#123;</span></span><br><span class="line"><span class="undefined">                 id: 1,</span></span><br><span class="line"><span class="javascript">                 content: <span class="string">"hello,今天又是美好的一天"</span>,</span></span><br><span class="line"><span class="javascript">                 isFinished: <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">             &#125;,</span></span><br><span class="line"><span class="undefined">             &#123;</span></span><br><span class="line"><span class="undefined">                  id: 2,</span></span><br><span class="line"><span class="javascript">                  content: <span class="string">"你好"</span>,</span></span><br><span class="line"><span class="javascript">                  isFinished: <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">              &#125;</span></span><br><span class="line"><span class="undefined">          ],</span></span><br><span class="line"><span class="undefined">     &#125;</span></span><br><span class="line"><span class="undefined"> &#125;)</span></span><br><span class="line"><span class="undefined"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、添加完成任务和删除任务按钮"><a href="#3、添加完成任务和删除任务按钮" class="headerlink" title="3、添加完成任务和删除任务按钮"></a>3、添加完成任务和删除任务按钮</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\罗中运\AppData\Roaming\Typora\typora-user-images\1545735525618.png" alt="1545735525618" title="">                </div>                <div class="image-caption">1545735525618</div>            </figure><p>在内容 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br></pre></td></tr></table></figure><p>下添加 sui 的按钮组件</p><p>为button添加 data isFinished: false属性（在每个todo 对象里面）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"button button-round"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">:class</span>=<span class="string">"(todo.isFinished?'active':'')"</span> </span></span><br><span class="line"><span class="tag">@<span class="attr">click</span>=<span class="string">"todo.isFinished=!todo.isFinished"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><p>1、为其添加 vue的 v-bind:class  用isFinished数据控制 它的样式</p><p>2、再为其添加 v-on:click 点击事件 来改变 isFinished的值来间接控制它的样式</p><p><strong>为删除任务添加事件</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"button button-round"</span></span></span><br><span class="line"><span class="tag">@<span class="attr">click</span>=<span class="string">"checkTodo(todo.id,todo.isFinished)"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><p>在任务状态为已完成（isFinished=true时）直接删除</p><p>在任务状态为未完成  弹出对话框</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\罗中运\AppData\Roaming\Typora\typora-user-images\1545736203312.png" alt="1545736203312" title="">                </div>                <div class="image-caption">1545736203312</div>            </figure><p>为对话框是否显示 添加数据  isRemoveShow: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"isRemoveShow=false"</span> <span class="attr">v-if</span>=<span class="string">"isRemoveShow"</span> <span class="attr">class</span>=<span class="string">"decive-content"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-if =true的时候显示 =false的时候隐藏</p><p>设置点击 除确定 的地方 将其隐藏 ： @click=”isRemoveShow=false” </p><h4 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h4><p>在 vue对象中：</p><blockquote><p> 删除按钮： <a href="#" class="button button-round" @click="checkTodo(todo.id,todo.isFinished)"></a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">        removeTodo(id) &#123;</span><br><span class="line">            <span class="keyword">this</span>.todos = <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> todo.id !== id ? todo : <span class="string">""</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        checkTodo(id, isFinished) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isFinished) &#123;</span><br><span class="line">                <span class="keyword">this</span>.isRemoveShow = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.preRemoveId = id;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.removeTodo(id);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>为对话框的确定添加删除功能</p><p> <span class="modal-button modal-button-bold" @click="removeTodo(preRemoveId)">确定</span></p><p>ps:这里 点击发生了冒泡，再删除数据的同时，也冒泡触发了 其父元素的 @click=”isRemoveShow=false”事件</p><p>为了给确定指明删除哪一个</p><p>在点击删除未完成任务的时候 存一个preRemoveId 用来记录此时的数据的id</p><h4 id="4、添加分类按钮"><a href="#4、添加分类按钮" class="headerlink" title="4、添加分类按钮"></a>4、添加分类按钮</h4><p>用sui的样式 和 vue的v-for循环添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">:class</span>=<span class="string">"['button',activeType === btn.type?'active':'']"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"(btn) in btns"</span> <span class="attr">:key</span>=<span class="string">"btn.id"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">click</span>=<span class="string">"activeType=btn.type"</span></span></span><br><span class="line"><span class="tag">&gt;</span>&#123;&#123;btn.title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为按钮创建数据模型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">btns: [&#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    type: <span class="string">"all"</span>,</span><br><span class="line">    title: <span class="string">"A"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">   &#123;</span><br><span class="line">       id: <span class="number">2</span>,</span><br><span class="line">       type: <span class="string">"finished"</span>,</span><br><span class="line">       title: <span class="string">"F"</span>,</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">       id: <span class="number">3</span>,</span><br><span class="line">       type: <span class="string">"unfinished"</span>,</span><br><span class="line">       title: <span class="string">"U"</span>,</span><br><span class="line">   &#125;,</span><br><span class="line">  ],</span><br><span class="line">    activeType: <span class="string">"all"</span></span><br></pre></td></tr></table></figure><p>title 用于显示文本、type用来匹配当前选中 哪一个 activeType 用来 表示 哪个选中</p><p><strong>按钮的</strong>  :calss 用来通过数据决定哪个被选中 </p><p><strong>添加点击事件改变选中</strong>：@click=”activeType=btn.type”</p><p>PS：所以，对于任何复杂逻辑，你都应当使用<strong>计算属性</strong>。</p><p><strong>添加计算属性 来 控制显示 哪一部分数据</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">            finished()&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> todo.isFinished?todo:<span class="string">""</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            unfinished()&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span>=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> !todo.isFinished?todo:<span class="string">""</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            showTodo()&#123;</span><br><span class="line">                <span class="keyword">switch</span>(<span class="keyword">this</span>.activeType)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"all"</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.todos;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"finished"</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.finished;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"unfinished"</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.unfinished;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//&lt;div class="card" v-for="todo in showTodo"&gt;</span></span><br><span class="line"><span class="comment">//修改循环显示的 数据</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;任务列表&quot;&gt;&lt;a href=&quot;#任务列表&quot; class=&quot;headerlink&quot; title=&quot;任务列表&quot;&gt;&lt;/a&gt;任务列表&lt;/h1&gt;&lt;h3 id=&quot;功能：&quot;&gt;&lt;a href=&quot;#功能：&quot; class=&quot;headerlink&quot; title=&quot;功能：&quot;&gt;&lt;/a&gt;功能
      
    
    </summary>
    
    
      <category term="sui vue" scheme="https://tianjiec.top/tags/sui-vue/"/>
    
  </entry>
  
  <entry>
    <title>js的this</title>
    <link href="https://tianjiec.top/2018/12/24/js%E7%9A%84this/"/>
    <id>https://tianjiec.top/2018/12/24/js的this/</id>
    <published>2018-12-24T04:14:45.000Z</published>
    <updated>2018-12-24T06:01:28.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this-指向详细解析（箭头函数）"><a href="#this-指向详细解析（箭头函数）" class="headerlink" title="this 指向详细解析（箭头函数）"></a>this 指向详细解析（箭头函数）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>this 指向问题是入坑前端必须了解知识点，现在迎来了ES6时代，因为箭头函数的出现，所以感觉有必要对 this 问题梳理一下，遂有此文</p><p>在非箭头函数下， this 指向调用其所在函数的对象，而且是离谁近就是指向谁（此对于常规对象，原型链， getter &amp; setter等都适用）；构造函数下，this与被创建的新对象绑定；DOM事件，this指向触发事件的元素；内联事件分两种情况，bind绑定， call &amp; apply 方法等， 容以下一步一步讨论。箭头函数也会穿插其中进行讨论。</p><h2 id="全局环境下"><a href="#全局环境下" class="headerlink" title="全局环境下"></a>全局环境下</h2><p>在全局环境下，this 始终指向全局对象（window）, 无论是否严格模式；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(this.document === document); // true</span><br><span class="line"></span><br><span class="line">// 在浏览器中，全局对象为 window 对象：</span><br><span class="line">console.log(this === window); // true</span><br><span class="line"></span><br><span class="line">this.a = 37;</span><br><span class="line">console.log(window.a); // 37</span><br></pre></td></tr></table></figure><h2 id="函数上下文调用"><a href="#函数上下文调用" class="headerlink" title="函数上下文调用"></a>函数上下文调用</h2><h3 id="函数直接调用"><a href="#函数直接调用" class="headerlink" title="函数直接调用"></a>函数直接调用</h3><p>普通函数内部的this分两种情况，严格模式和非严格模式。</p><p>非严格模式下，this 默认指向全局对象window</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1() === window; // true</span><br></pre></td></tr></table></figure><p>而严格模式下， this为undefined</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f2()&#123;</span><br><span class="line">  &quot;use strict&quot;; // 这里是严格模式</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2() === undefined; // true</span><br></pre></td></tr></table></figure><h3 id="对象中的this"><a href="#对象中的this" class="headerlink" title="对象中的this"></a>对象中的this</h3><p>对象内部方法的this指向调用这些方法的对象，</p><ol><li>函数的定义位置不影响其this指向，this指向只和调用函数的对象有关。</li><li>多层嵌套的对象，内部方法的this指向离被调用函数最近的对象（window也是对象，其内部对象调用方法的this指向内部对象， 而非window）。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line">var o = &#123;</span><br><span class="line">  prop: 37,</span><br><span class="line">  f: function() &#123;</span><br><span class="line">    return this.prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(o.f());  //37</span><br><span class="line">var a = o.f;</span><br><span class="line">console.log(a()):  //undefined</span><br><span class="line"></span><br><span class="line">var o = &#123;prop: 37&#125;;</span><br><span class="line"></span><br><span class="line">function independent() &#123;</span><br><span class="line">  return this.prop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f = independent;</span><br><span class="line"></span><br><span class="line">console.log(o.f()); // logs 37</span><br><span class="line"></span><br><span class="line">//2</span><br><span class="line">o.b = &#123;</span><br><span class="line">  g: independent,</span><br><span class="line">  prop: 42</span><br><span class="line">&#125;;</span><br><span class="line">console.log(o.b.g()); // logs 42</span><br></pre></td></tr></table></figure><h4 id="原型链中this"><a href="#原型链中this" class="headerlink" title="原型链中this"></a>原型链中this</h4><p>原型链中的方法的this仍然指向调用它的对象，与以上讨论一致；看个例子，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  f : function()&#123; </span><br><span class="line">    return this.a + this.b; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var p = Object.create(o);</span><br><span class="line">p.a = 1;</span><br><span class="line">p.b = 4;</span><br><span class="line"></span><br><span class="line">console.log(p.f()); // 5</span><br></pre></td></tr></table></figure><p>可以看出， 在p中没有属性f，当执行p.f()时，会查找p的原型链，找到 f 函数并执行，但这与函数内部this指向对象 p 没有任何关系，只需记住谁调用指向谁。</p><p>以上对于函数作为getter &amp; setter 调用时同样适用。</p><h3 id="构造函数中this"><a href="#构造函数中this" class="headerlink" title="构造函数中this"></a>构造函数中this</h3><p>构造函数中的this与被创建的新对象绑定。</p><p>注意：当构造器返回的默认值是一个this引用的对象时，可以手动设置返回其他的对象，如果返回值不是一个对象，返回this。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function C()&#123;</span><br><span class="line">  this.a = 37;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = new C();</span><br><span class="line">console.log(o.a); // logs 37</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function C2()&#123;</span><br><span class="line">  this.a = 37;</span><br><span class="line">  return &#123;a:38&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = new C2();</span><br><span class="line">console.log(b.a); // logs 38</span><br></pre></td></tr></table></figure><p>以上两个例子内部的this都指向对象o, 看到这里的你不妨在控制台执行下以上代码，看看对象 o 和 b ，这些是属于构造函数的内容了，此处不多做介绍。（C2函数中的this.a = 37 对整个过程完全没有影响的， 可以被忽略的）。</p><h3 id="call-amp-apply"><a href="#call-amp-apply" class="headerlink" title="call &amp; apply"></a>call &amp; apply</h3><p>当函数通过Function对象的原型中继承的方法 call() 和 apply() 方法调用时， 其函数内部的this值可绑定到 call() &amp; apply() 方法指定的第一个对象上， 如果第一个参数不是对象，JavaScript内部会尝试将其转换成对象然后指向它。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function add(c, d)&#123;</span><br><span class="line">  return this.a + this.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = &#123;a:1, b:3&#125;;</span><br><span class="line"></span><br><span class="line">add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16</span><br><span class="line"></span><br><span class="line">add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</span><br><span class="line"></span><br><span class="line">function tt() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">// 返回对象见下图（图1）</span><br><span class="line">tt.call(5);  // Number &#123;[[PrimitiveValue]]: 5&#125; </span><br><span class="line">tt.call(&apos;asd&apos;); // String &#123;0: &quot;a&quot;, 1: &quot;s&quot;, 2: &quot;d&quot;, length: 3, [[PrimitiveValue]]: &quot;asd&quot;&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144423820-371299881.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h3 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h3><p>bind方法在ES5引入， 在Function的原型链上， <code>Function.prototype.bind</code>。通过bind方法绑定后， 函数将被永远绑定在其第一个参数对象上， 而无论其在什么情况下被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">  return this.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = f.bind(&#123;a:&quot;azerty&quot;&#125;);</span><br><span class="line">console.log(g()); // azerty</span><br><span class="line"></span><br><span class="line">var o = &#123;a:37, f:f, g:g&#125;;</span><br><span class="line">console.log(o.f(), o.g()); // 37, azerty</span><br></pre></td></tr></table></figure><h3 id="DOM-事件处理函数中的-this-amp-内联事件中的-this"><a href="#DOM-事件处理函数中的-this-amp-内联事件中的-this" class="headerlink" title="DOM 事件处理函数中的 this &amp; 内联事件中的 this"></a>DOM 事件处理函数中的 this &amp; 内联事件中的 this</h3><p><strong>DOM事件处理函数</strong></p><ol><li>当函数被当做监听事件处理函数时， 其 this 指向触发该事件的元素 （针对于addEventListener事件）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 被调用时，将关联的元素变成蓝色</span><br><span class="line">  function bluify(e)&#123;</span><br><span class="line">    //在控制台打印出所点击元素</span><br><span class="line">    console.log(this);</span><br><span class="line">    //阻止时间冒泡</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    //阻止元素的默认事件</span><br><span class="line">    e.preventDefault();      </span><br><span class="line">    this.style.backgroundColor = &apos;#A5D9F3&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 获取文档中的所有元素的列表</span><br><span class="line">  var elements = document.getElementsByTagName(&apos;*&apos;);</span><br><span class="line"></span><br><span class="line">  // 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span><br><span class="line">  for(var i=0 ; i&lt;elements.length ; i++)&#123;</span><br><span class="line">    elements[i].addEventListener(&apos;click&apos;, bluify, false);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上代码建议在网页中执行以下，看下效果。</p><p><strong>内联事件</strong><br>内联事件中的this指向分两种情况：</p><ol><li>当代码被内联处理函数调用时，它的this指向监听器所在的DOM元素</li><li>当代码被包括在函数内部执行时，其this指向等同于 <strong><strong>函数直接调用</strong></strong>的情况，即在非严格模式指向全局对象window， 在严格模式指向undefined</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144449757-948944211.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>页面的代码块</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144504413-1120828849.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>在浏览器内显示三个按钮</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144511679-451778615.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>依次点击上边的三个按钮后在控制台的输出结果，</p><p>建议自己操作一遍以便于更好的理解。</p><h3 id="setTimeout-amp-setInterval"><a href="#setTimeout-amp-setInterval" class="headerlink" title="setTimeout &amp; setInterval"></a>setTimeout &amp; setInterval</h3><p>对于延时函数内部的回调函数的this指向全局对象window（当然我们可以通过bind方法改变其内部函数的this指向）<br>看下边代码及截图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//默认情况下代码</span><br><span class="line">function Person() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();//3秒后返回 window 对象</span><br><span class="line">==============================================</span><br><span class="line">//通过bind绑定</span><br><span class="line">function Person() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setTimeout((function() &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;).bind(this), 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();//3秒后返回构造函数新生成的对象 Person&#123;...&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144527554-990414883.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144536820-1525099793.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h2 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h2><p>由于箭头函数不绑定this， 它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值，</p><ol><li>所以 call() / apply() / bind() 方法对于箭头函数来说只是传入参数，对它的 this 毫无影响。</li><li>考虑到 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。（可以忽略是否在严格模式下的影响）</li></ol><p>因为箭头函数可以捕获其所在上下文的this值 所以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">        // 回调里面的 `this` 变量就指向了期望的那个对象了</span><br><span class="line">        this.age++;</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();</span><br></pre></td></tr></table></figure><p>以上代码可以得到我们所以希望的值，下图可以看到，在setTimeout中的this指向了构造函数新生成的对象，而普通函数指向了全局window对象</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144556179-936108349.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var adder = &#123;</span><br><span class="line">  base : 1,</span><br><span class="line">    </span><br><span class="line">  add : function(a) &#123;</span><br><span class="line">    var f = v =&gt; v + this.base;</span><br><span class="line">    return f(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addThruCall: function inFun(a) &#123;</span><br><span class="line">    var f = v =&gt; v + this.base;</span><br><span class="line">    var b = &#123;</span><br><span class="line">      base : 2</span><br><span class="line">    &#125;;</span><br><span class="line">            </span><br><span class="line">    return f.call(b, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(adder.add(1));         // 输出 2</span><br><span class="line">console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3，其内部的this并没有因为call() 而改变，其this值仍然为函数inFun的this值，指向对象adder</span><br></pre></td></tr></table></figure><p>bind() &amp; apply() 读者可以自行测试</p><p>对于是否严格模式示例代码（可以复制进控制台进行验证）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var f = () =&gt; &#123;&apos;use strict&apos;; return this&#125;;</span><br><span class="line">var p = () =&gt; &#123; return this&#125;;</span><br><span class="line">console.log(1,f() === window);</span><br><span class="line">console.log(2,f() === p());</span><br><span class="line">//1 true</span><br><span class="line">//2 true</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144613820-1277977431.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>以上的箭头函数都是在方法内部，总之都是以非方法的方式使用，如果将箭头函数当做一个方法使用会怎样呢？<br>上例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  i: 10,</span><br><span class="line">  b: () =&gt; console.log(this.i, this),</span><br><span class="line">  c: function() &#123;</span><br><span class="line">    console.log( this.i, this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b();  // undefined window&#123;...&#125;</span><br><span class="line">obj.c();  // 10 Object &#123;...&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144630663-1545275969.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>可以看到，作为方法的箭头函数this指向全局window对象，而普通函数则指向调用它的对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;this-指向详细解析（箭头函数）&quot;&gt;&lt;a href=&quot;#this-指向详细解析（箭头函数）&quot; class=&quot;headerlink&quot; title=&quot;this 指向详细解析（箭头函数）&quot;&gt;&lt;/a&gt;this 指向详细解析（箭头函数）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>箭头函数this</title>
    <link href="https://tianjiec.top/2018/12/24/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this/"/>
    <id>https://tianjiec.top/2018/12/24/箭头函数this/</id>
    <published>2018-12-24T04:03:14.000Z</published>
    <updated>2018-12-24T05:07:13.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h3><p>由于箭头函数不绑定this，他会捕捉所在上下文的this值，作为自己的this值，</p><p>​    1、所以call()/apply()/bind() 方法对于箭头函数来说只是传入参数，对他的this值毫无影响。</p><p>​    2、考虑到this是语法层面上的，严格模式中this相关的规则都可以忽略。（可以忽略是否在严格模式下的影响）</p><p>因为箭头函数可以捕获其上下文的this值所以</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line">     setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 回调里面的 `this` 变量就指向了期望的那个对象了</span></span><br><span class="line">        <span class="keyword">this</span>.age++;</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>以上代码可以得到我们所以希望的值，下图可以看到，在setTimeout中的this指向了构造函数新生成的对象，而普通函数指向了全局window对象</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144556179-936108349.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adder = &#123;</span><br><span class="line">  base : <span class="number">1</span>,</span><br><span class="line">    </span><br><span class="line">  add : <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="keyword">this</span>.base;</span><br><span class="line">    <span class="keyword">return</span> f(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addThruCall: <span class="function"><span class="keyword">function</span> <span class="title">inFun</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="keyword">this</span>.base;</span><br><span class="line">    <span class="keyword">var</span> b = &#123;</span><br><span class="line">      base : <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> f.call(b, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(adder.add(<span class="number">1</span>));         <span class="comment">// 输出 2</span></span><br><span class="line"><span class="built_in">console</span>.log(adder.addThruCall(<span class="number">1</span>)); <span class="comment">// 仍然输出 2（而不是3，其内部的this并没有因为call() 而改变，其this值仍然为函数inFun的this值，指向对象adder</span></span><br></pre></td></tr></table></figure><p>bind() &amp; apply() 读者可以自行测试</p><p>对于是否严格模式示例代码（可以复制进控制台进行验证）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="string">'use strict'</span>; <span class="keyword">return</span> <span class="keyword">this</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>,f() === <span class="built_in">window</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>,f() === p());</span><br><span class="line"><span class="comment">//1 true</span></span><br><span class="line"><span class="comment">//2 true</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144613820-1277977431.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>以上的箭头函数都是在方法内部，总之都是以非方法的方式使用，如果将箭头函数当做一个方法使用会怎样呢？<br>上例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  i: <span class="number">10</span>,</span><br><span class="line">  b: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.i, <span class="keyword">this</span>),</span><br><span class="line">  c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.i, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b();  <span class="comment">// undefined window&#123;...&#125;</span></span><br><span class="line">obj.c();  <span class="comment">// 10 Object &#123;...&#125;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/777834/201706/777834-20170620144630663-1545275969.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>可以看到，作为方法的箭头函数this指向全局window对象，而普通函数则指向调用它的对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;箭头函数中的this&quot;&gt;&lt;a href=&quot;#箭头函数中的this&quot; class=&quot;headerlink&quot; title=&quot;箭头函数中的this&quot;&gt;&lt;/a&gt;箭头函数中的this&lt;/h3&gt;&lt;p&gt;由于箭头函数不绑定this，他会捕捉所在上下文的this值，作为自己的thi
      
    
    </summary>
    
    
  </entry>
  
</feed>
